#### Construct
#### David Bustos
####
### This is the top-level script for cons.  It defines my OCaml extensions and
### then moves to the Conscript file in this directory.
###
### To use cons, run "cons -t <targets>" from any subdirectory of this one.
### <targets> is a list of file or directory names.  If a directory is
### specified, all targets in that directory are built.  (Hence, "cons -t ."
### in the top-level directory builds everything.)  If no targets are listed,
### the default targets identified in the config files are built.
###
### To make a cons file for your directory, see one of the Conscript files.
###
### For more information on cons, see the homepage at
### http://www.dsmit.com/cons/, or view the manual with "perldoc cons".

#### David's Muy Advanced OCaml Cons Extensions ##############################
#
# Revision History
#  2001/04/22	bustos	Initial version
#
#  2001/05/01	bustos	Allowed for ocamllex files with explicit signatures
#
#  2001/05/04	bustos	Added dependency scanning for programs scan::ocamlprog
#
#  2001/05/05	bustos	Wrote "Revision History"
#			Made scan::ocamlprog object-suffix independent
#
#  2001/05/06	bustos	Updated comments
#
#  2001/07/03   geoff   Wrote vastly better version of includes()
#
#  2002/01/11	bustos	Rewrote:
#			- Code in builders, rather than scanners
#			- Timestamps for all files
#			- Module dependency caching
#			- Automatic include directory computation
#			- .output file detection
#			- Fixed 'inconsistent assumptions over implementation'
#			  bug
#
#  2002/01/14	bustos	*Really* fixed 'inconsistent assumptions...' bug.
#
#  2002/03/10	bustos	Adapted for MetaPRL.
#  			- Recognizes .mlz files.
#  			- Does not compute include flags.
#  			- Uses hidden dependencies (HIDDEPS and HIDMODDEPS).
#  			- Uses ocamldep when available.
#  			- Preprocesses files before scanning when necessary.
#  			- Knows that prlc produces .cmiz and .cmoz files.

use strict;

package build::command::ocaml;

use vars qw( @ISA %modfiles %moddeps );

# modfiles maps module names to array references.  The arrays contain four
# file references.  The first is the code for that module, the second is the
# object file for the module, the third is the signature file (if it exists,
# undefined if it's not), and the fourth is the compiled signature file.

# moddeps maps module names to array references.  The arrays contain the names
# of included modules.

BEGIN { @ISA = qw(build::command) }

#
# Utilities
#

# Finds a file in the same directory as the given file, but with a different
# suffix.  Put this into the file package so that we can use it as a method on
# file objects.
sub file::lookup_sibling {
    ## Called with a file and a suffix
    my($file,$suffix) = @_;

    $file->{dir}->lookupfile($file->base_suf($suffix));
}


### Returns true if the given environment calls for producing native code.
sub is_native_env {
    my($env) = @_;
    $env->{OCAMLC} =~ /^ocamlopt(?:\.opt)?$/o;
}

# Returns the name of the module that a file produces.
sub module_of_file {
    $_ = ucfirst @_[0]->{entry};
    s/\..*$//o;
    $_
}


#
# User Interface (i.e., functions called from Conscript files)
#
# These need to be in the cons package so they can be called as methods of
# cons environment objects.
#

### User interface for setting up build instructions for OCaml sources.  Given
### an environment and a list of filenames, it determines the type of each
### file and sets up the corresponding build dependencies.
sub cons::OCamlSources {
    ## Called with an environment and source filenames
    my($env) = shift;

    ## Loop through the source file objects
    foreach my $filename (@_) {

	my $src = $dir::cwd->lookupfile($env->_subst($filename));
	my $suf = $src->suffix;

	## Is this an OCaml source file?
	if ($suf eq ".ml") {
	    ## Does the corresponding signature file exist?
	    my($sig) = $src->lookup_sibling($env->{SUFSIG});

	    ocaml_module($env, $src, $sig->accessible ? $sig : undef);
	}

	## Is this an ocamllex file?
	elsif ($suf eq ".mll") {
	    ## ocamllex produces an OCaml source file
	    my($mlsrc) = $src->lookup_sibling($env->{SUFSRC});
	    $mlsrc->bind((find build::command::user($env, $env->{LEXCOM})),
			 $src);

	    ## Does the corresponding .mli file exist?
	    my($sig) = $mlsrc->lookup_sibling($env->{SUFSIG});

	    ocaml_module($env, $mlsrc, $sig->accessible ? $sig : undef);
	}

	## Is this an ocamlyacc file?
	elsif ($suf eq ".mly") {
	    ## ocamlyacc produces an OCaml source file and a signature file
	    my @tgt_sufs = ($env->{SUFSRC}, $env->{SUFSIG});

	    # And maybe a .output file.
	    if ($env->{YACCCOM} =~ /-v/) { push @tgt_sufs, ('.output') }

	    my @tgts = map($src->lookup_sibling($_), @tgt_sufs);

	    my $cbuild = find build::command::user($env, $env->{YACCCOM});
	    my $builder = build::multiple->new($cbuild, \@tgts);
	    foreach my $tgt (@tgts) { $tgt->bind($builder, $src) };

	    ocaml_module($env, @tgts[0], @tgts[1]);
	}

	elsif ($suf eq ".mlz") {
	    if ($env->{OCAMLC} !~ /prlc/) {
		my $builder = find build::command::user($env, "ln -s %1:f %>");
		my $real_src = $src->lookup_sibling($env->{SUFSRC});
		$real_src->bind($builder, $src);
		ocaml_module($env, $real_src, undef);
	    } else {
		my $builder = find build::command::user($env, "ln -s %1:f %>");
		my $real_src = $src->lookup_sibling($env->{SUFSRC});
		my $real_sig = $src->lookup_sibling($env->{SUFSIG});
		$real_src->bind($builder, $src);
		$real_sig->bind($builder, $src);
		ocaml_module($env, $real_src, $real_sig);
	    }
	}

	## What kind of file is this?
	else {
	    my($file) = $src->path;
	    die "Unrecognized file $file\n";
	}
    }
}


### User interface for declaring a program target.  Given an environment, the
### name of the program, and the modules required to build it, this sets up
### the dependencies.
sub cons::OCamlProgram {
    ## Called with an environment, a program name, and module names
    my($env, $prog, @modules) = @_;

    ## Get the file for the program
    my($tgt) = $dir::cwd->lookupfile($prog);

    ## Get objects for the modules
    my @objects = map {
	$modfiles{ucfirst $_}->[1] ||
	    die "OCamlProgram($prog): Don't know where module $_ is.\n"
    } @modules;

    ## The program depends on its module's objects with the linking command
    $tgt->bind((find build::command::ocaml::prog($env)), @objects);
}


### User interface for declaring a library target.  Given an environment, the
### name of the library, and the modules to put in it, this sets up the
### dependencies.
sub cons::OCamlLibrary {
    ## Called with an environment, a library name, and module names
    my($env) = shift;

    ## Get the object for the library
    my($libname) = shift;
    my($lib) = $dir::cwd->lookupfile($libname . $env->{SUFLIB});

    ## Get objects for the modules
    my(@objects) = map($lib->{dir}->lookupfile($_ . $env->{SUFOBJ}), @_);

    ## The library depends on the objects.  Use ARCOM to build it.
    my($builder) = find build::command::user($env, $env->{ARCOM});
    if (! is_native_env($env)) {
	$lib->bind($builder, @objects);
    }
    else {
	## the native compiler also produces a .a file
	## Can't use lookup_sibling here because base_suf won't remove a
	## four-letter suffix.
	my($natlib) = $lib->{dir}->lookupfile("$libname.a");
	my($multi) = build::multiple->new($builder, [$lib, $natlib]);
	$lib->bind($multi, @objects);
	$natlib->bind($multi, @objects);
    }
}


#
# Given a cons environment, a source file, and a signature file (may be
# undefined), set up the apropriate bindings.
#
sub ocaml_module {
    my($env, $src, $sig) = @_;

    $env->{_IFLAGS} = join(' ', map('-I '.$dir::cwd->lookup($_)->path,
				    ('.', @{$env->{INCPATH}})));

    # Get the associated object and compiled signature files
    my $obj = $src->lookup_sibling($env->{SUFOBJ});
    my $csig = $src->lookup_sibling($env->{SUFCSIG});

    # Tell the builder about this module
    module_files(module_of_file($src), $src, $obj, $sig, $csig);

    # Copy HIDMODDEPS from the environment to the source file, since it would
    # otherwise be inaccessible (frome the source file).
    $src->{HIDMODDEPS} = $env->{HIDMODDEPS};

    # Look up hidden dependencies so they can pushed onto dependency lists.
    my @hiddeps = map($dir::cwd->lookupfile($_), split(' ', $env->{HIDDEPS}));

    # Depending on whether there's a signature file and whether we're using
    # the native compiler, bind derived files to their sources.
    if (defined $sig) {
	if ($env->{OCAMLC} !~ /prlc/) {
	    # We have a signature.  The compiled signature is always produced
	    # by running the OCaml builder on the signature file
	    my $builder = find build::command::ocaml($env);
	    $csig->bind($builder, $sig);

	    push @{$csig->{dep}}, @hiddeps;

	    # The object, on the other hand, will be accompanied by a native
	    # object file if we're using the native compiler.
	    if (! is_native_env($env)) {
		$obj->bind($builder, $src);
	    }
	    else {
		my $natobj = $src->lookup_sibling(".o");

		$builder = build::multiple->new($builder, [$obj, $natobj]);

		$obj->bind($builder, $src);
		$natobj->bind($builder, $src);

		push @{$natobj->{dep}}, @hiddeps;
	    }

	    # Make sure the compiled signature is built before the object.
	    push @{$obj->{dep}}, ($csig, @hiddeps);

	    # The object file (unfortunately) depends on the objects of its
	    # included modules.
	    $obj->{depends_on_objects} = 1;
	} else {
	    my $csigz = $src->lookup_sibling(".cmiz");
	    my $objz = $src->lookup_sibling(".cmoz");

	    my $builder = find build::command::ocaml($env);
	    my $mbuild = build::multiple->new($builder, [$csig, $csigz]);
	    $csig->bind($mbuild, $sig);
	    $csigz->bind($mbuild, $sig);

	    if (! $env->{OCAMLC} =~ /-opt/) {
		my $mbuild = build::multiple->new($builder, [$obj, $objz]);
		$obj->bind($mbuild, $src);
		$objz->bind($mbuild, $src);
	    } else {
		my $natobj = $src->lookup_sibling(".o");

		my $mbuild = build::multiple->new($builder, [$obj, $natobj, $objz]);

		map { $_->bind($mbuild, $src) } ($obj, $natobj, $objz);

		push @{$natobj->{dep}}, @hiddeps;
	    }

	    map {push @{$_->{dep}}, @hiddeps} ($csig, $csigz, $obj, $objz);

	    push @{$obj->{dep}}, ($csig);

	    $obj->{depends_on_objects} = 1;
	}
    }
    else {
	# No signature.  Everything (object, compiled signature, and possible
	# native object) is produced by one command.

	my @tgts = ($obj, $csig);

	if (is_native_env($env)) { push @tgts, ($src->lookup_sibling(".o")); }

	my $builder =
	    build::multiple->new(find build::command::ocaml($env), \@tgts);

	foreach my $tgt (@tgts) {
	    $tgt->bind($builder, $src);

	    push @{$tgt->{dep}}, @hiddeps;

	    # Since all of the targets are produced with one command, they all
	    # depend on the objects of their included modules.  See
	    # build::command::ocaml::includes below for more information.
	    $tgt->{depends_on_objects} = 1;
	};
    }
}


#
# Meat of the builder
#

# Register the files associated with a module in the module directory.
sub module_files {
    my($mod, $src, $obj, $sig, $csig) = @_;

    if ($script::ARG{DEBUG} && exists $modfiles{$mod}) {
	print "module_files: Ieeeee!  I already know about module $mod.\n";
    }

    $modfiles{$mod} = [$src, $obj, $sig, $csig];
}

# Return a builder for the given environment.
sub find {
    my($class, $env) = @_;

    # I guess we'll just have a different builder for each environment.
    $env->{_ocaml} || do {
	my($self) = find build::command($env, $env->{OCAMLCOM});
	bless ($env->{_ocaml} = $self);
    }
}

# Scan a file and return a list of the (names of the) modules it uses.
sub scan_file {
    my($self, $src) = @_;

    my %includes;

    # Inform the user, if he wants.
    print "Scanning ".$src->path."\n" if ($script::ARG{SCAN});

    # If the file needs to be preprocessed, do so
    my $filename;	# File to scan

    if ($self->{com} =~ /-pp '(.*?)'/) {
	use File::Temp qw/ tempfile /;
	my ($fh, $fn) =
	    tempfile("cons_scan-XXXX", SUFFIX => ".ml", UNLINK => 1);
	$filename = $fn;
	my $command = $1;
	if ($command =~ /\.cmo/) {
	    $command =~ s/(.*\.cmo)/$1 pr_o.cmo/;
	} else {
	    $command .= " pr_o.cmo";
	}
	$command .= " " . $src->path . " > $filename";
	print "Executing `$command' before scanning.\n" if ($script::ARG{DEBUG});
	system($command);
    } else {
	$filename = $src->path;
    }

    # Scan the file.  Use ocamldep if we know where it is.

    my $ocamldep = $self->{env}->{OCAMLDEP};
    my @mods;

    if ($ocamldep) {
	# Make sure it's built
	my($command) = $ocamldep =~ /\s*(\S*)/;
	my $bin = $dir::top->lookupfile($command);
	if ((build $bin) eq 'errors') {
	    $ocamldep = '';
	} else {
	    print "Executing `$ocamldep $filename' to scan.\n" if ($script::ARG{DEBUG});
	    @mods = split(' ', `$ocamldep $filename`);
	}
    }

    if (! $ocamldep) {
	my %includes;

	die "Couldn't open `".$src->rpath."' for scanning."
	    unless open(SCAN, $src->rpath);

	while(<SCAN>) {
	    s/"[^"]*?"//go;		# Remove literal strings from $_

	    # Since the regular expressions here are in list context, they
	    # return lists of matched strings.  Those strings are then entered
	    # into the %includes hash, so that its keys will be a uniquified
	    # list of modules.
	    foreach (/open\s+([A-Z]\w*)/go,	# Search $_ for "open Module"
		     /([A-Z]\w*)\.\w+/go)	# Search $_ for "Module.blah"
	    {
		$includes{$_} = 1;
	    }
	}
	close(SCAN);

	@mods = keys %includes;
    }

    return @mods;
}

#
# Given an OCaml source file, return a list of the modules it uses.
#
sub get_included_modules {
    my($self, $src) = @_;

    print "get_included_modules(".$src->path.")\n" if ($script::ARG{DEBUG});

    return $self->get_included_modules_for_module(module_of_file($src));
}

sub get_included_modules_for_module {
    my($self, $mod) = @_;

    print "get_included_modules_for_module($mod)\n" if ($script::ARG{DEBUG});

    if (exists $moddeps{$mod}) { return @{$moddeps{$mod}} }

    my %includes;

    return () if ! exists $modfiles{$mod};

    my $files = $modfiles{$mod};
    my $file = $files->[0];

    map { $includes{$_} = 1 } $self->get_included_modules_for_file($file);
    $file = $files->[2];
    map { $includes{$_} = 1 } $self->get_included_modules_for_file($file)
    if (defined $files->[2]);

    my @includes = keys %includes;

    $moddeps{$mod} = \@includes;

    @includes;
}

sub get_included_modules_for_file {
    my($self, $file) = @_;

    print "get_included_modules_for_file(".$file->path.")\n"
	if ($script::ARG{DEBUG});

    # Make sure the file is built, if necessary
    if ((build $file) eq 'errors') {
	# XXX Should propogate error here... but how?
	return ();
    }

    # Retrieve the list of included modules for this file from the
    # corresponding .consign file.  I've arranged to have this placed in the
    # builder_data attribute of the file, through the sig::md5::signature
    # function.
    'sig'->signature($file);
    my $mods = $file->{builder_data};

    my @includes;

    if ($mods) {
	@includes = ($mods eq '-') ? () : split(' ', $mods);
    } else {
	# Either we don't have a list from the .consign file, or the file has
	# changed since the list was made.
	@includes = $self->scan_file($file);

	# Cache the resulting list.
	$file->{builder_data} = (@includes) ? join(' ', @includes) : '-';
	$sig::hash::dirty{$file->{dir}} = $file->{dir};
    }

    push @includes, split(' ', $file->{HIDMODDEPS});
    return @includes;
}

#
# Returns a list of modules that the given source files depend on.  The
# resulting list should be closed with respect to dependencies.
#
sub get_included_modules_recursive {
    my($self, @srcs) = @_;

    print "get_included_modules_recursive(".join(', ', map($_->path, @srcs)).")\n"
	if ($script::ARG{DEBUG});

    my %modules;	# We'll return the keys of this
    my @mods;		# This will be a queue of modules to be included

    # Initialize the queue
    @mods = map { $self->get_included_modules_for_module(module_of_file($_)); } @srcs;

    while (my $mod = pop @mods) {
	next if exists $modules{$mod};

	$modules{$mod} = 1;

	push @mods, $self->get_included_modules_for_module($mod);
    }

    keys %modules;
}

#
# Return a signature of the dynamic predependencies of $tgt.  Build them, too.
#
sub includes {
    my($self, $tgt) = @_;

    print "includes(".$tgt->path.")\n" if ($script::ARG{DEBUG});

    # Collect the modules included by all sources of $tgt (as keys of %modules).
    my(%modules);
    # Apparently map'ing on referenced arrays is a bad idea, so we have to
    # copy $tgt->{sources}, I guess.
    my @srcs = @{$tgt->{sources}};
    map { $modules{$_} = 1 } (map $self->get_included_modules($_), @srcs);
    map { $modules{$_} = 1 } (split(' ', $tgt->{builder}->{env}->{HIDMODDEPS}));

    my $sig = '';

    # Build and get signatures for the compiled signatures of the included
    # modules.
    for my $mod (sort keys %modules) {
	if (exists $modfiles{$mod}) {
	    my $modfiles = $modfiles{$mod};
	    my($csig) = $modfiles->[3];
	    next if $csig eq $tgt;
	    if ((build $csig) eq 'errors') {
		$tgt->{status} = 'errors';
		return '';
	    }

	    $sig .= 'sig'->signature($csig);

	    # Possibly build the object for the included module.  This is
	    # necessary because some OCaml files depend on the implementation
	    # of their included modules.  Specifically, object files.
	    #
	    # We need a more general condition here (than just detecting when
	    # we're working on an object file) because (thanks to
	    # build::multiple), sometimes we will be called on a compiled
	    # signature file and the command which eventually produces it also
	    # produces an object file (i.e., when there is no explicit
	    # signature file.)
	    if ($tgt->{depends_on_objects}) {
		my $obj = $modfiles->[1];
		next if $obj eq $tgt;
		if ((build $obj) eq 'errors') {
		    $tgt->{status} = 'errors';
		    return '';
		}

		$sig .= 'sig'->signature($obj);
	    }
	}
	else {
	    if ($script::ARG{DEBUG}) {
		print "includes/build: Don't know where module $mod is.\n";
	    }
	}
    }

    $sig
}


#
# A builder for OCaml programs.
#
package build::command::ocaml::prog;

use vars qw( @ISA );

BEGIN { @ISA = qw(build::command::ocaml) }

sub find {
    my($class, $env) = @_;

    $env->{_ocamlprog} || do {
	my $self = find build::command($env, $env->{LINKCOM});
	bless ($env->{_ocamlprog} = $self);
    }
}

#
# Return a signature of the dynamic predependants of the given target.
#
sub includes {
    my($self, $tgt) = @_;

    my %modules;
    my @objs = @{$tgt->{sources}};
    my @srcs = map $_->lookup_sibling($self->{env}->{SUFSRC}), @objs;
    map { $modules{$_} = 1 }
	(map $self->get_included_modules_recursive($_), @srcs);

    my $sig = '';

    for my $mod (sort keys %modules) {
	if (exists $build::command::ocaml::modfiles{$mod}) {
	    my $modfiles = $build::command::ocaml::modfiles{$mod};
	    my $obj = $modfiles->[1];
	    if ((build $obj) eq 'errors') {
		$tgt->{status} = 'errors';
		return '';
	    }

	    $sig .= 'sig'->signature($obj);
	}
	else {
	    if ($script::ARG{DEBUG}) {
		print "ocaml::prog::includes: Don't know where module $mod is.\n";
	    }
	}
    }

    $sig
}

#
# Called by file::_build to actually build an object.  Here we use the module
# dependency information (in %build::command::ocaml::moddeps) to create the
# topologically-ordered list of objects necessary to build the program, and
# then defer to build::command::action to actually execute the command.
#
sub action {
    my($self, $tgt) = @_;

    print "ocaml::prog::action(", $tgt->path, ")\n" if ($script::ARG{DEBUG});

    my $env = $self->{env};

    my @objs = @{$tgt->{sources}};

    # Build a dependency dag

    # Queue of modules to be added to the graph
    my @mods = map(build::command::ocaml::module_of_file($_), @objs);

    my %nodes = map { $_ => {deps => [], predepcnt => 0} } @mods;

    my %done;

    while (my $mod = pop @mods) {
	next if exists $done{$mod};
	$done{$mod} = 1;
	my @predeps = $self->get_included_modules_for_module($mod);
	for my $predep (@predeps) {
	    my $node = $nodes{$predep} ||
		($nodes{$predep} = {deps => [], predepcnt => 0});
	    push @{$node->{deps}}, $mod;
	    ++$nodes{$mod}->{predepcnt};
	}
	push @mods, @predeps;
    }

    # Create a topologically-ordered list of objects
    @objs = ();
    my @nopredeps = grep($nodes{$_}->{predepcnt} == 0, keys %nodes);
    while (my $mod = pop @nopredeps) {
	my $files = $build::command::ocaml::modfiles{$mod};
	my $file = $files->[1];
	push @objs, $file;
	for my $dep (@{$nodes{$mod}->{deps}}) {
	    my $node = $nodes{$dep};
	    --$node->{predepcnt};
	    if ($node->{predepcnt} == 0) {
		push @nopredeps, $dep;
	    }
	}
    }

    # Set the sources of the target to created list
    $tgt->{sources} = \@objs;

    # Build the target
    build::command::action($self, $tgt);
}


#
# The rest of the code redefines functions in cons in order to get it to do
# what we want.
#

package sig::md5;

#
# Redefine sig::md5::signature so that it will store timestamps for all files,
# even derived ones.  This way we can use timestamps instead of md5 sums for a
# speedup, and also tell whether the file needs to be rescanned.
#
sub signature {
    if (defined $_[1]->{sig}) {
	return $_[1]->{sig};
    }
    my ($self, $file) = @_;
    my($path) = $file->path;
    my($time) = (stat($path))[9];
    if ($time) {
	my($sigtime) = sig::hash::in($file);
	if ($file->is_on_rpath) {
	    if ($sigtime) {
		my ($htime, $hsig) = split(' ',$sigtime);
		if (! $hsig) {
		    # There was no separate $htime recorded in
		    # the .consign file, which implies that this
		    # is a source file in the repository.
		    # (Source file .consign entries don't record
		    # $htime.)  Just return the signature that
		    # someone else conveniently calculated for us.
		    return $htime;	# actually the signature
		} else {
		    if (! $param::rep_sig_times_ok || $htime == $time) {
			return $file->{sig} = $hsig;
		    }
		}
	    }
	    return $file->{sig} = $file->path . $time;
	}
	if ($sigtime) {
	    my ($htime, $hsig) = split(' ',$sigtime);
	    if ($htime eq $time) {
		return $file->{sig} = $hsig;
	    }
	}
	if (! File::Spec->file_name_is_absolute($path)) {
	    # A file in the local build directory. Assume we can write
	    # a signature file for it, and compute the actual source
	    # signature. We compute the file based on the build path,
	    # not source path, only because there might be parallel
	    # builds going on... In principle, we could use the source
	    # path and only compute this once.
	    my($sig) = srcsig($path);
	    sig::hash::out($file, "$time $sig");
	    # Invalidate the builder_data.
	    delete $file->{builder_data};
	    return $file->{sig} = $sig;
	} else {
	    return $file->{sig} = $file->{entry} . $time;
	}
    }
    $file->{sig} = '';
}

package sig::hash;

#
# Redefine sig::hash::in so that it sets the builder_data field of the file
# object to the extra info in the file's .consign entry.
#
sub in {
    my($file)= @_;
    my($dir) = $file->{dir};
    my $data = ($dir->{consign} || init($dir))->{$file->{entry}};
    my @array = split(' ', $data, 3);

    # If there's no extra field, then just return
    return $data unless $array[2];

    # Set the file's builder_data field to the extra field, but don't mess
    # with anything that was already there.
    $file->{builder_data} = $array[2] unless exists $file->{builder_data};

    # Strip off the last field, so we don't repeat this processing.
    return ($dir->{consign}->{$file->{entry}} = join(' ', ($array[0], $array[1])));
}


#
# Redefine sig::hash::END so that it writes the latest version of the
# builder_data for each file into the .consign files.
#
sub END {
    return if $called++; # May be called twice.
    close(CONSIGN); # in case this came in via ^C.
    my $dir;
    for $dir (values %sig::hash::dirty) {
	my($consign) = $dir->prefix . ".consign";
	my($constemp) = $consign . ".$$";
	if (! open(CONSIGN, ">$constemp")) {
	    die("$0: can't create $constemp ($!)\n");
	}
	# Write a new .consign file for this directory
	my($entry, $data);
	while (($entry, $data) = each %{$dir->{consign}}) {
	    my $file = $dir->lookupfile($entry);
	    $data .= ' ' . $file->{builder_data} if exists $file->{builder_data};
	    if (! print CONSIGN "$entry:$data\n") {
		die("$0: error writing to $constemp ($!)\n");
	    }
	}
	close(CONSIGN);
	if (! rename($constemp, $consign)) {
	    if (futil::copy($constemp, $consign)) {
		unlink($constemp);
	    } else {
		die("$0: couldn't rename or copy $constemp to $consign " .
		    "($!)\n");
	    }
	}
    }
}


package script;


### Continue with a top-level Conscript file

Build qw( Conscript );
