#### Construct
#### David Bustos
####
### This is the top-level script for cons.  It defines my OCaml extensions and
### then moves to the Conscript file in this directory.
###
### To use cons, run "cons -t <targets>" from any subdirectory of this one.
### <targets> is a list of file or directory names.  If a directory is
### specified, all targets in that directory are built.  (Hence, "cons -t ."
### in the top-level directory builds everything.)  If no targets are listed,
### the default targets identified in the config files are built.
###
### To make a cons file for your directory, see one of the Conscript files.
###
### For more information on cons, see the homepage at
### http://www.dsmit.com/cons/, or view the manual with "perldoc cons".


#### David's Muy Advanced OCaml Cons Extensions ##############################
#
# Revision History
#  2001/04/22	bustos	Initial version
#
#  2001/05/01	bustos	Allowed for ocamllex files with explicit signatures
#
#  2001/05/04	bustos	Added dependency scanning for programs scan::ocamlprog
#
#  2001/05/05	bustos	Wrote "Revision History"
#			Made scan::ocamlprog object-suffix independent
#
#  2001/05/06	bustos	Updated comments
#
#  2001/07/03   geoff   Wrote vastly better version of includes()

use strict;

### Finds a file in the same directory as the given file, but with a different
### suffix.
sub cons::lookup_sibling {
    ## Called with a file and a suffix
    my($file,$suffix) = @_;

    $file->{dir}->lookupfile($file->base_suf($suffix));
}


### Returns true if the given environment calls for producing native code.
sub cons::is_native_env {
    my($env) = @_;
    $env->{OCAMLC} =~ /^ocamlopt(?:\.opt)?$/o;
}


### This is a QuickScan dependency scanner for OCaml.  It is called for each
### line of the file being scanned and returns files that the given file
### depends on.  This one works by looking for "open Module" or "Module." in
### the text.
my $ocamlscan = sub {
	my (@modules);

	s/"[^"]*?"//go;	# Remove double quoted strings from $_

	push @modules, /open\s+([A-Z]\w*)/go;	# Search $_ for "open Module"
	push @modules, /([A-Z]\w*)\.\w+/go;	# Search $_ for "Module.var"

	## Convert the Modules into filenames and return the list
	map(("$_.cmi", "$_.cmx"), map(lcfirst $_, @modules));
};


### Sets up build instructions for an OCaml source file with a corresponding
### signature file.
sub cons::module_with_signature {
    ## Called with an environment, a source file, and a signature file
    my($env, $src, $sig) = @_;

    ## Compute the include flags from $env->{INCPATH}
    $env->{_IFLAGS} = join(" ", map("-I ".$dir::cwd->lookup($_)->path,
				    (".", @{$env->{INCPATH}})));

    ## The compiled signature depends on the signature file
    my($csig) = cons::lookup_sibling($sig, $env->{SUFCSIG});
    $csig->bind((find build::command::user($env, $env->{SIGCOM})), $sig);

    ## The object file depends on the source file and the compiled signature
    my($obj) = cons::lookup_sibling($src, $env->{SUFOBJ});
    my($builder) = find build::command::user($env, $env->{OCAMLCOM});

    if (! cons::is_native_env($env)) {
	$obj->bind($builder, ($src, $csig));
    }
    else {
	## the native compiler also produces a .o file
	my($natobj) = cons::lookup_sibling($src, ".o");
	my($multi) = build::multiple->new($builder, [$obj, $natobj]);
	$obj->bind($multi, ($src, $csig));
	$natobj->bind($multi, ($src, $csig));
    }

    ## Scan the signature and the source for other dependencies
    $sig->{'srcscan',$env} = find scan::quickscan($ocamlscan, $env, $env->{INCPATH});
    $src->{'srcscan',$env} = find scan::quickscan($ocamlscan, $env, $env->{INCPATH});
}


### Sets up build instructions for an OCaml source file without a
### corresponding signature file.
sub cons::module_without_signature {
    ## Called with an environment and a source file
    my($env, $src) = @_;

    ## Compute the include flags from $env->{INCPATH}
    $env->{_IFLAGS} = join(" ", map("-I ".$dir::cwd->lookup($_)->path,
				    (".", @{$env->{INCPATH}})));

    ## The object and the compiled signature depend on the source file
    my($obj) = cons::lookup_sibling($src, $env->{SUFOBJ});
    my($csig) = cons::lookup_sibling($src, $env->{SUFCSIG});
    my($builder) = find build::command::user($env, $env->{OCAMLCOM});

    my($multi);
    if (! cons::is_native_env($env)) {
	$multi = build::multiple->new($builder, [$obj, $csig]);
    }
    else {
	## the native compiler also produces a .o file
	my($natobj) = cons::lookup_sibling($src, ".o");
	$multi = build::multiple->new($builder, [$csig, $obj, $natobj]);
	$natobj->bind($multi, $src);
    }

    $csig->bind($multi, $src);
    $obj->bind($multi, $src);

    ## Scan the source and the signature for other dependencies
    $src->{'srcscan',$env} = find scan::quickscan($ocamlscan, $env, $env->{INCPATH});
}


### User interface for setting up build instructions for OCaml sources.  Given
### an environment and a list of filenames, it determines the type of each
### file and sets up the corresponding build dependencies.
sub cons::OCamlSources {
    ## Called with an environment and source filenames
    my($env) = shift;

    ## Get file objects for the filenames
    my(@srcs) = map($dir::cwd->lookupfile($env->_subst($_)), @_);

    ## Loop through the source file objects
    foreach my $src (@srcs) {

	## Is this an OCaml source file?
	if ($src->suffix eq ".ml") {
	    ## Does the corresponding .mli file exist?
	    my($sig) = cons::lookup_sibling($src, $env->{SUFSIG});

	    if (-e $sig->path) {	# the signature file exists
		cons::module_with_signature($env, $src, $sig);
	    }
	    else {			# the signature file doesn't exist
		cons::module_without_signature($env, $src);
	    }
	}

	## Is this an ocamllex file?
	elsif ($src->suffix eq ".mll") {
	    ## ocamllex produces an OCaml source file
	    my($mlsrc) = cons::lookup_sibling($src, $env->{SUFSRC});
	    $mlsrc->bind((find build::command::user($env, $env->{LEXCOM})), $src);

	    ## Does the corresponding .mli file exist?
	    my($sig) = cons::lookup_sibling($mlsrc, $env->{SUFSIG});

	    if (-e $sig->path) {	# the signature file exists
		cons::module_with_signature($env, $mlsrc, $sig);
	    }
	    else {
		cons::module_without_signature($env, $mlsrc);
	    }
	}

	## Is this an ocamlyacc file?
	elsif ($src->suffix eq ".mly") {
	    ## ocamlyacc produces an OCaml source file and a signature file
	    my($mlsrc) = cons::lookup_sibling($src, $env->{SUFSRC});
	    my($sig) = cons::lookup_sibling($src, $env->{SUFSIG});
	    my($builder) = find build::command::user($env, $env->{YACCCOM});
	    my($multi) = build::multiple->new($builder, [$mlsrc, $sig]);
	    $mlsrc->bind($multi, $src);
	    $sig->bind($multi, $src);

	    cons::module_with_signature($env, $mlsrc, $sig);
	}

	## Is this a .mlz file?
	elsif ($src->suffix eq ".mlz") {
	    ## ocamlyacc produces an OCaml source file and a signature file
	    my($mlsrc) = cons::lookup_sibling($src, $env->{SUFSRC});
	    my($builder) = find build::command::user($env, $env->{LNCOM});
	    my($multi) = build::multiple->new($builder, [$mlsrc]);
	    $mlsrc->bind($multi, $src);

	    cons::module_without_signature($env, $mlsrc);
	}

	## What kind of file is this?
	else {
	    my($file) = $src->path;
	    die "Unrecognized file $file\n";	# XXX Should I use die here?
	}
    }
}


### User interface for declaring a program target.  Given an environment, the
### name of the program, and the modules required to build it, this sets up
### the dependencies.
sub cons::OCamlProgram {
    ## Called with an environment, a program name, and module names
    my($env, $prog, @modules) = @_;

    ## Get the object for the program
    my($tgt) = $dir::cwd->lookupfile($prog);

    ## Get objects for the modules
    my(@objects);
    foreach my $name (@modules) {
	my($obj) = $tgt->{dir}->lookup_accessible($name . $env->{SUFOBJ})
		    || $tgt->{dir}->lookupfile($name . $env->{SUFLIB});
	push @objects, ($obj);
    }

    ## The program depends on its module's objects with the linking command
    $tgt->bind((find build::command::user($env, $env->{LINKCOM})), @objects);

    ## Try out the module scanner
    $objects[0]->{'srcscan',$env} = find scan::ocamlprog($env, $env->{INCPATH});
}


### User interface for declaring a library target.  Given an environment, the
### name of the library, and the modules to put in it, this sets up the
### dependencies.
sub cons::OCamlLibrary {
    ## Called with an environment, a library name, and module names
    my($env) = shift;

    ## Get the object for the library
    my($libname) = shift;
    my($lib) = $dir::cwd->lookupfile($libname . $env->{SUFLIB});

    ## Get objects for the modules
    my(@objects) = map($lib->{dir}->lookupfile($_ . $env->{SUFOBJ}), @_);

    ## The library depends on the objects.  Use ARCOM to build it.
    my($builder) = find build::command::user($env, $env->{ARCOM});
    if (! cons::is_native_env($env)) {
	$lib->bind($builder, @objects);
    }
    else {
	## the native compiler also produces a .a file
	## Can't use lookup_sibling here because base_suf won't remove a
	## four-letter suffix.
	my($natlib) = $lib->{dir}->lookupfile("$libname.a");
	my($multi) = build::multiple->new($builder, [$lib, $natlib]);
	$lib->bind($multi, @objects);
	$natlib->bind($multi, @objects);
    }
}


### A scanner for OCaml programs.
package scan::ocamlprog;

use vars qw( @ISA %scanner );

BEGIN { @ISA = qw(scan) }

sub find {
    my($class, $env, $pdirs) = @_;
    if (! defined $pdirs) {
	$pdirs = [ ];
    } elsif (ref($pdirs) ne 'ARRAY') {
	$pdirs = [ split(/$main::PATH_SEPARATOR/o, $pdirs) ];
    }
    my @path = map { $dir::cwd->lookupdir($_) } @$pdirs;
    my($spath) = "@path";
    $scanner{$spath} || do {
	my($self) = { env => $env, 'path' => \@path };
	$scanner{$spath} = bless $self;
    }
}

### The plan (two versions):
###
### 1. Dave's old, horrifically inefficent version:
###      For each file given, find the corresponding source file.  Scan it and add
###      the objects corresponding to the included modules to the @sources list of
###      the target.  Add the corresponding source files to the stack to be
###      scanned, and continue until the stack is empty.
###
### 2. Geoffrey's fast method:
###      Instead of a list of sources, we generate a dependence dag.  Then we apply
###      a topological sort to get a correctly ordered list of sources.

sub includes {

    ## Invoked with a scanner, a target, and a list of files
    my($self, $tgt, @files) = @_;

    my($env) = $self->{env};	# Have the environment on hand for easy access

    my(%signatures);		# signatures of included files
    my($source);		# iteration variable

    ## $self->{includes} is the scanner-specific persistent hash of files and
    ## lists of includes
    my($inc) = $self->{includes} || ($self->{includes} = {});

    ## Find sources for the @files given
    my @work_list = map(cons::lookup_sibling($_, $env->{SUFSRC}), @files);

    my %source_set;

    ## For each file in the queue,
    while ($source = shift @work_list) {
	next if exists $source_set{$source};   # Already seen it.
        $source_set{$source} = $source;

        ## build file and generate includes if necessary
	unless ($inc->{$source}) {
	    ## Build the object file
	    if ((file::build(cons::lookup_sibling($source, $env->{SUFOBJ}))) eq 'errors') {
		$tgt->{status} = 'errors';	# tgt inherits build status
		return ();
	        }

	    ## Scan the file for included files
	    $inc->{$source} = [map(cons::lookup_sibling($_, $env->{SUFSRC}), $self->scan($source))];
	    }

	## Compute the signature
	$signatures{$source} = 'sig'->signature($source->rfile);

	## Put dependencies onto the work list
	push(@work_list, @{$inc->{$source}});

        ## add dependency edges to the dag
        for my $s (@{$inc->{$source}}) {
            $s->{dag_pred}{$source} = $source;
            $source->{dag_succ}{$s} = $s;
            }
        }

    $tgt->{sources} = [];

    ## compute degrees
    for (values %source_set) {
      $_->{dag_degree} = values %{$_->{dag_succ}};
      }

    ## topological sort
    @work_list = grep($_->{dag_degree} == 0, values %source_set);
    while ($source = pop @work_list) {
        push @{$tgt->{sources}}, cons::lookup_sibling($source, $env->{SUFOBJ});
        for (values %{$source->{dag_pred}}) {
          push @work_list, $_ unless --$_->{dag_degree};
          }
        }

    ## Slap all the signatures together and return it
    'sig'->collect(sort values %signatures);
}


### Scan a source file and return the list of signature files it includes
sub scan {

    ## Called with a scanner and a file to scan
    my ($self, $file) = @_;

    ## Try to open the file, and return nothing if it doesn't work
    open(SCAN, $file->rpath) || return ();

    my %includes;	# includes will have the included files

    while(<SCAN>) {
	s/"[^"]*"//go;	# Remove double quoted strings

	## Search for "open Module"
	$includes{$_} = 0 for (/open\s+([A-Z]\w*)/go);

	## Search for "Module.var"
	$includes{$_} = 0 for (/([A-Z]\w*)\.\w+/go);
	}

    close(SCAN);

    my @dirs = ($file->{dir}, @{$self->{path}});
    my @files;
    for (keys %includes) {
        my $name = (lcfirst) . '.cmi';
	for my $dir (@dirs) {
	    my $include = $dir->lookup_accessible($name);
	    if ($include) {
                push @files, $include unless $include->ignore;
		last;
	    }
	}
    }

    @files
}

package script;


### Continue with a top-level Conscript file

Build qw( Conscript );
