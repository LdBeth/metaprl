*** /usr/src/redhat/SOURCES/ocaml-2.00/byterun/extern.c	Thu Jun 11 08:53:45 1998
--- extern.c	Sat Jan  2 11:32:07 1999
***************
*** 13,18 ****
--- 13,19 ----
  
  /* Structured output */
  
+ #include <stdio.h>
  #include <string.h>
  #include "alloc.h"
  #include "fail.h"
***************
*** 25,30 ****
--- 26,81 ----
  #include "reverse.h"
  #include "str.h"
  
+ /* To print out the function symbols */
+ static value function_symbols;
+ 
+ /* Store the symbol array */
+ value ml_extern_symbols(value symbols)
+ {
+     register_global_root(&function_symbols);
+     function_symbols = symbols;
+     return Val_unit;
+ }
+ 
+ /*
+  * Print the function symbol at a location.
+  * Binary search.
+  */
+ static void print_symbol(int pc)
+ {
+     int i, j, k, pos, cpos, length;
+     char *modname;
+     value symbol;
+ 
+     if(function_symbols) {
+         length = Wosize_val(function_symbols);
+         i = -1;
+         j = length;
+         symbol = 0;
+         while(i < j - 1) {
+             k = (i + j) >> 1;
+             symbol = Field(function_symbols, k);
+             pos = Int_val(Field(symbol, 0));
+             if(pos == pc)
+                 break;
+             else if(pos > pc)
+                 j = k;
+             else
+                 i = k;
+         }
+         if(symbol) {
+             modname = String_val(Field(symbol, 1));
+             cpos = Int_val(Field(symbol, 2));
+             if(pos == pc)
+                 fprintf(stderr, "marshaling function (0x%08x): %s/%d\n", pc, modname, cpos);
+             else
+                 fprintf(stderr, "marshaling function (0x%08x:0x%08x): %s/%d\n", pc, pos, modname, cpos);
+         }
+         else
+             fprintf(stderr, "marshaling function (0x%08x)\n", pc);
+     }
+ }
+ 
  /* To keep track of sharing in externed objects */
  
  typedef unsigned long byteoffset_t;
***************
*** 203,208 ****
--- 254,261 ----
    invalid_argument(msg);
  }
  
+ static int closure_level;
+ 
  static void extern_rec(value v)
  {
   tailcall:
***************
*** 312,317 ****
--- 365,384 ----
      case Object_tag:
        extern_invalid_argument("output_value: object value");
        break;
+     case Closure_tag: {
+       mlsize_t i;
+       if (tag < 16 && sz < 8) {
+         Write(PREFIX_SMALL_BLOCK + tag + (sz << 4));
+       } else {
+         writecode32(CODE_BLOCK32, hd & ~Black);
+       }
+       size_32 += 1 + sz;
+       size_64 += 1 + sz;
+       closure_level++;
+       for (i = 0; i < sz; i++) extern_rec(Field(v, i));
+       closure_level--;
+       return;
+       }
      default: {
        mlsize_t i;
        if (tag < 16 && sz < 8) {
***************
*** 329,336 ****
--- 396,409 ----
      return;
    }
    if ((char *) v >= code_area_start && (char *) v < code_area_end) {
+     int i;
      if (!extern_closures)
        extern_invalid_argument("output_value: functional value");
+     if(function_symbols) {
+         for(i = 0; i != closure_level; i++)
+             putc(' ', stderr);
+         print_symbol((char *) v - code_area_start);
+     }
      writecode32(CODE_CODEPOINTER, (char *) v - code_area_start);
      writeblock((char *) code_checksum(), 16);
      return;
