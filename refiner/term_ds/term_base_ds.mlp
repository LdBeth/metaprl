(*
 * This is the module that implements delayed substitution,
 * keeps track of free variables and does some sharing.
 *)

#include "refine_error.h"

open Printf
open Debug
open Opname
open Refine_error_sig
open Term_ds

(*
 * Show the file loading.
 *)
let _ =
   if !debug_load then
      eprintf "Loading Term_ds%t" eflush

let debug_subst =
   create_debug (**)
      { debug_name = "subst";
        debug_description = "Display substition operations";
        debug_value = false
      }

module Term
   (RefineError : RefineErrorSig
    with type level_exp = TermType.level_exp
    with type param = TermType.param
    with type term = TermType.term
    with type bound_term = TermType.bound_term)
=
struct
   (************************************************************************
    * Type definitions                                                     *
    ************************************************************************)

   open TermType
   open RefineError

   type level_exp_var = TermType.level_exp_var
   type level_exp = TermType.level_exp
   type param = TermType.param
   type operator = TermType.operator
   type term = TermType.term
   type bound_term = TermType.bound_term

   type level_exp_var' = TermType.level_exp_var'
   type level_exp' = TermType.level_exp'
   type object_id = TermType.object_id
   type param' = TermType.param'
   type operator' = TermType.operator'
   type term' = TermType.term'
   type bound_term' = TermType.bound_term'

   (*
    * Simple substitution.
    *)
   type term_subst = (string * term) list

   (************************************************************************
    * DEBUGGING                                                            *
    ************************************************************************)

   (*
    * Printer is installed by client.
    *)
   let print_term = ref (fun _ _ -> raise (Failure "Term_ds.print_term: printer not installed"))

   let debug_print out t =
      !print_term out t

   let install_debug_printer f =
      print_term := f

   (************************************************************************
    * Free variables, substitution                                         *
    ************************************************************************)

   let rec bterms_free_vars = function
      [] -> StringSet.empty
    | [bt] -> bt.bfree_vars
    | bt::tl -> StringSet.union (bterms_free_vars tl) bt.bfree_vars

   let rec subst_free_vars = function
      [] -> StringSet.empty
    | [(v,t)] -> t.free_vars
    | (v,t)::tl -> StringSet.union (subst_free_vars tl) t.free_vars

   let do_term_subst sub t =
#ifdef VERBOSE_EXN
      if !debug_subst then
         begin
            eprintf "do_term_subst: %a%t" debug_print t eflush;
            eprintf "\tfree_vars:";
            List.iter (fun name -> eprintf " %s" name) (StringSet.elements t.free_vars);
            eflush stderr;
            List.iter (fun (v, t) -> eprintf "\t%s: %a%t" v debug_print t eflush) sub
         end;
#endif
      match List_util.filter (fun (v,_) -> StringSet.mem v t.free_vars) sub with
         [] -> t
       | sub' ->
            {free_vars =
               StringSet.union
                  (List.fold_right
                     StringSet.remove
                     (List_util.fst_split sub')
                     t.free_vars)
                  (subst_free_vars sub');
             core = Subst (t,sub')}

   let do_bterm_subst sub bt =
      match List_util.filter (fun (v,_) -> StringSet.mem v bt.bfree_vars) sub with
         [] -> bt
       | sub' ->
            {bfree_vars =
               StringSet.union
                  (List.fold_right
                     StringSet.remove
                     (List_util.fst_split sub')
                  bt.bfree_vars)
                     (subst_free_vars sub');
             bcore = BSubst (bt,sub')}

   (************************************************************************
    * Variables in pure terms                                              *
    ************************************************************************)

   exception Not_var

   let var_opname = make_opname ["var"]

   (*
    * See if a term is a variable.
    *)
   let is_var_term_nods = function
      { term_op = { op_name = opname; op_params = [Var v] };
        term_terms = []
      } when opname == var_opname -> true
    | _ -> false

   (*
    * Destructor for a variable.
    *)
   let dest_var_nods = function
      { term_op = { op_name = opname; op_params = [Var v] };
        term_terms = []
      } when opname == var_opname -> v
     | _ -> raise Not_var

   (************************************************************************
    * De/Constructors                                                 *
    ************************************************************************)

   let rec dest_term t =
      match t.core with
         Term tt -> tt
       | Subst (tt,sub) ->
            let ttt = dest_term tt in
            let t4 =
               try dest_term (List.assoc (dest_var_nods ttt) sub)
               with _ ->
                  { term_op = ttt.term_op;
                    term_terms = List.map (do_bterm_subst sub) ttt.term_terms }
            in
               t.core <- Term t4;
               t4

   (*
    * Make a variable.
    *)
   let mk_var_term v =
      { free_vars = StringSet.make v;
        core = Term
         { term_op = { op_name = var_opname; op_params = [Var v] };
           term_terms = [] }}

   let make_term = function
      { term_op = { op_name = opname; op_params = [Var v] };
        term_terms = []
      } when opname == var_opname -> 
         mk_var_term v
    | t ->
         {free_vars = bterms_free_vars t.term_terms;
          core = Term t}

   let mk_term op bterms =
      match op, bterms with 
         { op_name = opname; op_params = [Var v] }, [] when opname == var_opname ->
            mk_var_term v
       | _ -> 
            { free_vars = bterms_free_vars bterms;
              core = Term { term_op = op; term_terms = bterms }}

   let mk_op name params = { op_name = name; op_params = params }

   let make_bterm bt =
      { bfree_vars = List.fold_right StringSet.remove bt.bvars bt.bterm.free_vars;
        bcore = BTerm bt }

   let mk_bterm vars term =
      { bfree_vars = List.fold_right StringSet.remove vars term.free_vars;
        bcore = BTerm {bvars = vars; bterm = term }}

   (*
    * New variable production.
    * renames are the variables to be renamed,
    * and av is a list list of variables to avoid.
    * Our algorithm is slow and simple: just append an
    * index and increment until no more collisions.
    *)

   let rec new_var av v i =
      let v' = v ^ "_" ^ (string_of_int i) in
      if (StringSet.mem v' av)
         then new_var av v (succ i)
         else v'

   and new_vars av = function
      [] -> ([],[])
    | v::vt ->
         let (vs,ts) = (new_vars av vt) in
         let v' = new_var av v 0 in
            ((v,v')::vs, (v,mk_var_term v')::ts)

   let rec dest_bterm bt =
      match bt.bcore with
         BTerm tt -> tt
       | BSubst (tt,sub) ->
            let ttt = dest_bterm tt in
            let btrm = ttt.bterm in
            let t4 =
               match ttt.bvars with
                  [] ->
                     { bvars = [];
                       bterm =
                        { free_vars = bt.bfree_vars;
                          core = Subst (btrm,sub) }}
                | bvrs ->
                     let sub_fvars = subst_free_vars sub in
                     let capt_vars = List_util.filter (function v -> StringSet.mem v sub_fvars) bvrs in
                     match capt_vars with
                        [] ->
                           let rec aux = function
                              [] -> bt.bfree_vars
                            | v::t ->
                               if StringSet.mem v btrm.free_vars
                                  then StringSet.add v (aux t)
                                  else aux t
                           in
                              { bvars = bvrs;
                                bterm =
                                 { free_vars = aux bvrs;
                                   core = Subst (btrm,sub) }}
                      | _ ->
                           let avoidvars = StringSet.union sub_fvars btrm.free_vars in
                           let (vs,ts) = new_vars avoidvars capt_vars in
                           let new_t = do_term_subst ts btrm in
                           { bvars =
                              List.map
                                 (function v ->
                                    try List.assoc v vs
                                    with Not_found -> v)
                                 bvrs;
                              bterm =
                                 { free_vars =
                                    StringSet.union
                                       (List.fold_right
                                          StringSet.remove
                                          (List_util.fst_split sub)
                                          new_t.free_vars)
                                       sub_fvars;
                                   core = Subst (new_t,sub) }}
            in
               bt.bcore <- BTerm t4;
               t4

   let no_bvars =
      List.for_all
         (function bt ->
            match dest_bterm bt with
               { bvars = [] } -> true
             | _ -> false)

   let dest_simple_bterm term bt =
      match dest_bterm bt with
         { bvars = []; bterm = tt } -> tt
       | _ -> ref_raise(RefineError ("dest_simple_bterm", TermMatchError (term, "bvars exist")))

   let dest_simple_bterms term =
      List.map (dest_simple_bterm term)

   let mk_simple_bterm term =
      { bfree_vars = term.free_vars;
        bcore = BTerm { bvars = []; bterm = term }}

   let mk_level_var v i =
      { le_var = v; le_offset = i }

   let mk_level i l =
      { le_const = i; le_vars = l }

   let subterms_of_term t =
      List.map (fun bt -> (dest_bterm bt).bterm) (dest_term t).term_terms

   let subterm_count t =
      List.length (dest_term t).term_terms

   let subterm_arities term =
      let aux bterm = List.length (dest_bterm bterm).bvars in
         List.map aux (dest_term term).term_terms
   (*
    * Operator names.
    *)
   let opname_of_term t = (dest_term t).term_op.op_name

   (* These are trivial identity functions *)

   external make_op : operator' -> operator = "%identity"
   external dest_op : operator -> operator' = "%identity"
   external make_param : param' -> param = "%identity"
   external dest_param : param -> param' = "%identity"
   external make_level : level_exp' -> level_exp = "%identity"
   external dest_level : level_exp -> level_exp' = "%identity"
   external make_level_var : level_exp_var' -> level_exp_var = "%identity"
   external dest_level_var : level_exp_var -> level_exp_var' = "%identity"
   external make_object_id : param list -> object_id = "%identity"
   external dest_object_id : object_id -> param list = "%identity"

   (************************************************************************
    * Variables                                                            *
    ************************************************************************)

   (*
    * See if a term is a variable.
    *)
   let is_var_term t = is_var_term_nods (dest_term t)

   (*
    * Destructor for a variable.
    *)
   let dest_var t =
      try
         dest_var_nods (dest_term t)
      with
         Not_var -> ref_raise(RefineError ("dest_var_nods", TermMatchError (t, "not a var")))

   let mk_var_op v = { op_name = var_opname; op_params = [Var v] }

   (*
    * Second order variables have subterms.
    *)
   let is_so_var_term t = match dest_term t with
      { term_op = { op_name = opname; op_params = [Var(_)] }; term_terms = bterms }
      when opname == var_opname -> no_bvars bterms
    | _ -> false

   let dest_so_var t = match dest_term t with
      { term_op = { op_name = opname; op_params = [Var(v)] };
         term_terms = bterms
      } when opname == var_opname ->
         v, dest_simple_bterms t bterms
    | _ -> ref_raise(RefineError ("dest_so_var", TermMatchError (t, "not a so_var")))

   (*
    * Second order variable.
    *)
   let mk_so_var_term v terms =
      let bterms = List.map mk_simple_bterm terms in
      { free_vars = bterms_free_vars bterms;
        core = Term 
         { term_op = { op_name = var_opname; op_params = [Var(v)] }; 
           term_terms = bterms }}

   (*
    * Second order context, contains a context term, plus
    * binding variables like so vars.
    *)
   let context_opname = make_opname ["context"]

   let is_context_term t =
      match dest_term t with
         { term_op = { op_name = opname; op_params = [Var _] };
           term_terms = bterms
         } when opname == context_opname ->
            bterms <> [] & no_bvars bterms
       | _ ->
            false

   let dest_context term =
      match dest_term term with
         { term_op = { op_name = opname; op_params = [Var v] };
           term_terms = bterms
         } when opname == context_opname ->
            let rec collect term = function
               [bterm] ->
                  [], dest_simple_bterm term bterm
             | bterm::bterms ->
                  let args, term = collect term bterms in
                     dest_simple_bterm term bterm :: args, term
             | _ ->
                  ref_raise(RefineError ("dest_context", TermMatchError (term, "not a context")))
            in
            let args, term = collect term bterms in
               v, term, args
       | _ ->
            ref_raise(RefineError ("dest_context", TermMatchError (term, "not a context")))

   let mk_context_term v term terms =
      let rec collect term = function
         [] ->
            [mk_simple_bterm term]
       | h::t ->
            mk_simple_bterm h :: collect term t
      in
      let op = { op_name = context_opname; op_params = [Var v] } in
         mk_term op (collect term terms)

   (************************************************************************
    * Tools for "simple" terms                                             *
    ************************************************************************)

   (*
    * "Simple" terms have no parameters and no binding variables.
    *)
   let is_simple_term_opname name t = match dest_term t with
      { term_op = { op_name = name'; op_params = [] };
        term_terms = bterms
      } when name' == name -> no_bvars bterms
    | _ -> false

   let mk_any_term op terms = mk_term op (List.map mk_simple_bterm terms)

   let mk_simple_term name terms =
      mk_any_term { op_name = name; op_params = [] } terms

   let dest_simple_term t = match dest_term t with
      { term_op = { op_name = name; op_params = [] };
         term_terms = bterms } ->
            name, dest_simple_bterms t bterms
    | _ -> ref_raise(RefineError ("dest_simple_term", TermMatchError (t, "params exist")))

   let dest_simple_term_opname name t = match dest_term t with
      { term_op = { op_name = name'; op_params = [] };
         term_terms = bterms } ->
         if name == name' then dest_simple_bterms t bterms
         else
            ref_raise(RefineError ("dest_simple_term_opname", TermMatchError (t, "opname mismatch")))
    | _ -> ref_raise(RefineError ("dest_simple_term_opname", TermMatchError (t, "params exist")))
end
