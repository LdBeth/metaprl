(*
 * This is the module that implements delayed substitution,
 * keeps track of free variables and does some sharing.
 *)

#include "refine_error.h"

open Printf
open Nl_debug
open Opname
open Refine_error_sig
open Term_ds

(*
 * Show the file loading.
 *)
let _ =
   if !debug_load then
      eprintf "Loading Term_ds%t" eflush

let debug_subst =
   create_debug (**)
      { debug_name = "subst";
        debug_description = "Display substition operations";
        debug_value = false
      }

module Term
   (RefineError : RefineErrorSig
    with type level_exp = TermType.level_exp
    with type param = TermType.param
    with type term = TermType.term
    with type bound_term = TermType.bound_term)
=
struct
   (************************************************************************
    * Type definitions                                                     *
    ************************************************************************)

   open TermType
   open RefineError

   type level_exp_var = TermType.level_exp_var
   type level_exp = TermType.level_exp
   type param = TermType.param
   type operator = TermType.operator
   type term = TermType.term
   type term_core = TermType.term_core
   type bound_term = TermType.bound_term
   type esequent = TermType.esequent
   type seq_hyps = TermType.seq_hyps
   type seq_goals = TermType.seq_goals

   type hypothesis = TermType.hypothesis
   type level_exp_var' = TermType.level_exp_var'
   type level_exp' = TermType.level_exp'
   type object_id = TermType.object_id
   type param' = TermType.param'
   type operator' = TermType.operator'
   type term' = TermType.term'
   type bound_term' = TermType.bound_term'

   (*
    * Simple substitution.
    *)
   type term_subst = (string * term) list

   module SeqHyp =
   struct
      type elt = hypothesis
      type t = seq_hyps
      let length = Array.length
      let get = Array.get
      let create = Array.create
      let make = Array.make
      let init = Array.init
      let mapi = Array.mapi
      let append_array = Array.append
      let append_list = Array_util.append_list
      let to_list = Array.to_list
      let of_list = Array.of_list
      let sub_map = Array_util.sub_map
      let collect = Array_util.collect
      let iter = Array.iter
   end

   module SeqGoal =
   struct
      type elt = term
      type t = seq_goals
      let length = Array.length
      let create = Array.create
      let get = Array.get
      let make = Array.make
      let init = Array.init
      let mapi = Array.mapi
      let append_array = Array.append
      let append_list = Array_util.append_list
      let to_list = Array.to_list
      let of_list = Array.of_list
      let sub_map = Array_util.sub_map
      let collect = Array_util.collect
      let iter = Array.iter
   end

   (************************************************************************
    * DEBUGGING                                                            *
    ************************************************************************)

   (*
    * Printer is installed by client.
    *)
   let print_term_ref = ref (fun _ _ -> raise (Failure "Term_ds.print_term: printer not installed"))

   let debug_print out t =
      !print_term_ref out t

   let print_term = debug_print

   let rec print_term_list out = function
      [t] ->
         debug_print out t
    | h::t ->
         debug_print out h;
         output_string out ", ";
         print_term_list out t
    | [] ->
         ()

   let install_debug_printer f =
      print_term_ref := f

   (************************************************************************
    * Free variables, substitution                                         *
    ************************************************************************)

   let rec bterms_free_vars = function
      [] -> StringSet.empty
    | [bt] -> bt.bfree_vars
    | bt::tl -> StringSet.union (bterms_free_vars tl) bt.bfree_vars

   let rec subst_free_vars = function
      [] -> StringSet.empty
    | [(v,t)] -> t.free_vars
    | (v,t)::tl -> StringSet.union (subst_free_vars tl) t.free_vars

   let do_term_subst sub t =
#ifdef VERBOSE_EXN
      if !debug_subst then
         begin
            eprintf "do_term_subst: %a%t" debug_print t eflush;
            eprintf "\tfree_vars:";
            List.iter (fun name -> eprintf " %s" name) (StringSet.elements t.free_vars);
            eflush stderr;
            List.iter (fun (v, t) -> eprintf "\t%s: %a%t" v debug_print t eflush) sub
         end;
#endif
      match StringSet.fst_mem_filt t.free_vars sub with
         [] -> t
       | sub' ->
            {free_vars =
               StringSet.union
                  (List.fold_right
                     StringSet.remove
                     (List_util.fst_split sub')
                     t.free_vars)
                  (subst_free_vars sub');
             core = Subst (t,sub')}

   let do_bterm_subst sub bt =
      match StringSet.fst_mem_filt bt.bfree_vars sub with
         [] -> bt
       | sub' ->
            {bfree_vars =
               StringSet.union
                  (List.fold_right
                     StringSet.remove
                     (List_util.fst_split sub')
                  bt.bfree_vars)
                     (subst_free_vars sub');
             bcore = BSubst (bt,sub')}

   (************************************************************************
    * De/Constructors                                                 *
    ************************************************************************)

   let var_opname = make_opname ["var"]

   (*
    * Manifest terms are injected into the "perv" module.
    *)
   let xperv = make_opname ["Perv"]
   let sequent_opname = mk_opname "sequent" xperv

   (************************************************************************
    * De/Constructors                                                 *
    ************************************************************************)

   let fail_core s =
      raise (Invalid_argument ("Term_ds." ^ s ^ ": get_core returned a Subst"))

   let rec subst_remove v = function
      [] -> []
    | ((v',t)::tl) as sub ->
         if (v = v') then subst_remove v tl
         else let rem = subst_remove v tl in
            if rem == tl then sub else (v',t)::rem

   let rec get_core t =
      match t.core with
         Subst (tt,sub) ->
            let core =
               match get_core tt with
                  Term { term_op = { op_name = opname; op_params = [Var v] };
                         term_terms = [] } when Opname.eq opname var_opname ->
                     (* since sub was not eliminated, v should be in sub *)
                     get_core (List.assoc v sub)
                | Term ttt ->
                     Term { term_op = ttt.term_op;
                            term_terms = List.map (do_bterm_subst sub) ttt.term_terms }
                | Sequent { sequent_args = args;
                            sequent_hyps = hyps;
                            sequent_goals = goals } ->
                     let new_args = do_term_subst sub args in
                     let new_hyps = Array.copy hyps in
                     let new_goals = Array.copy goals in
                     let hlen = Array.length hyps in
                     let rec do_hyps_subst sub i =
                        if i = hlen then
                           let glen = Array.length goals in
                           let rec do_goals_subst i =
                              if i = glen then
                                 Sequent { sequent_args = new_args;
                                           sequent_hyps = new_hyps;
                                           sequent_goals = new_goals }
                              else begin
                                 new_goals.(i) <- do_term_subst sub goals.(i);
                                 do_goals_subst (succ i)
                              end
                           in do_goals_subst 0
                        else (match hyps.(i) with
                           Hypothesis (v,t) ->
                              new_hyps.(i) <- Hypothesis (v,do_term_subst sub t);
                              do_hyps_subst (subst_remove v sub) (succ i)
                         | Context (v,ts) ->
                              new_hyps.(i) <- Context (v, List.map (do_term_subst sub) ts);
                              do_hyps_subst sub (succ i)) in
                     do_hyps_subst sub 0
                | Subst _ -> fail_core "get_core"
            in
               t.core <- core;
               core
       | core -> core

   (*
    * Make a variable.
    *)
   let mk_var_term v =
      { free_vars = StringSet.make v;
        core = Term
         { term_op = { op_name = var_opname; op_params = [Var v] };
           term_terms = [] }}

   let make_term = function
      { term_op = { op_name = opname; op_params = [Var v] };
        term_terms = []
      } when Opname.eq opname var_opname ->
         mk_var_term v
    | t ->
         {free_vars = bterms_free_vars t.term_terms;
          core = Term t}

   let mk_term op bterms =
      match op, bterms with
         { op_name = opname; op_params = [Var v] }, [] when Opname.eq opname var_opname ->
            mk_var_term v
       | _ ->
            { free_vars = bterms_free_vars bterms;
              core = Term { term_op = op; term_terms = bterms }}

   let mk_op name params = { op_name = name; op_params = params }

   let mk_simple_bterm term =
      { bfree_vars = term.free_vars;
        bcore = BTerm { bvars = []; bterm = term }}

   let make_bterm bt =
      { bfree_vars = List.fold_right StringSet.remove bt.bvars bt.bterm.free_vars;
        bcore = BTerm bt }

   let mk_bterm vars term =
      { bfree_vars = List.fold_right StringSet.remove vars term.free_vars;
        bcore = BTerm {bvars = vars; bterm = term }}

   (*
    * Second order context, contains a context term, plus
    * binding variables like so vars.
    *)
   let context_opname = make_opname ["context"]

   let mk_context_term v term terms =
      let rec collect term = function
         [] ->
            [mk_simple_bterm term]
       | h::t ->
            mk_simple_bterm h :: collect term t
      in
      let op = { op_name = context_opname; op_params = [Var v] } in
         mk_term op (collect term terms)

   (****************************************************
    * Sequent "ugly" forms - remove when not necessary *
    ****************************************************)

   let hyp_opname = mk_opname "hyp" xperv
   let concl_opname = mk_opname "concl" xperv

   let mk_sequent_outer_term goal args =
      { term_op = { op_name = sequent_opname; op_params = [] };
        term_terms = [mk_simple_bterm args; mk_simple_bterm goal] }

   let null_concl =
      { free_vars = StringSet.empty;
        core = Term { term_op = { op_name = concl_opname; op_params = [] }; term_terms = [] }}

   let mk_concl_term t1 t2 =
      { free_vars = StringSet.union t1.free_vars t2.free_vars;
        core = Term
         { term_op = { op_name = concl_opname; op_params = [] };
           term_terms = [mk_simple_bterm t1; mk_simple_bterm t2] }}

   let mk_hyp_term v t1 t2 =
      let fv2 = StringSet.remove v t2.free_vars in
      { free_vars = StringSet.union t1.free_vars fv2;
        core = Term
         { term_op = { op_name = hyp_opname; op_params = [] };
           term_terms =
            [ mk_simple_bterm t1;
              { bfree_vars = fv2;
                bcore = BTerm
                 { bvars = [v]; bterm = t2 }}]}}

   let rec mk_goals goals i len =
      if i = len then
         null_concl
      else
         mk_concl_term (SeqGoal.get goals i) (mk_goals goals (i + 1) len)

   let rec mk_sequent_inner_term hyps goals i len =
      if i = len then
         mk_goals goals 0 (SeqGoal.length goals)
      else
         match SeqHyp.get hyps i with
            Hypothesis (v, t') ->
               mk_hyp_term v t' (mk_sequent_inner_term hyps goals (i + 1) len)
          | Context (v, subterms) ->
               mk_context_term v (mk_sequent_inner_term hyps goals (i + 1) len) subterms

   (* End of sequent "ugly" forms *)

   let dest_term t =
      match get_core t with
         Term t -> t
       | Sequent
            { sequent_args = args;
              sequent_hyps = hyps;
              sequent_goals = goals
            }  ->
         (* raise (Invalid_argument "Term_base_ds.dest_term: dest_term called on a sequent") *)
         (* Create an "ugly" form: *)
          mk_sequent_outer_term (mk_sequent_inner_term hyps goals 0 (SeqHyp.length hyps)) args
       | Subst _ -> fail_core "dest_term"

   (*
    * New variable production.
    * renames are the variables to be renamed,
    * and av is a list list of variables to avoid.
    * Our algorithm is slow and simple: just append an
    * index and increment until no more collisions.
    *)

   let rec new_var av v i =
      let v' = v ^ "_" ^ (string_of_int i) in
      if (StringSet.mem av v')
         then new_var av v (succ i)
         else v'

   and new_vars av = function
      [] -> ([],[])
    | v::vt ->
         let (vs,ts) = (new_vars av vt) in
         let v' = new_var av v 0 in
            ((v,v')::vs, (v,mk_var_term v')::ts)

   let rec dest_bterm bt =
      match bt.bcore with
         BTerm tt -> tt
       | BSubst (tt,sub) ->
            let ttt = dest_bterm tt in
            let btrm = ttt.bterm in
            let t4 =
               match ttt.bvars with
                  [] ->
                     { bvars = [];
                       bterm =
                        { free_vars = bt.bfree_vars;
                          core = Subst (btrm,sub) }}
                | bvrs ->
                     let sub_fvars = subst_free_vars sub in
                     let capt_vars = StringSet.mem_filt sub_fvars bvrs in
                     match capt_vars with
                        [] ->
                           let rec aux = function
                              [] -> bt.bfree_vars
                            | v::t ->
                               if StringSet.mem btrm.free_vars v
                                  then StringSet.add v (aux t)
                                  else aux t
                           in
                              { bvars = bvrs;
                                bterm =
                                 { free_vars = aux bvrs;
                                   core = Subst (btrm,sub) }}
                      | _ ->
                           let avoidvars = StringSet.union sub_fvars btrm.free_vars in
                           let (vs,ts) = new_vars avoidvars capt_vars in
                           let new_t = do_term_subst ts btrm in
                           { bvars =
                              List.map
                                 (function v ->
                                    try List.assoc v vs
                                    with Not_found -> v)
                                 bvrs;
                              bterm =
                                 { free_vars =
                                    StringSet.union
                                       (List.fold_right
                                          StringSet.remove
                                          (List_util.fst_split sub)
                                          new_t.free_vars)
                                       sub_fvars;
                                   core = Subst (new_t,sub) }}
            in
               bt.bcore <- BTerm t4;
               t4

   let rec goal_fv goals i =
      if i < 0 then StringSet.empty else
      StringSet.union (SeqGoal.get goals i).free_vars (goal_fv goals (pred i))

   let rec terms_free_vars = function
      [] -> StringSet.empty
    | [t] -> t.free_vars
    | t::tl -> StringSet.union (terms_free_vars tl) t.free_vars

   let rec hyp_fv hyps i fvs =
      if i < 0 then fvs else
      hyp_fv hyps (pred i) (
      match SeqHyp.get hyps i with
         Hypothesis (v,t) ->
            StringSet.union t.free_vars (StringSet.remove v fvs)
       | Context (v,subterms) ->
            StringSet.union fvs (terms_free_vars subterms))

   let mk_sequent_term seq =
      { free_vars =
         StringSet.union
            seq.sequent_args.free_vars
            (hyp_fv
               seq.sequent_hyps
               (SeqHyp.length seq.sequent_hyps - 1)
               (goal_fv seq.sequent_goals (SeqGoal.length seq.sequent_goals - 1)));
        core = Sequent seq }

   let rec no_bvars = function
      [] -> true
    | bt::btrms -> (dest_bterm bt).bvars == [] && no_bvars btrms

   let dest_simple_bterm term bt =
      match dest_bterm bt with
         { bvars = []; bterm = tt } -> tt
       | _ -> ref_raise(RefineError ("dest_simple_bterm", TermMatchError (term, "bvars exist")))

   let dest_simple_bterms term =
      List.map (dest_simple_bterm term)

   let is_context_term t =
      match dest_term t with
         { term_op = { op_name = opname; op_params = [Var _] };
           term_terms = bterms
         } when Opname.eq opname context_opname ->
            bterms <> [] & no_bvars bterms
       | _ ->
            false

   let dest_context term =
      match dest_term term with
         { term_op = { op_name = opname; op_params = [Var v] };
           term_terms = bterms
         } when Opname.eq opname context_opname ->
            let rec collect term = function
               [bterm] ->
                  [], dest_simple_bterm term bterm
             | bterm::bterms ->
                  let args, term = collect term bterms in
                     dest_simple_bterm term bterm :: args, term
             | _ ->
                  ref_raise(RefineError ("dest_context", TermMatchError (term, "not a context")))
            in
            let args, term = collect term bterms in
               v, term, args
       | _ ->
            ref_raise(RefineError ("dest_context", TermMatchError (term, "not a context")))

   let mk_level_var v i =
      { le_var = v; le_offset = i }

   let mk_level i l =
      { le_const = i; le_vars = l }

   let subterms_of_term t =
      List.map (fun bt -> (dest_bterm bt).bterm) (dest_term t).term_terms

   let subterm_count t =
      List.length (dest_term t).term_terms

   let subterm_arities_aux bterm = List.length (dest_bterm bterm).bvars

   let subterm_arities term =
         List.map subterm_arities_aux (dest_term term).term_terms
   (*
    * Operator names.
    *)
   let rec opname_of_term t = match t.core with
      Term t -> t.term_op.op_name
    | Sequent _ -> sequent_opname
    | Subst _ -> get_core t; opname_of_term t

   (* These are trivial identity functions *)

   external make_op : operator' -> operator = "%identity"
   external dest_op : operator -> operator' = "%identity"
   external make_param : param' -> param = "%identity"
   external dest_param : param -> param' = "%identity"
   external make_level : level_exp' -> level_exp = "%identity"
   external dest_level : level_exp -> level_exp' = "%identity"
   external make_level_var : level_exp_var' -> level_exp_var = "%identity"
   external dest_level_var : level_exp_var -> level_exp_var' = "%identity"
   external make_object_id : param list -> object_id = "%identity"
   external dest_object_id : object_id -> param list = "%identity"

   (************************************************************************
    * Variables                                                            *
    ************************************************************************)

   (*
    * See if a term is a variable.
    *)

   let is_var_term t =
      match get_core t with
         Term { term_op = { op_name = opname; op_params = [Var _] };
                term_terms = [] } when Opname.eq opname var_opname ->
            true
       | _ -> false

   (*
    * Destructor for a variable.
    *)
   let dest_var t =
      match dest_term t with
         { term_op = { op_name = opname; op_params = [Var v] };
           term_terms = [] } when Opname.eq opname var_opname ->
            v
       | _ -> ref_raise(RefineError ("dest_var", TermMatchError (t, "not a var")))

   let mk_var_op v = { op_name = var_opname; op_params = [Var v] }

   (*
    * Second order variables have subterms.
    *)
   let is_so_var_term t = match get_core t with
      Term { term_op = { op_name = opname; op_params = [Var(_)] }; term_terms = bterms }
      when Opname.eq opname var_opname -> no_bvars bterms
    | _ -> false

   let dest_so_var t = match dest_term t with
      { term_op = { op_name = opname; op_params = [Var(v)] };
         term_terms = bterms
      } when Opname.eq opname var_opname ->
         v, dest_simple_bterms t bterms
    | _ -> ref_raise(RefineError ("dest_so_var", TermMatchError (t, "not a so_var")))

   (*
    * Second order variable.
    *)
   let mk_so_var_term v terms =
      let bterms = List.map mk_simple_bterm terms in
      { free_vars = bterms_free_vars bterms;
        core = Term
         { term_op = { op_name = var_opname; op_params = [Var(v)] };
           term_terms = bterms }}

   (*
    * Second order context, contains a context term, plus
    * binding variables like so vars.
    *)
   let context_opname = make_opname ["context"]

   let is_context_term t =
      match get_core t with
         Term { term_op = { op_name = opname; op_params = [Var _] };
                term_terms = bterms
              } when Opname.eq opname context_opname ->
            bterms <> [] & no_bvars bterms
       | _ ->
            false

   let dest_context term =
      match dest_term term with
         { term_op = { op_name = opname; op_params = [Var v] };
           term_terms = bterms
         } when Opname.eq opname context_opname ->
            let rec collect term = function
               [bterm] ->
                  [], dest_simple_bterm term bterm
             | bterm::bterms ->
                  let args, term = collect term bterms in
                     dest_simple_bterm term bterm :: args, term
             | _ ->
                  ref_raise(RefineError ("dest_context", TermMatchError (term, "not a context")))
            in
            let args, term = collect term bterms in
               v, term, args
       | _ ->
            ref_raise(RefineError ("dest_context", TermMatchError (term, "not a context")))

   let mk_context_term v term terms =
      let rec collect term = function
         [] ->
            [mk_simple_bterm term]
       | h::t ->
            mk_simple_bterm h :: collect term t
      in
      let op = { op_name = context_opname; op_params = [Var v] } in
         mk_term op (collect term terms)

   (************************************************************************
    * Tools for "simple" terms                                             *
    ************************************************************************)

   (*
    * "Simple" terms have no parameters and no binding variables.
    *)
   let is_simple_term_opname name t = match get_core t with
      Term { term_op = { op_name = name'; op_params = [] };
             term_terms = bterms
           } when Opname.eq name' name -> no_bvars bterms
    | _ -> false

   let mk_any_term op terms = mk_term op (List.map mk_simple_bterm terms)

   let mk_simple_term name terms =
      mk_any_term { op_name = name; op_params = [] } terms

   let dest_simple_term t = match dest_term t with
      { term_op = { op_name = name; op_params = [] };
         term_terms = bterms } ->
            name, dest_simple_bterms t bterms
    | _ -> ref_raise(RefineError ("dest_simple_term", TermMatchError (t, "params exist")))

   let dest_simple_term_opname name t = match dest_term t with
      { term_op = { op_name = name'; op_params = [] };
         term_terms = bterms } ->
         if Opname.eq name name' then dest_simple_bterms t bterms
         else
            ref_raise(RefineError ("dest_simple_term_opname", TermMatchError (t, "opname mismatch")))
    | _ -> ref_raise(RefineError ("dest_simple_term_opname", TermMatchError (t, "params exist")))
end
