(*
 * Standard operations on terms.
 *)

#include "refine_error.h"

open Refine_error_sig
open Term_ds_sig
open Term_ds

module TermOp
#ifdef VERBOSE_EXN
   (Term : TermDsSig
    with type level_exp_var = TermType.level_exp_var
    with type level_exp = TermType.level_exp
    with type param = TermType.param
    with type operator = TermType.operator
    with type term = TermType.term
    with type bound_term = TermType.bound_term

    with type level_exp_var' = TermType.level_exp_var'
    with type level_exp' = TermType.level_exp'
    with type object_id = TermType.object_id
    with type param' = TermType.param'
    with type operator' = TermType.operator'
    with type term' = TermType.term'
    with type bound_term' = TermType.bound_term')
   (RefineError : RefineErrorSig
    with type level_exp = TermType.level_exp
    with type param = TermType.param
    with type term = TermType.term
    with type bound_term = TermType.bound_term)
#endif VERBOSE_EXN
=
struct
#ifdef VERBOSE_EXN
   open RefineError
#else
   open Term_base_ds_simp
#endif
   open TermType
   open Term

   type term = TermType.term
   type operator = TermType.operator
   type level_exp = TermType.level_exp

   (*
    * Terms with no subterms.
    *)
   let is_no_subterms_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = []
      } when opname' == opname -> true
    | _ -> false

   (*
    * Terms with one subterm
    *)
   let is_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt]
      } when opname' == opname -> (dest_bterm bt).bvars = []
    | _ -> false

   let mk_dep0_term opname t =
      { free_vars = t.free_vars;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [] };
           term_terms = [mk_simple_bterm t]}}

   let dest_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt]
      } when opname' == opname -> dest_simple_bterm t bt
    | _ -> ref_raise(RefineError ("dest_dep0_term", TermMatchError (t, "bad arity")))

   let one_subterm t = match dest_term t with
      { term_terms = [bt]}  -> dest_simple_bterm t bt
    | _ -> ref_raise(RefineError ("one_subterm", TermMatchError (t, "bad arity")))

   (*
    * Terms with two subterms.
    *)
   let is_dep0_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2]
      } when opname' == opname ->
         (dest_bterm bt1).bvars = [] && (dest_bterm bt2).bvars = []
    | _ -> false

   let mk_dep0_dep0_term opname t1 t2 =
      { free_vars = StringSet.union t1.free_vars t2.free_vars;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [] };
           term_terms = [mk_simple_bterm t1; mk_simple_bterm t2]}}

   let dest_dep0_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1 ; bt2 ]
      } when opname' == opname ->
         let destr = dest_simple_bterm t in
         destr bt1, destr bt2
    | _ -> ref_raise(RefineError ("dest_dep0_dep0_term", TermMatchError (t, "bad arity")))

   let two_subterms t = match dest_term t with
      { term_terms = [bt1; bt2]} ->
         let destr = dest_simple_bterm t in
         destr bt1, destr bt2
    | _ -> ref_raise(RefineError ("two_subterms", TermMatchError (t, "bad arity")))

   (*
    * Terms with three subterms.
    *)
   let is_dep0_dep0_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = ([b1; b2; b3] as bterms)
      } when opname' == opname -> no_bvars bterms
    | _ -> false

   let mk_dep0_dep0_dep0_term opname t1 t2 t3 =
      { free_vars = StringSet.union t1.free_vars (StringSet.union t2.free_vars t3.free_vars);
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [] };
           term_terms =
            [mk_simple_bterm t1; mk_simple_bterm t2; mk_simple_bterm t3]}}

   let dest_dep0_dep0_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3]
      } when opname' == opname ->
         let destr = dest_simple_bterm t in
         destr bt1, destr bt2, destr bt3
    | _ -> ref_raise(RefineError ("dest_dep0_dep0_dep0_term", TermMatchError (t, "bad arity")))

   let three_subterms t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3]
      } ->
         let destr = dest_simple_bterm t in
         destr bt1, destr bt2, destr bt3
    | _ -> ref_raise(RefineError ("three_subterms", TermMatchError (t, "bad arity")))

   let four_subterms t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3; bt4]
      } ->
         let destr = dest_simple_bterm t in
         destr bt1, destr bt2, destr bt3, destr bt4
    | _ -> ref_raise(RefineError ("four_subterms", TermMatchError (t, "bad arity")))

   let five_subterms t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3; bt4; bt5]
      } ->
         let destr = dest_simple_bterm t in
         destr bt1, destr bt2, destr bt3, destr bt4, destr bt5
    | _ -> ref_raise(RefineError ("five_subterms", TermMatchError (t, "bad arity")))

   (************************************************************************
    * Nonsimple but useful forms                                           *
    ************************************************************************)

   (*
    * One string param.
    *)
   let is_string_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [String _] };
        term_terms = []
      } when opname == opname' ->
         true
    | _ ->
         false

   let dest_string_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [String s] };
        term_terms = []
      } when opname == opname' ->
         s
    | _ ->
         ref_raise(RefineError ("dest_string_term", TermMatchError (t, "not a string term")))

   let dest_string_param t = match dest_term t with
      { term_op = { imp_op_params = String s :: _ } } ->
         s
    | _ ->
         ref_raise(RefineError ("dest_string_param", TermMatchError (t, "no string parameter")))

   let mk_string_term opname s =
      { free_vars = StringSet.empty;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [String s] }; term_terms = [] }}

   (*
    * One string parameter, and one simple subterm.
    *)
   let is_string_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [String _] };
        term_terms = [bt]
      } when opname == opname' -> (dest_bterm bt).bvars = []
    | _ -> false

   let dest_string_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [String s] };
        term_terms = [bt]
      } when opname == opname' -> s, dest_simple_bterm t bt
    | _ -> ref_raise(RefineError ("dest_string_dep0_term", TermMatchError (t, "bad arity")))

   let mk_string_dep0_term opname s t =
      { free_vars = t.free_vars;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [String s] };
           term_terms = [mk_simple_bterm t] }}

   (*
    * Two string parameters, and one simple subterm.
    *)
   let is_string_string_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [String _; String _] };
        term_terms = [bt]
      } when opname == opname' -> (dest_bterm bt).bvars = []
    | _ ->
         false

   let dest_string_string_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [String s1; String s2] };
        term_terms = [bt]
      } when opname == opname' ->
         s1, s2, dest_simple_bterm t bt
    | _ ->
         ref_raise(RefineError ("dest_string_string_dep0_term", TermMatchError (t, "bad arity")))

   let dest_string_string_dep0_any_term t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [String s1; String s2] };
        term_terms = [bt]
      } ->
         s1, s2, dest_simple_bterm t bt
    | _ ->
         ref_raise(RefineError ("dest_string_string_dep0_any_term", TermMatchError (t, "bad arity")))

   let mk_string_string_dep0_term opname s1 s2 t =
      { free_vars = t.free_vars;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [String s1; String s2] };
           term_terms = [mk_simple_bterm t] }}

   (*
    * Two number parameters and one subterm.
    *)
   let is_number_number_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [Number _; Number _] };
        term_terms = [ bt ]
      } when opname == opname' -> (dest_bterm bt).bvars = []
    | _ ->
         false

   let dest_number_number_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [Number s1; Number s2] };
        term_terms = [bt]
      } when opname == opname' ->
         s1, s2, dest_simple_bterm t bt
    | _ ->
         ref_raise(RefineError ("dest_number_number_dep0_term", TermMatchError (t, "bad arity")))

   let dest_number_number_dep0_any_term t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [Number s1; Number s2] };
        term_terms = [bt]
      } ->
         s1, s2, dest_simple_bterm t bt
    | _ ->
         ref_raise(RefineError ("dest_number_number_dep0_any_term", TermMatchError (t, "bad arity")))

   let mk_number_number_dep0_term opname s1 s2 t =
      { free_vars = t.free_vars;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [Number s1; Number s2] };
           term_terms = [mk_simple_bterm t]}}

   (*
    * Two string parameters, two subterms.
    *)
   let is_string_string_dep0_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [String _; String _] };
        term_terms = [bt1;bt2]
      } when opname == opname' ->
         (dest_bterm bt1).bvars = [] && (dest_bterm bt2).bvars = []
    | _ ->
         false

   let dest_string_string_dep0_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [String s1; String s2] };
        term_terms = [bt1;bt2]
      } when opname == opname' ->
         let destr = dest_simple_bterm t in
         s1, s2, destr bt1, destr bt2
    | _ ->
         ref_raise(RefineError ("dest_string_string_dep0_dep0_term", TermMatchError (t, "bad arity")))

   let dest_string_string_dep0_dep0_any_term t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [String s1; String s2] };
        term_terms = [bt1;bt2]
      } ->
         let destr = dest_simple_bterm t in
         s1, s2, destr bt1, destr bt2
    | _ ->
         ref_raise(RefineError ("dest_string_string_dep0_dep0_any_term", TermMatchError (t, "bad arity")))

   let mk_string_string_dep0_dep0_term opname s1 s2 t1 t2 =
      { free_vars = StringSet.union t1.free_vars t2.free_vars;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [String s1; String s2] };
           term_terms = [mk_simple_bterm t1; mk_simple_bterm t2]}}

   (*
    * One number param.
    *)
   let is_number_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [Number _] };
        term_terms = []
      } when opname == opname' -> true
    | _ -> false

   let dest_number_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [Number n] };
        term_terms = []
      } when opname == opname' -> n
    | _ -> ref_raise(RefineError ("dest_number_term", TermMatchError (t, "bad arity")))

   let dest_number_any_term t = match dest_term t with
      { term_op = { imp_op_params = [Number n] };
        term_terms = []
      } ->
         n
    | _ ->
         ref_raise(RefineError ("dest_number_any_term", TermMatchError (t, "bad arity")))

   let mk_number_term opname n =
      { free_vars = StringSet.empty;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [Number n] };
           term_terms = [] }}

   (*
    * One universe param.
    *)
   let is_univ_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [Level _] };
        term_terms = []
      } when opname == opname' -> true
    | _ -> false

   let dest_univ_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [Level n] };
        term_terms = []
      } when opname == opname' -> n
    | _ -> ref_raise(RefineError ("dest_univ_term", TermMatchError (t, "")))

   let mk_univ_term opname n =
      { free_vars = StringSet.empty;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [Level n] };
           term_terms = [] }}

   (*
    * One token param.
    *)
   let is_token_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [Token _] };
        term_terms = []
      } when opname == opname' -> true
    | _ -> false

   let dest_token_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [Token n] };
        term_terms = []
      } when opname == opname' -> n
    | _ -> ref_raise(RefineError ("dest_token_term", TermMatchError (t, "bad arity")))

   let mk_token_term opname n =
      { free_vars = StringSet.empty;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [Token n] };
           term_terms = [] }}

   (*
    * Bound term.
    *)
   let is_dep1_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt]
      } when opname' == opname ->
         begin
            match (dest_bterm bt).bvars with
               [_] -> true
             | _ -> false
         end
    | _ -> false

   let mk_dep1_term opname v t =
      let fv = StringSet.remove v t.free_vars in
      { free_vars = fv;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [] };
           term_terms =
            [{ bfree_vars = fv;
               bcore = BTerm { bvars = [v]; bterm = t }}]}}

   let dest_dep1_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt]
      } when opname' == opname ->
         begin
            match dest_bterm bt with
               { bvars = [v]; bterm = t } -> v,t
             | _ -> ref_raise(RefineError ("dest_dep1_term", TermMatchError (t, "bad arity")))
         end
    | _ -> ref_raise(RefineError ("dest_dep1_term", TermMatchError (t, "bad arity")))

   let is_dep0_dep1_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1;bt2]
      } when opname' == opname ->
         if (dest_bterm bt1).bvars = []
            then match (dest_bterm bt2).bvars with
               [_] -> true
             | _ -> false
            else false
    | _ -> false

   let is_dep0_dep1_any_term t = match dest_term t with
      { term_op = { imp_op_params = [] };
        term_terms = [bt1;bt2] } ->
          if (dest_bterm bt1).bvars = []
            then match (dest_bterm bt2).bvars with
               [_] -> true
             | _ -> false
            else false
    | _ -> false

   let mk_dep0_dep1_term opname v t1 t2 =
      let fv2 = StringSet.remove v t2.free_vars in
      { free_vars = StringSet.union t1.free_vars fv2;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [] };
           term_terms =
               [ mk_simple_bterm t1;
                 { bfree_vars = fv2;
                   bcore = BTerm { bvars = [v]; bterm = t2 }}]}}

   let mk_dep0_dep1_any_term op v t1 t2 =
      let fv2 = StringSet.remove v t2.free_vars in
      { free_vars = StringSet.union t1.free_vars fv2;
        core = Term
         { term_op = op;
           term_terms =
               [ mk_simple_bterm t1;
                 { bfree_vars = fv2;
                   bcore = BTerm { bvars = [v]; bterm = t2 }}]}}

   let dest_dep0_dep1_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1;bt2]
      } when opname' == opname ->
      begin match (dest_bterm bt1, dest_bterm bt2) with
         ({ bvars = []; bterm = t1 }, { bvars = [v]; bterm = t2 }) ->
            v, t1, t2
       | _ -> ref_raise(RefineError ("dest_dep0_dep1_term", TermMatchError (t, "bad arity")))
      end
    | _ -> ref_raise(RefineError ("dest_dep0_dep1_term", TermMatchError (t, "bad arity")))

   let dest_dep0_dep1_any_term t = match dest_term t with
      { term_op = { imp_op_params = [] };
        term_terms = [bt1;bt2] } ->
         begin match (dest_bterm bt1, dest_bterm bt2) with
            ({ bvars = []; bterm = t1 }, { bvars = [v]; bterm = t2 }) ->
               v, t1, t2
          | _ -> ref_raise(RefineError ("dest_dep0_dep1_term", TermMatchError (t, "bad arity")))
         end
    | _ -> ref_raise(RefineError ("dest_dep0_dep1_any_term", TermMatchError (t, "bad arity")))

   (*
    * First subterm of arity 2.
    *)
   let is_dep2_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1;bt2]
      } when opname' == opname ->
         if (dest_bterm bt2).bvars = []
            then match (dest_bterm bt1).bvars with
               [_;_] -> true
             | _ -> false
            else false
    | _ -> false

   let mk_dep2_dep0_term opname v1 v2 t1 t2 =
      let fv1 = StringSet.remove v1 (StringSet.remove v2 t1.free_vars) in
      { free_vars = StringSet.union fv1 t2.free_vars;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [] };
           term_terms =
            [{ bfree_vars = fv1;
               bcore = BTerm { bvars = [v1; v2]; bterm = t1 }};
             mk_simple_bterm t2]}}

   let dest_dep2_dep0_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2]
      } when opname' == opname ->
         begin match (dest_bterm bt1, dest_bterm bt2) with
            ({ bvars = [v1; v2]; bterm = t1 },
             { bvars = []; bterm = t2 }) -> v1, v2, t1, t2
          | _ -> ref_raise(RefineError ("dest_dep2_dep0_term", TermMatchError (t, "bad arity")))
         end
    | _ -> ref_raise(RefineError ("dest_dep2_dep0_term", TermMatchError (t, "bad arity")))

   (*
    * Second subterm of arity 2.
    *)
   let is_dep0_dep2_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2]
      } when opname' == opname ->
         if (dest_bterm bt1).bvars = []
            then match (dest_bterm bt2).bvars with
               [_;_] -> true
             | _ -> false
            else false
    | _ -> false

   let mk_dep0_dep2_term opname v1 v2 t1 t2 =
      let fv2 = StringSet.remove v1 (StringSet.remove v2 t2.free_vars) in
      { free_vars = StringSet.union t1.free_vars fv2;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [] };
           term_terms =
            [mk_simple_bterm t1;
             { bfree_vars = fv2;
               bcore = BTerm { bvars = [v1; v2]; bterm = t2 }}]}}

   let dest_dep0_dep2_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1;bt2]
      } when opname' == opname ->
         begin match (dest_bterm bt1, dest_bterm bt2) with
            ({ bvars = []; bterm = t1 },
             { bvars = [v1; v2]; bterm = t2 }) -> v1, v2, t1, t2
          | _ -> ref_raise(RefineError ("dest_dep0_dep2_term", TermMatchError (t, "bad arity")))
         end
    | _ -> ref_raise(RefineError ("dest_dep0_dep2_term", TermMatchError (t, "bad arity")))

   (*
    * Second subterm of arity 2.
    *)
   let is_dep0_dep3_term opname t =
      match dest_term t with
         { term_op = { imp_op_name = opname'; imp_op_params = [] };
           term_terms = [bt1; bt2]
         } when opname' == opname ->
            if (dest_bterm bt1).bvars = [] then
               match (dest_bterm bt2).bvars with
                    [_; _; _] ->
                       true
                  | _ ->
                       false
            else
               false
       | _ ->
            false

   let mk_dep0_dep3_term opname v1 v2 v3 t1 t2 =
      let fv2 = StringSet.remove v1 (StringSet.remove v2 (StringSet.remove v3 t2.free_vars)) in
         { free_vars = StringSet.union t1.free_vars fv2;
           core = Term
                  { term_op = { imp_op_name = opname; imp_op_params = [] };
                    term_terms =
                       [mk_simple_bterm t1;
                        { bfree_vars = fv2;
                          bcore = BTerm { bvars = [v1; v2; v3]; bterm = t2 }}]}}

   let dest_dep0_dep3_term opname t =
      match dest_term t with
         { term_op = { imp_op_name = opname'; imp_op_params = [] };
           term_terms = [bt1; bt2]
         } when opname' == opname ->
            begin
               match (dest_bterm bt1, dest_bterm bt2) with
                  ({ bvars = []; bterm = t1 },
                   { bvars = [v1; v2; v3]; bterm = t2 }) ->
                     v1, v2, v3, t1, t2
                | _ ->
                     ref_raise(RefineError ("dest_dep0_dep3_term", TermMatchError (t, "bad arity")))
            end
       | _ ->
            ref_raise(RefineError ("dest_dep0_dep3_term", TermMatchError (t, "bad arity")))

   (*
    * Three subterms.
    *)
   let is_dep0_dep2_dep2_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1;bt2;bt3]
      } when opname' == opname ->
         if (dest_bterm bt1).bvars = []
            then match ((dest_bterm bt2).bvars, (dest_bterm bt3).bvars) with
               ([_;_], [_;_]) -> true
             | _ -> false
            else false
    | _ -> false

   let mk_dep0_dep2_dep2_term opname t0 v11 v12 t1 v21 v22 t2 =
      mk_term
         { imp_op_name = opname; imp_op_params = [] }
         [mk_simple_bterm t0;
          mk_bterm [v11; v12] t1;
          mk_bterm [v21; v22] t2]

   let dest_dep0_dep2_dep2_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3]
      } when opname' == opname ->
         begin
            match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3) with
               ({ bvars = []; bterm = t0 },
                { bvars = [v11; v12]; bterm = t1 },
                { bvars = [v21; v22]; bterm = t2 })
                  -> t0, v11, v12, t1, v21, v22, t2
             | _ -> ref_raise(RefineError ("dest_dep0_dep2_dep2_term", TermMatchError (t, "bad arity")))
         end
    | _ -> ref_raise(RefineError ("dest_dep0_dep2_dep2_term", TermMatchError (t, "bad arity")))

   (*
    * Four subterms.
    *)
   let is_dep0_dep2_dep0_dep2_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3; bt4]
      } when opname' == opname ->
         begin match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3, dest_bterm bt4) with
            ({ bvars = [] }, { bvars = [_; _] }, { bvars = [] }, { bvars = [_; _] }) -> true
          | _ -> false
         end
    | _ -> false

   let mk_dep0_dep2_dep0_dep2_term opname t0 v11 v12 t1 base v21 v22 t2 =
         mk_term
            { imp_op_name = opname; imp_op_params = [] }
            [mk_simple_bterm t0;
             mk_bterm [v11; v12] t1;
             mk_simple_bterm base;
             mk_bterm [v21; v22] t2]

   let dest_dep0_dep2_dep0_dep2_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3; bt4]
      } when opname' == opname ->
         begin match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3, dest_bterm bt4) with
            ({ bvars = []; bterm = t0 },
             { bvars = [v11; v12]; bterm = t1 },
             { bvars = []; bterm = base },
             { bvars = [v21; v22]; bterm = t2 }) ->
               t0, v11, v12, t1, base, v21, v22, t2
          | _ -> ref_raise(RefineError ("dest_dep0_dep2_dep0_dep2_term", TermMatchError (t, "bad arity")))
         end
    | _ -> ref_raise(RefineError ("dest_dep0_dep2_dep0_dep2_term", TermMatchError (t, "bad arity")))

   (*
    * Three subterms.
    *)
   let is_dep0_dep0_dep1_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3]
      } when opname' == opname ->
         begin match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3) with
            ({ bvars = [] }, { bvars = [] }, { bvars = [_] }) -> true
          | _ -> false
         end
    | _ -> false

   let mk_dep0_dep0_dep1_term opname t0 t1 v2 t2 =
      let fv2 = StringSet.remove v2 t2.free_vars in
      { free_vars = StringSet.union t0.free_vars
                                    (StringSet.union t1.free_vars fv2);
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [] };
           term_terms =
            [mk_simple_bterm t0;
             mk_simple_bterm t1;
             { bfree_vars = fv2;
               bcore = BTerm { bvars = [v2]; bterm = t2 }}]}}

   let dest_dep0_dep0_dep1_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3]
      } when opname' == opname ->
         begin match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3) with
            ({ bvars = []; bterm = t0 },
             { bvars = []; bterm = t1 },
             { bvars = [v2]; bterm = t2 }) -> t0, t1, v2, t2
          | _ -> ref_raise(RefineError ("dest_dep0_dep0_dep1_term", TermMatchError (t, "bad arity")))
         end
    | _ ->
         ref_raise(RefineError ("dest_dep0_dep0_dep1_term", TermMatchError (t, "bad arity")))

   let is_dep0_dep0_dep1_any_term t = match dest_term t with
      { term_terms = [bt1; bt2; bt3] } ->
         begin match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3) with
            ({ bvars = [] }, { bvars = [] }, { bvars = [_] }) -> true
          | _ -> false
         end
    | _ -> false

   let mk_dep0_dep0_dep1_any_term op t0 t1 v2 t2 =
      let fv2 = StringSet.remove v2 t2.free_vars in
      { free_vars = StringSet.union t0.free_vars
                                    (StringSet.union t1.free_vars fv2);
        core = Term
         { term_op = op;
           term_terms =
            [mk_simple_bterm t0;
             mk_simple_bterm t1;
             { bfree_vars = fv2;
               bcore = BTerm { bvars = [v2]; bterm = t2 }}]}}

   let dest_dep0_dep0_dep1_any_term t = match dest_term t with
      { term_terms = [bt1; bt2; bt3] } ->
         begin match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3) with
            ({ bvars = []; bterm = t0 },
             { bvars = []; bterm = t1 },
             { bvars = [v2]; bterm = t2 }) -> t0, t1, v2, t2
          | _ -> ref_raise(RefineError ("dest_dep0_dep0_dep1_any_term", TermMatchError (t, "bad arity")))
         end
    | _ ->
         ref_raise(RefineError ("dest_dep0_dep0_dep1_any_term", TermMatchError (t, "bad arity")))

   let is_dep0_dep1_dep1_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3]
      } when opname' == opname ->
         begin match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3) with
            ({ bvars = [] }, { bvars = [_] }, { bvars = [_] }) -> true
          | _ -> false
         end
    | _ -> false

   let mk_dep0_dep1_dep1_term opname t0 v1 t1 v2 t2 =
      mk_term
         { imp_op_name = opname; imp_op_params = [] }
         [mk_simple_bterm t0;
          mk_bterm [v1] t1;
          mk_bterm [v2] t2]

   let dest_dep0_dep1_dep1_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3]
      } when opname' == opname ->
         begin match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3) with
            ({ bvars = []; bterm = t0 },
             { bvars = [v1]; bterm = t1 },
             { bvars = [v2]; bterm = t2 }) -> t0, v1, t1, v2, t2
          | _ -> ref_raise(RefineError ("dest_dep0_dep1_dep1_term", TermMatchError (t, "bad arity")))
         end
    | _ -> ref_raise(RefineError ("dest_dep0_dep1_dep1_term", TermMatchError (t, "bad arity")))

   (*
    * Three subterms.
    *)
   let is_dep0_dep0_dep3_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3]
      } when opname' == opname ->
         begin match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3) with
            ({ bvars = [] }, { bvars = [] }, { bvars = [_; _; _] }) -> true
          | _ -> false
         end
    | _ -> false

   let mk_dep0_dep0_dep3_term opname t0 t1 v1 v2 v3 t2 =
      mk_term
         { imp_op_name = opname; imp_op_params = [] }
         [mk_simple_bterm t0;
          mk_simple_bterm t1;
          mk_bterm [v1; v2; v3] t2]

   let dest_dep0_dep0_dep3_term opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bt1; bt2; bt3]
      } when opname' == opname ->
         begin match (dest_bterm bt1, dest_bterm bt2, dest_bterm bt3) with
            ({ bvars = []; bterm = t0 },
             { bvars = []; bterm = t1 },
             { bvars = [v1; v2; v3]; bterm = t2 })
               -> t0, t1, v1, v2, v3, t2
          | _ -> ref_raise(RefineError ("dest_dep0_dep0_dep3_term", TermMatchError (t, "bad arity")))
         end
    | _ -> ref_raise(RefineError ("dest_dep0_dep0_dep3_term", TermMatchError (t, "bad arity")))

   (*
    * One subterm with opname.
    *)
   let is_one_bsubterm opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [_]
      } when opname' == opname -> true
    | _ -> false

   let dest_one_bsubterm opname t = match dest_term t with
      { term_op = { imp_op_name = opname'; imp_op_params = [] };
        term_terms = [bterm]
      } when opname' == opname -> bterm
    | _ -> ref_raise(RefineError ("dest_one_bsubterm", TermMatchError (t, "bad arity")))

   let mk_one_bsubterm opname bt =
      { free_vars = bt.bfree_vars;
        core = Term
         { term_op = { imp_op_name = opname; imp_op_params = [] };
           term_terms = [bt] }}

   (************************************************************************
    * TERM MAPS                                                            *
    ************************************************************************)

   (*
    * Sweep a function down through the term.
    *)
   let rec map_down f t =
      let { term_op = op; term_terms = bterms } = dest_term (f t) in
      let apply bterm =
         let { bvars = vars; bterm = t } = dest_bterm bterm in
            make_bterm { bvars = vars; bterm = map_down f t }
      in
         make_term { term_op = op; term_terms = List.map apply bterms }

   let rec map_up f t =
      let apply bterm =
         let { bvars = vars; bterm = t } = dest_bterm bterm in
            make_bterm { bvars = vars; bterm = map_up f t }
      in
      let { term_op = op; term_terms = bterms } = dest_term t in
      let t = make_term { term_op = op; term_terms = List.map apply bterms } in
         f t
end
