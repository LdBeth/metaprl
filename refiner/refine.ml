(*
 * The refiner deals with proofs and functions on them.
 * We have the following objects in a refiner:
 *    + validation: a validation is a function on proofs
 *       for instance:
 *           f: (H, x:A, y:B, J[pair(x, y)] >> C[pair(x, y)]) -->
 *               (H, x:A, J[x] >> C[x])
 *        this declares "f" to be a validation, which is a function
 *        that takes a proof of the first sequent, and produces a
 *        proof of the second.  These validations can have
 *        arbitrary arity.
 *    + extract: an extract is a form of validation generated
 *          during proof refinement using tactics.
 *    + tactic: a tactic is a "reverse" application of a
 *      validation.  That is, given a validation f: A --> B,
 *      to produce a proof of B, all that is necessary is to
 *      produce a proof of A (modus ponens).
 *
 *    + rewrite: a rewrite can be reduced to an equivalence
 *      of terms in any context:
 *         f: A <--> B
 *      declares a rewrite that will convert an A to a B, or
 *      vice versa in any context.  This is the same as the
 *      validation:
 *         f: C:[A] <--> C:[B]
 *
 *    + cond_rewrite: conditional rewrite that requires
 *      a proof to be valid.  For instance,
 *         p: (x in A # B) --> (pair(x.1, x.2) <--> x)
 *      this rewrite can only be applied in a sequent
 *      calculus, and it means:
 *         p: (H >> x in A # B) --> (C:[pair(x.1, x.2)] <--> C:[x])
 *
 *)

open Printf

open Debug
open Term
open Term_util
open Refine_sig
open Refine_util

module Refiner =
struct
   (************************************************************************
    * TYPES                                                                *
    ************************************************************************)
   
   (*
    * A proof has either been computed,
    * or the computation is delayed.
    *)
   type 'a proof =
      Extracted of 'a
    | Delayed of (unit -> 'a)
   
   (*
    * An extract summarizes a validation that is generated by a tactic.
    *
    * The extract type is a tree of terms.  The substitution is
    * delayed, since in most cases the extract term is never
    * computed.
    *
    * The refiner describes the rule that was applied, and
    * in most cases we also list the params to the rule that
    * was applied so that the validation can be called if
    * necessary.  The head rule of the refiner is the applied
    * rule.
    *)
   type extract =
      { ext_goal : msequent;
        ext_just : ext_just;
        ext_subgoals : msequent list
      }
   
   and ext_just =
      SingleJust of single_just
    | PairJust of ext_just * ext_just
    | ComposeJust of ext_just * ext_just list
    | NthHypJust of int
   
   and single_just =
      { (* Parameters to the rule and the rule itself *)
         ext_names : string array;
         ext_params : term list;
         ext_refiner : refiner
      }
   
   (*
    * A refiner contains the following items:
    *    + theorems: terms that are true in a sequent calculus
    *    + rules: implications on proofs
    *    + rewrite: term equivalences in any context
    *    + ml versions of the above
    *
    * refiners can be combined using PairRefiner.
    *)
   and refiner =
      NullRefiner

    | AxiomRefiner of axiom_refiner
    | PrimAxiomRefiner of prim_axiom_refiner

    | RuleRefiner of rule_refiner
    | PrimRuleRefiner of prim_rule_refiner
    | MLRuleRefiner of ml_rule_refiner

    | RewriteRefiner of rewrite_refiner
    | PrimRewriteRefiner of prim_rewrite_refiner

    | CondRewriteRefiner of cond_rewrite_refiner
    | PrimCondRewriteRefiner of prim_cond_rewrite_refiner
    | MLRewriteRefiner of ml_rewrite_refiner

    | PairRefiner of refiner * refiner
    | LabelRefiner of string * refiner
   
   and axiom_refiner =
      { axiom_name : string;
        axiom_term : term;
        axiom_refiner : refiner
      }
   and prim_axiom_refiner =
      { mutable pax_proof : term proof;
        pax_axiom : axiom_refiner;
        pax_refiner : refiner
      }

   and rule_refiner =
      { rule_name : string;
        rule_count : int;
        rule_rule : msequent;
        rule_refiner : refiner
      }
   and prim_rule_refiner =
      { mutable prule_proof : (string array -> term list -> term list -> term) proof;
        prule_rule : rule_refiner;
        prule_refiner : refiner
      }
   and ml_rule_refiner =
      { ml_rule_arg : term;
        ml_rule_rule : ml_rule;
        ml_rule_refiner : refiner
      }

   and rewrite_refiner =
      { rw_name : string;
        rw_rewrite : term * term;
        rw_refiner : refiner
      }
   and prim_rewrite_refiner =
      { mutable prw_proof : unit proof;
        prw_rewrite : rewrite_refiner;
        prw_refiner : refiner
      }

   and cond_rewrite_refiner =
      { crw_name : string;
        crw_count : int;
        crw_rewrite : term list * term * term;
        crw_refiner : refiner
      }
   and prim_cond_rewrite_refiner =
      { mutable pcrw_proof : unit proof;
        pcrw_rewrite : cond_rewrite_refiner;
        pcrw_refiner : refiner
      }
   and ml_rewrite_refiner =
      { ml_rw_name : string;
        ml_rw_rewrite : ml_rewrite;
        ml_rw_refiner : refiner
      }
   
   (*
    * A hashtable is constructed for looking up justifications.
    *)
   type hash =
      { hash_rewrite : (string, prim_rewrite_refiner) Hashtbl.t;
        hash_cond_rewrite : (string, prim_cond_rewrite_refiner) Hashtbl.t;
        hash_axiom : (string, prim_axiom_refiner) Hashtbl.t;
        hash_rule : (string, prim_rule_refiner) Hashtbl.t
      }
   
   type find =
      { find_rewrite : string -> prim_rewrite_refiner;
        find_cond_rewrite : string -> prim_cond_rewrite_refiner;
        find_axiom : string -> prim_axiom_refiner;
        find_rule : string -> prim_rule_refiner
      }
   
   type check =
      { check_rewrite : rewrite_refiner -> prim_rewrite_refiner;
        check_cond_rewrite : cond_rewrite_refiner -> prim_cond_rewrite_refiner;
        check_axiom : axiom_refiner -> prim_axiom_refiner;
        check_rule : rule_refiner -> prim_rule_refiner
      }
   
   (*
    * The safe_tactic type is the basic refinement type, and every
    * element of safe_tactic always produces "correct" refinements
    * by construction.  In other words, only primitive rules can
    * be directly injected into the safe_tactic type, and all else is
    * by composition.
    *
    * Note: the first argument should really be type msequent,
    * but it is more efficient to use ('a tactic_arg) because
    * the coercion ('a tactic_arg -> msequent) costs a needless
    * memory allocation.
    *)
   and 'a safe_tactic = 'a tactic_arg -> 'a tactic_arg list * ext_just
   
   (*
    * A rewrite is a function on terms (that can be reversed)
    *)
   and 'a safe_rewrite = term -> 'a rewrite_arg * refiner
   
   (*
    * A conditional rewrite takes a goal, then applies the rewrite
    * and generates subgoals.
    *)
   and 'a safe_cond_rewrite = term -> term -> 'a rewrite_arg * 'a rewrite_arg list * ext_just
   
   (*
    * Abbreviations.
    *)
   and 'a tactic = 'a tactic_arg -> 'a safe_tactic

   and 'a rewrite_arg = term * 'a
   
   and 'a rw = 'a rewrite_arg -> 'a safe_rewrite

   and 'a cond_rewrite_arg = term * term * 'a
     
   and 'a cond_rewrite = 'a cond_rewrite_arg -> 'a safe_cond_rewrite

   (*
    * These are the forms created at compile time.
    *)
   and prim_tactic = address array * string array -> term list -> term -> term list * ext_just
   and prim_rewrite = term -> term * refiner
   and prim_cond_rewrite = (string array * term list) -> term -> term -> term * term list * ext_just
   
   (*
    * For destruction.
    *)
   type refiner_item =
      RIAxiom of ri_axiom
    | RIRule of ri_rule
    | RIPrimTheorem of ri_prim_theorem
    | RIMLRule of ri_ml_rule

    | RIRewrite of ri_rewrite
    | RICondRewrite of ri_cond_rewrite
    | RIPrimRewrite of ri_prim_rewrite
    | RIMLRewrite of ri_ml_rewrite

    | RIParent of refiner
    | RILabel of string

   and ri_axiom =
      { ri_axiom_name : string;
        ri_axiom_term : term
      }
   and ri_rule =
      { ri_rule_name : string;
        ri_rule_rule : msequent
      }
   and ri_ml_rule =
      { ri_ml_rule_arg : term }
   and ri_prim_theorem =
      { ri_pthm_axiom : refiner }

   and ri_rewrite =
      { ri_rw_name : string;
        ri_rw_redex : term;
        ri_rw_contractum : term
      }
   and ri_cond_rewrite =
      { ri_crw_name : string;
        ri_crw_conds : term list;
        ri_crw_redex : term;
        ri_crw_contractum : term
      }
   and ri_prim_rewrite =
      { ri_prw_rewrite : refiner }
   and ri_ml_rewrite =
      { ri_ml_rw_name : string }
   
   (************************************************************************
    * SEQUENT OPERATIONS                                                   *
    ************************************************************************)
   
    (*
     * Check that all the hyps in the list are equal.
     *)
   let equal_hyps hyps t =
      let check hyps' =
         try List.for_all2 alpha_equal hyps' hyps with
            Failure "for_all2" ->
               false
      in
         List.for_all check t
   
   (*
    * Collapse the two arguments to a tactic.
    *)
   let collapse_arg arg seq =
      if arg == seq then
         arg
      else
         let { tac_arg = args } = arg in
         let { tac_goal = goal; tac_hyps = hyps } = seq in
            { tac_goal = goal; tac_hyps = hyps; tac_arg = args }

   (************************************************************************
    * TACTICS                                                              *
    ************************************************************************)
   
   (*
    * Refinement is just application.
    * The application is doubled: the first argument is
    * for type tactic, and the second is for type safe_tactic.
    *)
   let refine (tac : 'a tactic) (arg : 'a tactic_arg) =
      let subgoals, just = tac arg arg in
      let seq = msequent_of_tactic_arg arg in
      let subgoals' = List.map msequent_of_tactic_arg subgoals in
         subgoals, { ext_goal = seq; ext_just = just; ext_subgoals = subgoals' }
   
   (*
    * COMPOSE
    * Compose two extracts.
    * The subgoals of the first must match with the goals of the second.
    *)
   let compose ext extl =
      let { ext_goal = goal; ext_just = just; ext_subgoals = subgoals } = ext in
      let subgoals' = List.map (fun ext -> ext.ext_goal) extl in
      let _ =
         try
            if not (List_util.for_all2 msequent_alpha_equal subgoals subgoals') then
               raise (RefineError (StringError "Refine.compose: goal mistmatch"))
         with
            Failure "for_all2" ->
               raise (RefineError (StringError "Refine.compose: goal mistmatch"))
      in
      let justl = List.map (fun ext -> ext.ext_just) extl in
      let just = ComposeJust (just, justl) in
      let subgoals'' = List_util.flat_map (fun ext -> ext.ext_subgoals) extl in
         { ext_goal = goal; ext_just = just; ext_subgoals = subgoals }
   
   (*
    * NTH_HYP
    * The base tactic proves by assumption.
    *)
   let nth_hyp i _ seq =
      let { tac_goal = goal; tac_hyps = hyps } = seq in
         try
            if alpha_equal (List.nth hyps i) goal then
               [], NthHypJust i
            else
               raise (RefineError (StringError "Refine.nth_hyp: goal mistmatch"))
         with
            Failure "nth" ->
               raise (RefineError (StringIntError ("Refine.nth_hyp: bad argument", i)))

   (*
    * ORELSE
    * orelse tries the first tactic, and if it fails, then it
    * tries the second tactic.
    *)
   let orelse tac1 tac2 arg seq =
      let arg = collapse_arg arg seq in
         try tac1 arg arg with
            RefineError x ->
               (try tac2 arg arg with
                   RefineError y ->
                      raise (RefineError (PairError ("orelse", x, y))))
   
   (*
    * ANDTHEN: do tac1, then
    * do tac2 on all the subgoals,
    * passing the subgoal index.
    *)
   let andthen tac1 tac2 arg seq =
      let arg = collapse_arg arg seq in
      let subgoals, just =
         try tac1 arg arg with
            RefineError x ->
               raise (RefineError (GoalError ("andthen", x)))
      in
      let rec aux i = function
         h::sgtl ->
            let subgoals', just' =
               try tac2 h h with
                  RefineError x ->
                     raise (RefineError (SubgoalError ("andthen", i, x)))
            in
            let subgoals'', justs = aux (i + 1) sgtl in
               subgoals' @ subgoals'', just'::justs
       | [] ->
            [], []
      in
      let subgoals', justs = aux 0 subgoals in
         subgoals', ComposeJust (just, justs)
         
   (*
    * ANDTHENL.
    * Do tac1, then apply the list of tactics to the subgoals
    * in order.  Fail if the list lengths don't match.
    *)
   let andthenL tac1 tac2list arg seq =
      let rec thenlist i = function
         tac::tactl, h::sgtl ->
            let subgoals, just =
               try tac h h with
                  RefineError x ->
                     raise (RefineError (SubgoalError ("andthenL", i, x)))
            in
            let subgoals', justs = thenlist (i + 1) (tactl, sgtl) in
               subgoals @ subgoals', just::justs
       | [], [] ->
            [], []
       | _ ->
            raise (RefineError (StringError "andthenL: argument mismatch"))
      in
      let arg = collapse_arg arg seq in
      let subgoals, just =
         try tac1 arg arg with
            RefineError x ->
               raise (RefineError (GoalError ("andthenL", x)))
      in
      let subgoals', justs = thenlist 0 (tac2list, subgoals) in
         subgoals', ComposeJust (just, justs)
   
   (*
    * ANDTHENFL.
    * Do tac1, then apply the second tactic function to the
    * subgoal list.
    *)
   let andthenFL tac f arg seq =
      let rec apply_list i = function
         stac::stactl, subgoal::sgtl ->
            let subgoals, just =
               try stac subgoal with
                  RefineError x ->
                     raise (RefineError (SubgoalError ("andthenFL", i, x)))
            in
            let subgoals', justs = apply_list (i + 1) (stactl, sgtl) in
               subgoals @ subgoals', just::justs
       | [], [] ->
            [], []
       | _ ->
            raise (RefineError (StringError "andthenFL: argument mismatch"))
      in
      let arg = collapse_arg arg seq in
      let subgoals, just =
         try tac arg arg with
            RefineError x ->
               raise (RefineError (GoalError ("andthenFL", x)))
      in
      let stacs =
         try f subgoals with
            RefineError x ->
               raise (RefineError (SubgoalError ("andthenFL", 0, x)))
      in
      let subgoals', justs' = apply_list 0 (stacs, subgoals) in
         subgoals', ComposeJust (just, justs')
   
   (************************************************************************
    * REGULAR REWRITES                                                     *
    ************************************************************************)
   
   (*
    * Convert a rewrite to a tactic.
    *)
   let rwtactic (rw : 'a rw) { tac_arg = args } (seq : 'a tactic_arg) =
      let { tac_goal = goal; tac_hyps = hyps } = seq in
      let (goal, arg), refiner = rw (goal, args) goal in
         [{ tac_goal = goal; tac_hyps = hyps; tac_arg = args }],
         SingleJust { ext_names = [||]; ext_params = []; ext_refiner = refiner }
   
   (*
    * Apply a rewrite at an address. We use an imperative operation to
    * capture the refiner.  This could be performed functionally, but it
    * would require two applications of the rewrite (one to compute
    * the refiner, and one to compute the result term).
    *)
   let rwaddr addr rw (_, args) t =
      let rval = ref None in
      let rw' t =
         let (t', args'), refiner' = rw (t, args) t in
            rval := Some (args', refiner');
            t'
      in
      let t' =
         try apply_fun_at_addr rw' addr t with
            RefineError x ->
               raise (RefineError (RewriteAddressError ("rwaddr", addr, x)))
      in
         match !rval with
            Some (args', refiner') ->
               (t', args'), refiner'
          | None ->
               raise (RefineError (StringError "rwaddr: address out of range"))
   
   (*
    * Compose two rewrites.
    *)
   let andthenrw rw1 rw2 (_, args) t =
      let ((t', args') as arg), refiner =
         try rw1 (t, args) t with
            RefineError x ->
               raise (RefineError (GoalError ("andthenrw", x)))
      in
      let t'', refiner' =
         try rw2 arg t' with
            RefineError x ->
               raise (RefineError (SecondError ("andthenrw", x)))
      in
         t'', PairRefiner (refiner, refiner')
   
   (************************************************************************
    * CONDITIONAL REWRITES                                                 *
    ************************************************************************)
   
   (*
    * Inject a regular rewrite as a conditional rewrite.
    *)
   let mk_cond_rewrite rw (_, _, args) seq t =
      let arg, refiner = rw (t, args) t in
         arg, [], SingleJust { ext_names = [||]; ext_params = []; ext_refiner = refiner }
   
   (*
    * Apply the rewrite to an addressed term.
    *)
   let crwaddr addr rw (_, _, args) seq t =
      let tmp = ref None in
      let rw' t =
         let (t', args'), subgoals, just = rw (seq, t, args) seq t in
            tmp := Some (args', subgoals, just);
            t'
      in
      let t' =
         try apply_fun_at_addr rw' addr t with
            RefineError x ->
               raise (RefineError (RewriteAddressError ("crwaddr", addr, x)))
      in
         match !tmp with
            Some (args', subgoals, just) ->
               (t', args'), subgoals, just
          | None ->
               raise (RefineError (StringError "crwaddr: tactic never applied"))
   
   (*
    * Apply a conditional rewrite.
    *)
   let crwtactic (rw : 'a cond_rewrite) { tac_arg = args } (seq : 'a tactic_arg) =
      let { tac_goal = goal; tac_hyps = hyps } = seq in
      let t', subgoals, just = rw (goal, goal, args) goal goal in
      let mk_subgoal (subgoal, arg) =
         { tac_goal = subgoal; tac_hyps = hyps; tac_arg = arg }
      in
      let subgoals' = List.map mk_subgoal (t' :: subgoals) in
         subgoals', just
   
   (*
    * Apply the rewrite, given the args.
    *)
   let apply_crw rw args seq t =
      let srw, args' = rw (seq, t, args) in
      let t', subgoals, just = srw seq t in
         t', subgoals, just, args'
   
   (*
    * Compose conditional rewrites.
    *)
   let candthenrw rw1 rw2 (_, _, args) seq t =
      let (t', args'), subgoals, just =
         try rw1 (seq, t, args) seq t with
            RefineError x ->
               raise (RefineError (GoalError ("candthenrw", x)))
      in
      let t'', subgoals', just' =
         try rw2 (seq, t', args') seq t' with
            RefineError x ->
               raise (RefineError (SecondError ("candthenrw", x)))
      in
         t'', subgoals @ subgoals', PairJust (just, just')
   
   (************************************************************************
    * UTILITIES                                                            *
    ************************************************************************)
   
   (*
    * Empty refiner.
    *)
   let null_refiner = NullRefiner
   
   (*
    * Combine the refiners into a single refiner.
    * We will eventually have to worry about joining common
    * ancestors.
    *)
   let join_refiner ref1 ref2 =
      ref1 := PairRefiner (ref2, !ref1)
   
   (*
    * Label a refiner with the name of the module.
    *)
   let label_refiner ref1 name =
      ref1 := LabelRefiner (name, !ref1)
   
   (*
    * Search for an axiom by name.
    *)
   let find_refiner refiner name =
      let rec search refiners refiner =
         if List.memq refiner refiners then
            raise Not_found;
         let refiners = refiner :: refiners in
            match refiner with
               NullRefiner ->
                  raise Not_found
             | AxiomRefiner { axiom_name = n; axiom_refiner = next } as r ->
                  if n = name then
                     r
                  else
                     search refiners next
             | PrimAxiomRefiner { pax_refiner = next } ->
                  search refiners next

             | RuleRefiner { rule_name = n; rule_refiner = next } as r ->
                  if n = name then
                     r
                  else
                     search refiners next
             | PrimRuleRefiner { prule_refiner = next } ->
                  search refiners next
             | MLRuleRefiner { ml_rule_refiner = next } ->
                  search refiners next

             | RewriteRefiner { rw_name = n; rw_refiner = next } as r ->
                  if n = name then
                     r
                  else
                     search refiners next
             | PrimRewriteRefiner { prw_refiner = next } ->
                  search refiners next

             | CondRewriteRefiner { crw_name = n; crw_refiner = next } as r ->
                  if n = name then
                     r
                  else
                     search refiners next
             | PrimCondRewriteRefiner { pcrw_refiner = next } ->
                  search refiners next
             | MLRewriteRefiner { ml_rw_name = n; ml_rw_refiner = next } as r ->
                  if n = name then
                     raise (RefineError (StringStringError (n, "ML rewrites can't be justified")))
                  else
                     search refiners next

             | LabelRefiner (_, next) ->
                  search refiners next
             | PairRefiner (next1, next2) ->
                  try search refiners next1 with
                     Not_found ->
                        search refiners next2
      in
         search [] refiner
   
   (************************************************************************
    * EXTRACTION                                                           *
    ************************************************************************)
   
   (*
    * When an term is calculated from an extract, we have to search
    * for the justifications in the current refiner.  We save them
    * in a hashtable by their names and their types.
    *)
   let hash_refiner refiner =
      let rewrites = Hashtbl.create 19 in
      let cond_rewrites = Hashtbl.create 19 in
      let axioms = Hashtbl.create 19 in
      let rules = Hashtbl.create 19 in
      let maybe_add hash name info =
         try Hashtbl.find hash name; () with
            Not_found ->
               Hashtbl.add hash name info
      in
      let rec insert = function
         PrimAxiomRefiner pax ->
            let { pax_axiom = { axiom_name = name }; pax_refiner = next } = pax in
               maybe_add axioms name pax;
               insert next
       | PrimRuleRefiner prule ->
            let { prule_rule = { rule_name = name }; prule_refiner = next } = prule in
               maybe_add rules name prule;
               insert next
       | PrimRewriteRefiner prw ->
            let { prw_rewrite = { rw_name = name }; prw_refiner = next  } = prw in
               maybe_add rewrites name prw;
               insert next
       | PrimCondRewriteRefiner pcrw ->
            let { pcrw_rewrite = { crw_name = name }; pcrw_refiner = next  } = pcrw in
               maybe_add cond_rewrites name pcrw;
               insert next
       | AxiomRefiner { axiom_refiner = next } ->
            insert next
       | RuleRefiner { rule_refiner = next } ->
            insert next
       | RewriteRefiner { rw_refiner = next } ->
            insert next
       | CondRewriteRefiner { crw_refiner = next } ->
            insert next
       | MLRewriteRefiner { ml_rw_refiner = next } ->
            insert next
       | MLRuleRefiner { ml_rule_refiner = next } ->
            insert next
       | LabelRefiner (_, next) ->
            insert next
       | PairRefiner (next1, next2) ->
            insert next1;
            insert next2
       | NullRefiner ->
            ()
      in
      let _ = insert refiner in
         { hash_axiom = axioms;
           hash_rule = rules;
           hash_rewrite = rewrites;
           hash_cond_rewrite = cond_rewrites
         }
   
   (*
    * Lookup values in the hashtable, or print error messages.
    *)
   let find_of_hash { hash_axiom = axioms;
                      hash_rule = rules;
                      hash_rewrite = rewrites;
                      hash_cond_rewrite = cond_rewrites
       } =
      let find_axiom name =
         try Hashtbl.find axioms name with
            Not_found ->
               raise (RefineError (StringStringError (name, "axiom is not justified")))
      in
      let find_rule name =
         try Hashtbl.find rules name with
            Not_found ->
               raise (RefineError (StringStringError (name, "rule is not justified")))
      in
      let find_rewrite name =
         try Hashtbl.find rewrites name with
            Not_found ->
               raise (RefineError (StringStringError (name, "rewrite is not justified")))
      in
      let find_cond_rewrite name =
         try Hashtbl.find cond_rewrites name with
            Not_found ->
               raise (RefineError (StringStringError (name, "cond_rewrite is not justified")))
      in
         { find_axiom = find_axiom;
           find_rule = find_rule;
           find_rewrite = find_rewrite;
           find_cond_rewrite = find_cond_rewrite
         }
   
   (*
    * Also check the matching.
    *)
   let check_of_find { find_axiom = find_axiom;
                       find_rule = find_rule;
                       find_rewrite = find_rewrite;
                       find_cond_rewrite = find_cond_rewrite
       } =
      let check_axiom ax =
         let { axiom_name = name } = ax in
         let pax = find_axiom name in
            if pax.pax_axiom == ax then
               pax
            else
               raise (RefineError (StringStringError (name, "axiom proof does not match")))
      in
      let check_rule rule =
         let { rule_name = name } = rule in
         let prule = find_rule name in
            if prule.prule_rule == rule then
               prule
            else
               raise (RefineError (StringStringError (name, "rule proof does not match")))
      in
      let check_rewrite rw =
         let { rw_name = name } = rw in
         let prw = find_rewrite name in
            if prw.prw_rewrite == rw then
               prw
            else
               raise (RefineError (StringStringError (name, "rewrite proof does not match")))
      in
      let check_cond_rewrite crw =
         let { crw_name = name } = crw in
         let pcrw = find_cond_rewrite name in
            if pcrw.pcrw_rewrite == crw then
               pcrw
            else
               raise (RefineError (StringStringError (name, "cond_rewrite proof does not match")))
      in
         { check_axiom = check_axiom;
           check_rule = check_rule;
           check_rewrite = check_rewrite;
           check_cond_rewrite = check_cond_rewrite
         }
   
   (*
    * Get the extract term for an axiom.
    *)
   let axiom_proof pax =
      match pax.pax_proof with
         Extracted t ->
            t
       | Delayed f ->
            let t = f () in
               pax.pax_proof <- Extracted t;
               t
   
   let rule_proof prule =
      match prule.prule_proof with
         Extracted t ->
            t
       | Delayed f ->
            let t = f () in
               prule.prule_proof <- Extracted t;
               t
   
   let rewrite_proof prw =
      match prw.prw_proof with
         Extracted () ->
            ()
       | Delayed f ->
            prw.prw_proof <- Extracted (f ())
   
   let cond_rewrite_proof pcrw =
      match pcrw.pcrw_proof with
         Extracted () ->
            ()
       | Delayed f ->
            pcrw.pcrw_proof <- Extracted (f ())
   
   (*
    * Expand the extracts of the components.
    *)
   let check = function
      PrimAxiomRefiner pax ->
         axiom_proof pax;
         ()
    | PrimRuleRefiner prule ->
         let _ = rule_proof prule in
            ()
    | PrimRewriteRefiner prw ->
         rewrite_proof prw;
         ()
    | PrimCondRewriteRefiner pcrw ->
         cond_rewrite_proof pcrw;
         ()
    | _ ->
         ()
         
   (*
    * Get the term from an extract.
    * This will fail if some of the rules are not justified.
    *)
   let term_of_extract refiner { ext_just = just } (args : term list) =
      let { check_axiom = find_axiom;
            check_rule = find_rule;
            check_rewrite = find_rewrite;
            check_cond_rewrite = find_cond_rewrite
          } = check_of_find (find_of_hash (hash_refiner refiner))
      in
      let split_first = function
         h::t ->
            h, t
       | [] ->
            raise (Failure "Refine.term_of_extract: extract list is empty")
      in
      let split_list i l =
         try List_util.split_list i l with
            Failure _ ->
               raise (Failure "Refine.term_of_extract: extract list too short")
      in
      let nth_tl i l =
         try List_util.nth_tl i l with
            Failure _ ->
               raise (Failure "Refine.term_of_extract: extract list too short")
      in
      let rec construct extracts = function
         SingleJust { ext_names = names; ext_params = params; ext_refiner = refiner } ->
            begin
               match refiner with
                  AxiomRefiner ax ->
                     axiom_proof (find_axiom ax), extracts
                | RuleRefiner rule ->
                     let { rule_count = count } = rule in
                     let hd, tl = split_list count extracts in
                        rule_proof (find_rule rule) names params hd, tl
                | MLRuleRefiner { ml_rule_rule = { ml_rule_extract = f } } ->
                     f (names, params) extracts
                | RewriteRefiner rw ->
                     find_rewrite rw;
                     split_first extracts
                | CondRewriteRefiner crw ->
                     let { crw_count = count } = crw in
                     let hd, tl = split_first extracts in
                        find_cond_rewrite crw;
                        hd, nth_tl count tl
                | MLRewriteRefiner _ ->
                     split_first extracts
                | _ ->
                     raise (Failure "Refine.term_of_extract: refine error")
            end
       | PairJust (just1, just2) ->
            let extract, extracts = construct extracts just2 in
               construct (extract :: extracts) just1
       | ComposeJust (just, justl) ->
            let rec collect extracts = function
               just :: justl ->
                  let extract, extracts = construct extracts just in
                     extract :: collect extracts justl
             | [] ->
                  extracts
            in
               construct (collect extracts justl) just
       | NthHypJust i ->
            List.nth args i, extracts
      in
         fst (construct [] just)
   
         

   (************************************************************************
    * AXIOM                                                                *
    ************************************************************************)

   (*
    * An theorem is a special case of a rule, where to
    * arity is 1, and there are no addrs or params.
    * Still get a tactic by this name (the equivalent
    * of BackThruLemma `name`).
    *)
   let check_axiom term =
      match Term.context_vars term with
         [] ->
            true
       | l ->
            raise (FreeContextVars l)
   
   let add_axiom refiner name term =
      if debug_refiner then
         eprintf "Refiner.add_axiom: %s%t" name eflush;
      let refiner' =
         AxiomRefiner { axiom_name = name;
                        axiom_term = term;
                        axiom_refiner = refiner
         }
      in
      let tac _ _ t =
         if alpha_equal (nth_concl t 0) term then
            [], SingleJust { ext_names = [||]; ext_params = []; ext_refiner = refiner' }
         else
            raise (Term.TermMatch ("add_axiom_refine", t, ""))
      in
         check_axiom term;
         refiner', tac
   
   let add_prim_axiom refiner name term =
      if debug_refiner then
         eprintf "Refiner.prim_axiom: %s%t" name eflush;
      match find_refiner refiner name with
         AxiomRefiner ax ->
            PrimAxiomRefiner { pax_proof = Extracted term;
                               pax_axiom = ax;
                               pax_refiner = refiner
            }
       | _ ->
            raise (RefineError (StringStringError (name, "not an axiom")))
   
   let add_delayed_axiom refiner name extf =
      if debug_refiner then
         eprintf "Refiner.delayed_axiom: %s%t" name eflush;
      match find_refiner refiner name with
         AxiomRefiner ax ->
            let compute () =
               let { axiom_term = goal } = ax in
               let ext = extf () in
               let { ext_goal = { mseq_goal = goal' }; ext_subgoals = subgoals } = ext in
                  if not (alpha_equal (nth_concl goal' 0) goal) or subgoals != [] then
                     raise (RefineError (StringStringError (name, "not justified")));
                  term_of_extract refiner ext []
            in
               PrimAxiomRefiner { pax_proof = Delayed compute;
                                  pax_axiom = ax;
                                  pax_refiner = refiner
               }
       | _ ->
            raise (RefineError (StringStringError (name, "not an axiom")))
   
   (************************************************************************
    * RULE                                                                 *
    ************************************************************************)
   
   (*
    * Create a rule from a meta-term.
    * We allow first-order rules (T -> ... -> T)
    * where each T must be a term, and the arity is arbitrary,
    * and there are no dependencies.
    *)
   let add_rule refiner name addrs names params mterm =
      if debug_refiner then
         eprintf "Refiner.add_rule: %s%t" name eflush;
      let terms = unzip_mimplies mterm in
      let subgoals, goal = List_util.split_last terms in
      let seq = { mseq_goal = goal; mseq_hyps = subgoals } in
      let rw =
         try Rewrite.term_rewrite (addrs, names) (goal :: params) subgoals with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
      let refiner' =
         RuleRefiner { rule_name = name;
                       rule_count = List.length subgoals;
                       rule_rule = seq;
                       rule_refiner = refiner
         }
      in
      let tac addrs_names params t =
         let subgoals, names' =
            try Rewrite.apply_rewrite rw addrs_names (t :: params) with
               Rewrite.RewriteError error ->
                  raise (RefineError (RewriteError (name, error)))
         in
         let just =
            SingleJust { ext_names = names';
                         ext_params = params;
                         ext_refiner = refiner'
            }
         in
            subgoals, just
      in
         refiner', tac
   
   (*
    * Theorem for a previous theorem or rule.
    * We once again use the rewriter to compute the
    * extract.  The subextracts are shaped into a
    * term of the form:
    *    lambda(a. lambda(b. ... cons(arg1; cons(arg2; ... cons(argn, nil)))))
    *)
   let compute_rule_ext name vars params args result =
      (* Create redex term *)
      let l = Array.length vars in
      let create_redex vars args =
         let args' = mk_xlist_term args in
         let rec aux j =
            if j < l then
               mk_xlambda_term vars.(j) (aux (j + 1))
            else
               args'
         in
            aux 0
      in
      let rw =
         try Rewrite.term_rewrite ([||], [||]) (create_redex vars args :: params) [result] with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
      let compute_ext vars params args =
         match
            try Rewrite.apply_rewrite rw ([||], [||]) (create_redex vars args :: params) with
               Rewrite.RewriteError error ->
                  raise (RefineError (RewriteError (name, error)))
         with
            [c], x when Array.length x = 0 ->
               c
          | _ ->
               raise (Failure "Refine.add_prim_theorem.compute_ext: faulty extract")
      in
         compute_ext
   
   let add_prim_rule refiner name vars params args result =
      if debug_refiner then
         eprintf "Refiner.add_prim_theorem: %s%t" name eflush;
      match find_refiner refiner name with
         RuleRefiner rule ->
            let compute_ext = compute_rule_ext name vars params args result in
               PrimRuleRefiner { prule_proof = Extracted compute_ext;
                                 prule_rule = rule;
                                 prule_refiner = refiner
               }
       | _ ->
            raise (RefineError (StringStringError (name, "not a rule")))
   
   let add_delayed_rule refiner name vars params args ext =
      if debug_refiner then
         eprintf "Refiner.delayed_rule: %s%t" name eflush;
      match find_refiner refiner name with
         RuleRefiner rule ->
            let compute_ext () =
               let ext = ext () in
               let { rule_rule = goal } = rule in
               let { ext_goal = goal'; ext_subgoals = subgoals } = ext in
               let _ =
                  if not (msequent_alpha_equal goal' goal) or subgoals <> [] then
                     raise (RefineError (StringError "Refine.add_derived_rule: extract does not match"))
               in
               let t = term_of_extract refiner ext args in
                  compute_rule_ext name vars params args t 
            in
               PrimRuleRefiner { prule_proof = Delayed compute_ext;
                                 prule_rule = rule;
                                 prule_refiner = refiner
               }
       | _ ->
            raise (RefineError (StringStringError (name, "not a rule")))
   
   (*
    * An ML condition.
    *)
   let add_ml_rule refiner arg rule =
      if debug_refiner then
         eprintf "Refiner.add_ml_rule%t" eflush;
      let refiner' =
         MLRuleRefiner { ml_rule_arg = arg;
                         ml_rule_rule = rule;
                         ml_rule_refiner = refiner
         }
      in
      let { ml_rule_rewrite = rw } = rule in
      let tac (_, names) params t =
         let subgoals = rw (names, params) t in
         let just =
            SingleJust { ext_names = names;
                         ext_params = params;
                         ext_refiner = refiner'
            }
         in
            subgoals, just
      in
         refiner', tac
   
   (*
    * Create a tactic from the rule.
    *)
   let tactic_of_rule (tac : prim_tactic) addrs_names params { tac_arg = args } seq =
      let { tac_goal = goal; tac_hyps = hyps } = seq in
      let subgoals, just = tac addrs_names params goal in
      let subgoals =
         List.map (function t -> { tac_goal = t; tac_hyps = hyps; tac_arg = args }) subgoals
      in
         subgoals, just
   
   (*
    * Just do the checking.
    *)
   let check_rule name addrs names params mterm =
      let terms = unzip_mimplies mterm in
      let subgoals, goal = List_util.split_last terms in
      let rw =
         try Rewrite.term_rewrite (addrs, names) (goal::params) subgoals with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
         true
   
   (************************************************************************
    * REWRITE                                                              *
    ************************************************************************)
   
   (*
    * See if the rewrite will compile.
    *)
   let check_rewrite name vars params subgoals redex contractum =
      let rw =
         try Rewrite.term_rewrite ([||], vars) (redex::params) [contractum] with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
         true
   
   (*
    * Create a simple rewrite from a meta-term.
    * The rewrite must be a MetaIff.
    *)
   let add_rewrite refiner name redex contractum =
      if debug_refiner then
         eprintf "Refiner.add_rewrite: %s%t" name eflush;
      let rw =
         try Rewrite.term_rewrite ([||], [||]) [redex] [contractum] with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
      let refiner' =
         RewriteRefiner { rw_name = name;
                          rw_rewrite = redex, contractum;
                          rw_refiner = refiner
         }
      in
      let rw t =
         match
            try Rewrite.apply_rewrite rw ([||], [||]) [t] with
               Rewrite.RewriteError error ->
                  raise (RefineError (RewriteError (name, error)))
         with
            [t'], _ ->
               t', refiner'
          | [], _ ->
               raise (Failure "Refine.add_rewrite: no contracta")
          | _ ->
               raise (Failure "Refine.add_Rewrite: multiple contracta")
      in
         refiner', rw
   
   let add_prim_rewrite refiner name redex contractum =
      if debug_refiner then
         eprintf "Refiner.add_prim_rewrite: %s%t" name eflush;
      match find_refiner refiner name with
         RewriteRefiner rw ->
            let { rw_rewrite = redex', contractum' } = rw in
            let term1 = mk_xlist_term [redex; contractum] in
            let term2 = mk_xlist_term [redex'; contractum'] in
               if alpha_equal term1 term2 then
                  PrimRewriteRefiner { prw_rewrite = rw;
                                       prw_refiner = refiner;
                                       prw_proof = Extracted ()
                  }
               else
                  raise (RefineError (StringStringError (name, "not a rewrite")))
       | _ ->
            raise (RefineError (StringStringError (name, "not a rewrite")))
   
   let add_delayed_rewrite refiner name redex contractum ext =
      if debug_refiner then
         eprintf "Refiner.add_delayed_rewrite: %s%t" name eflush;
      match find_refiner refiner name with
         RewriteRefiner rw ->
            let compute_ext () =
               let { rw_rewrite = redex, contractum } = rw in
               let ext = ext () in
               let { ext_goal = goal; ext_subgoals = subgoals } = ext in
               let t =
                  match goal, subgoals with
                     { mseq_goal = goal; mseq_hyps = [] },
                     [{ mseq_goal = subgoal; mseq_hyps = [] }] ->
                        if alpha_equal goal redex & alpha_equal subgoal contractum then
                           term_of_extract refiner ext []
                        else
                           raise (RefineError (StringError "Refine.add_delayed_rewrite: extract does not match"))
                   | _ ->
                        raise (RefineError (StringError "Refine.add_delayed_rewrite: bogus proof"))
               in
                  ()
            in
               PrimRewriteRefiner { prw_proof = Delayed compute_ext;
                                    prw_rewrite = rw;
                                    prw_refiner = refiner
               }
       | _ ->
            raise (RefineError (StringStringError (name, "not a rewrite")))
   
   (*
    * Get a polymorphic rewrite.
    *)
   let rewrite_of_rewrite (rw : prim_rewrite) (_, args) t =
      let t', refiner = rw t in
         (t', args), refiner
   
   (************************************************************************
    * CONDITIONAL REWRITE                                                  *
    ************************************************************************)
   
   (*
    * Conditional rewrite.
    *)
   let add_cond_rewrite refiner name vars params subgoals redex contractum =
      if debug_refiner then
         eprintf "Refiner.add_cond_rewrite: %s%t" name eflush;
      let rw =
         try Rewrite.term_rewrite ([||], vars) (redex::params) [contractum] with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
      let refiner' =
         CondRewriteRefiner { crw_name = name;
                              crw_count = List.length subgoals;
                              crw_rewrite = subgoals, redex, contractum;
                              crw_refiner = refiner
         }
      in
      let rw' (vars, params) seq t =
         let subgoals' = List.map (replace_goal seq) subgoals in
            match
               try Rewrite.apply_rewrite rw ([||], vars) (t :: params) with
                  Rewrite.RewriteError error ->
                     raise (RefineError (RewriteError (name, error)))
            with
               [t'], names ->
                  t',
                  subgoals',
                  SingleJust { ext_names = names;
                               ext_params = params;
                               ext_refiner = refiner'
                  }
             | [], _ ->
                  raise (Failure "Refine.add_cond_rewrite: no contracta")
             | _ ->
                  raise (Failure "Refine.add_cond_rewrite: multiple contracta")
      in
         refiner', rw'
   
   let add_prim_cond_rewrite refiner name vars params subgoals redex contractum =
      if debug_refiner then
         eprintf "Refiner.add_prim_cond_rewrite: %s%t" name eflush;
      match find_refiner refiner name with
         CondRewriteRefiner crw ->
            let { crw_rewrite = subgoals', redex', contractum' } = crw in
            let term1 = mk_xlist_term (redex :: contractum :: subgoals) in
            let term2 = mk_xlist_term (redex' ::  contractum' :: subgoals') in
               if alpha_equal term1 term2 then
                  PrimCondRewriteRefiner { pcrw_proof = Extracted ();
                                           pcrw_rewrite = crw;
                                           pcrw_refiner = refiner
                  }
               else
                  raise (RefineError (StringStringError (name, "not a conditional rewrite")))
          | _ ->
               raise (RefineError (StringStringError (name, "not a conditional rewrite")))
   
   let add_delayed_cond_rewrite refiner name vars params subgoals redex contractum ext =
      if debug_refiner then
         eprintf "Refiner.add_delayed_cond_rewrite: %s%t" name eflush;
      match find_refiner refiner name with
         CondRewriteRefiner crw ->
            let compute_ext () =
               let ext = ext () in
               let { ext_goal = goal; ext_subgoals = subgoals' } = ext in
               let { mseq_goal = goal; mseq_hyps = goal_hyps } = goal in
               let subgoals', sub_hyps = split_sequent_list subgoals' in
               let { crw_rewrite = subgoals, redex, contractum } = crw in
               let redex = replace_goal goal redex in
               let contractum = replace_goal goal contractum in
               let subgoals = List.map (replace_goal goal) subgoals in
                  try
                     equal_hyps goal_hyps sub_hyps;
                     List_util.for_all2 alpha_equal (redex :: contractum :: subgoals) (goal :: subgoals);
                     term_of_extract refiner ext [];
                     ()
                  with
                     Failure "for_all2" ->
                        raise (RefineError (StringError "Refine.add_delayed_cond_rewrite: derivation does not match"))
            in
               PrimCondRewriteRefiner { pcrw_proof = Delayed compute_ext;
                                        pcrw_rewrite = crw;
                                        pcrw_refiner = refiner
               }
       | _ ->
            raise (RefineError (StringStringError (name, "not a conditional rewrite")))
   
   let rewrite_of_cond_rewrite (rw : prim_cond_rewrite) vars_params (_, _, args) seq t =
      let t', subgoals', just = rw vars_params seq t in
         (t', args), List.map (function t -> (t, args)) subgoals', just
   
   (*
    * An ML rewrite.
    *)
   let add_ml_rewrite refiner name subgoals rw =
      let refiner' =
         MLRewriteRefiner { ml_rw_name = name;
                            ml_rw_rewrite = rw;
                            ml_rw_refiner = refiner
         }
      in
      let rw' ((vars, params) as args) seq t =
         let subgoals' = List.map (replace_goal seq) subgoals in
         let t' = rw args t in
         let just = SingleJust { ext_names = vars;
                                 ext_params = params;
                                 ext_refiner = refiner'
                               }
         in
            t', subgoals', just
      in
         refiner', rw'
   
   (************************************************************************
    * API FUNCTIONS                                                        *
    ************************************************************************)

   (*
    * Axiom creation.
    *)
   let create_axiom refiner name term =
      let refiner', tac = add_axiom !refiner name term in
         refiner := refiner';
         (tac : prim_tactic)
   
   let prim_axiom refiner name term =
      refiner := add_prim_axiom !refiner name term
   
   let delayed_axiom refiner name extf =
      refiner := add_delayed_axiom !refiner name extf
   
   let derived_axiom refiner name ext =
      let extf () = ext in
      let refiner' = add_delayed_axiom !refiner name extf in
         check refiner';
         refiner := refiner'
   
   (*
    * Rules.
    *)
   let create_rule refiner name addrs names params mterm =
      let refiner', tac = add_rule !refiner name addrs names params mterm in
         refiner := refiner';
         tac
   
   let prim_rule refiner name vars params args result =
      refiner :=  add_prim_rule !refiner name vars params args result
   
   let delayed_rule refiner name vars params args extf =
      refiner := add_delayed_rule !refiner name vars params args extf
   
   let derived_rule refiner name vars params args ext =
      let extf () = ext in
      let refiner' = add_delayed_rule !refiner name vars params args extf in
         check refiner';
         refiner := refiner'
   
   let create_ml_rule refiner term mlr =
      let refiner', tac = add_ml_rule !refiner term mlr in
         refiner := refiner';
         tac

   (*
    * Rewrites.
    *)
   let create_rewrite refiner name redex contractum =
      let refiner', rw = add_rewrite !refiner name redex contractum in
         refiner := refiner';
         rw
   
   let prim_rewrite refiner name redex contractum =
      refiner := add_prim_rewrite !refiner name redex contractum
   
   let delayed_rewrite refiner name redex contractum extf =
      refiner := add_delayed_rewrite !refiner name redex contractum extf
   
   let derived_rewrite refiner name redex contractum ext =
      let extf () = ext in
      let refiner' = add_delayed_rewrite !refiner name redex contractum extf in
         check refiner';
         refiner := refiner'
   
   (*
    * Condiitional rewrites.
    *)
   let create_cond_rewrite refiner name vars params args redex contractum =
      let refiner', rw = add_cond_rewrite !refiner name vars params args redex contractum in
         refiner := refiner';
         rw
   
   let prim_cond_rewrite refiner name vars params args redex contractum =
      refiner := add_prim_cond_rewrite !refiner name vars params args redex contractum
   
   let delayed_cond_rewrite refiner name vars params args redex contractum extf =
      refiner := add_delayed_cond_rewrite !refiner name vars params args redex contractum extf
   
   let derived_cond_rewrite refiner name vars params args redex contractum ext =
      let extf () = ext in
      let refiner' = add_delayed_cond_rewrite !refiner name vars params args redex contractum extf in
         check refiner';
         refiner := refiner'
   
   let create_ml_rewrite refiner name subgoals rw =
      let refiner', rw' = add_ml_rewrite !refiner name subgoals rw in
         refiner := refiner';
         (rw' : prim_cond_rewrite)
   
   (************************************************************************
    * DESTRUCTORS                                                          *
    ************************************************************************)
   
   (*
    * Null refiners.
    *)
   let is_null_refiner = function
      NullRefiner -> true
    | _ -> false
   
   (*
    * Get the next item from a refiner.
    *)
   let dest_refiner = function
      NullRefiner ->
         raise (Invalid_argument "dest_refiner")

    | AxiomRefiner { axiom_name = n; axiom_term = t; axiom_refiner = r } ->
         RIAxiom { ri_axiom_name = n; ri_axiom_term = t }, r
    | PrimAxiomRefiner { pax_axiom = ax; pax_refiner = r } ->
         RIPrimTheorem { ri_pthm_axiom = AxiomRefiner ax }, r

    | RuleRefiner { rule_name = n; rule_rule = t; rule_refiner = r } ->
         RIRule { ri_rule_name = n; ri_rule_rule = t }, r
    | MLRuleRefiner { ml_rule_arg = cond; ml_rule_refiner = r } ->
         RIMLRule { ri_ml_rule_arg = cond }, r
    | PrimRuleRefiner { prule_rule = rule; prule_refiner = r } ->
         RIPrimTheorem { ri_pthm_axiom = RuleRefiner rule }, r

    | RewriteRefiner { rw_name = n; rw_rewrite = redex, con; rw_refiner = r } ->
         RIRewrite { ri_rw_name = n;
                     ri_rw_redex = redex;
                     ri_rw_contractum = con
         }, r
    | PrimRewriteRefiner { prw_rewrite = r1; prw_refiner = r2 } ->
         RIPrimRewrite { ri_prw_rewrite = RewriteRefiner r1 }, r2

    | CondRewriteRefiner { crw_name = n; crw_rewrite = conds, redex, con; crw_refiner = r } ->
         RICondRewrite { ri_crw_name = n;
                         ri_crw_conds = conds;
                         ri_crw_redex = redex;
                         ri_crw_contractum = con
         },
         r
    | PrimCondRewriteRefiner { pcrw_rewrite = r1; pcrw_refiner = r2 } ->
         RIPrimRewrite { ri_prw_rewrite = CondRewriteRefiner r1 }, r2
    | MLRewriteRefiner { ml_rw_name = n; ml_rw_refiner = r } ->
         RIMLRewrite { ri_ml_rw_name = n }, r

    | PairRefiner (par, r) ->
         RIParent par, r
    | LabelRefiner (name, r) ->
         RILabel name, r
end

(*
 * $Log$
 * Revision 1.6  1998/04/22 14:06:35  jyh
 * Implementing proof editor.
 *
 * Revision 1.5  1998/04/21 19:53:57  jyh
 * Upgraded refiner for program extraction.
 *
 * Revision 1.4  1998/04/17 20:48:39  jyh
 * Updating refiner for extraction.
 *
 * Revision 1.3  1997/08/07 19:43:45  jyh
 * Updated and added Lori's term modifications.
 * Need to update all pattern matchings.
 *
 * Revision 1.2  1997/08/06 16:18:12  jyh
 * This is an ocaml version with subtyping, type inference,
 * d and eqcd tactics.  It is a basic system, but not debugged.
 *
 * Revision 1.1  1997/04/28 15:51:30  jyh
 * This is the initial checkin of Nuprl-Light.
 * I am porting the editor, so it is not included
 * in this checkin.
 *
 * Directories:
 *     refiner: logic engine
 *     filter: front end to the Ocaml compiler
 *     editor: Emacs proof editor
 *     util: utilities
 *     mk: Makefile templates
 *
 * Revision 1.17  1996/09/25 22:52:00  jyh
 * Initial "tactical" commit.
 *
 * Revision 1.16  1996/05/21 02:14:04  jyh
 * This is a semi-working version before Wisconsin vacation.
 *
 * Revision 1.15  1996/04/07 18:24:49  jyh
 * This is an intermediate commit while adjusting the dforms.
 * We intend that dform printers just return a list of terms.
 *
 * Revision 1.14  1996/03/25 20:50:43  jyh
 * Intermediate commit while modifying grammer.  Restricting
 * ML hooks to condition terms.
 *
 * Revision 1.13  1996/03/11 18:34:23  jyh
 * The filterModule module is untested, but it seems to work
 * correctly on most inputs, except for mlbegin ... mlend expressions.
 * That's the next task.
 *
 * Revision 1.12  1996/03/08 15:40:48  jyh
 * This version works for most constructs except for ML rewrites.
 * The next step will be to break apart the rewriter so that
 * redices and contracta can be compiled separately.
 *
 * Revision 1.11  1996/03/05 19:48:34  jyh
 * Preliminary version with logical framework.
 *
 * Revision 1.10  1996/02/25 15:16:17  jyh
 * This is a partial checkin as filterModule is being developed.
 * After the meta-logical framework is developed, sequent.* will go away.
 *
 * Revision 1.9  1996/02/18 23:32:31  jyh
 * Changin Format module to more Nuprl-like format.
 *
 * Revision 1.8  1996/02/14 03:51:51  jyh
 * This is a version common to Caml-Light and Caml-Special-Light.
 *
 * Revision 1.7  1996/02/13 21:32:28  jyh
 * This is an intermediate checkin while matching is being added to the rewriter.
 *
 * Revision 1.6  1996/02/10 20:19:55  jyh
 * Initial checkin of filter (prlcomp).
 *
 * Revision 1.5  1996/02/08 16:02:30  jyh
 * Adding type Theory.
 *
 * Revision 1.4  1996/02/07 23:41:15  jyh
 * First working version in CamlSpecialLight.
 *
 * Revision 1.3  1996/02/07 17:34:08  jyh
 * This is Version 0 of the refiner in Caml-Light.  At this point,
 * Caml-Light becomes a branch, and main development will be
 * in Caml-Special-Light.
 *
 * Revision 1.2  1996/02/05 18:14:53  jyh
 * Merge context rewrites onto the main branch.
 *
 * Revision 1.1.4.1  1996/02/05 06:09:53  jyh
 * This version has the rewriter with contexts, and Rule application
 * in Sequent.ml, but it is not fully debugged.
 *
 * Revision 1.1  1996/01/31 20:02:39  jyh
 * Generalizing rewriter to work on Sequents.
 *
 * -*-
 * Local Variables:
 * Caml-master: "refiner.run"
 * End:
 * -*-
 *)
