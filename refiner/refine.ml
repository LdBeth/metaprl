(*
 * The refiner deals with proofs and functions on them.
 * We have the following objects in a refiner:
 *    + proof: a proof is a complete proof of a goal
 *    + validation: a validation is a function on proofs
 *       for instance:
 *           f: (H, x:A, y:B, J[pair(x, y)] >> C[pair(x, y)]) -->
 *               (H, x:A, J[x] >> C[x])
 *        this declares "f" to be a validation, which is a function
 *        that takes a proof of the first sequent, and produces a
 *        proof of the second.  These validations can have
 *        arbitrary arity.
 *    + extract: an extract is a form of validation generated
 *          during proof refinement using tactics.
 *    + tactic: a tactic is a "reverse" application of a
 *      validation.  That is, given a validation f: A --> B,
 *      to produce a proof of B, all that is necessary is to
 *      produce a proof of A (modus ponens).
 *
 *    + rewrite: a rewrite can be reduced to an equivalence
 *      of terms in any context:
 *         f: A <--> B
 *      declares a rewrite that will convert an A to a B, or
 *      vice versa in any context.  This is the same as the
 *      validation:
 *         f: C:[A] <--> C:[B]
 *
 *    + cond_rewrite: conditional rewrite that requires
 *      a proof to be valid.  For instance,
 *         p: (x in A # B) --> (pair(x.1, x.2) <--> x)
 *      this rewrite can only be applied in a sequent
 *      calculus, and it means:
 *         p: (H >> x in A # B) --> (C:[pair(x.1, x.2)] <--> C:[x])
 *
 *)

open Printf

open Debug
open Term
open Term_util
open Refine_sig

module Refiner =
struct
   (************************************************************************
    * TYPES                                                                *
    ************************************************************************)
   
   (*
    * For now, a proof has a goal and an extract.
    *)
   type proof =
      { proof_goal : term;
        proof_ext : term
      }
   
   (*
    * An extract summarizes a validation that is generated by a tactic.
    *
    * The extract type is a tree of terms.  The substitution is
    * delayed, since in most cases the extract term is never
    * computed.
    *
    * The refiner describes the rule that was applied, and
    * in most cases we also list the params to the rule that
    * was applied so that the validation can be called if
    * necessary.  The head rule of the refiner is the applied
    * rule.
    *)
   type extract =
      { ext_goal : term;
        ext_just : ext_just;
        ext_subgoals : term list
      }
   
   and ext_just =
      SingleJust of single_just
    | PairJust of ext_just * ext_just
    | ComposeJust of ext_just * ext_just list
   
   and single_just =
      { (* Parameters to the rule + the rule itself *)
        ext_names : string array;
        ext_params : term list;
        ext_refiner : refiner
      }
   
   (*
    * A refiner contains the following items:
    *    + theorems: terms that are true in a sequent calculus
    *    + rules: implications on proofs
    *    + rewrite: term equivalences in any context
    *    + ml versions of the above
    *
    * refiners can be combined using PairRefiner or JointRefiner.
    *)
   and refiner =
      NullRefiner
    | AxiomRefiner of axiom_refiner_type
    | RuleRefiner of rule_refiner_type
    | RewriteRefiner of rewrite_refiner_type
    | CondRewriteRefiner of cond_rewrite_refiner_type
    | PrimRewriteRefiner of prim_rewrite_refiner_type
    | MLRewriteRefiner of ml_rewrite_refiner_type
    | MLRuleRefiner of ml_rule_refiner_type
    | MLConditionRefiner of ml_condition_refiner_type
    | PrimTheoremRefiner of prim_theorem_refiner_type
    | PairRefiner of refiner * refiner
    | LabelRefiner of string * refiner
   
   and axiom_refiner_type =
      { axiom_name : string;
        axiom_term : term;
        axiom_refiner : refiner
      }
   and rule_refiner_type =
      { rule_name : string;
        rule_rule : meta_term;
        rule_refiner : refiner
      }
   and rewrite_refiner_type =
      { rw_name : string;
        rw_rewrite : term * term;
        rw_refiner : refiner
      }
   and cond_rewrite_refiner_type =
      { crw_name : string;
        crw_rewrite : term list * term * term;
        crw_refiner : refiner
      }
   and prim_rewrite_refiner_type =
      { prw_rewrite : refiner;
        prw_refiner : refiner
      }
   and ml_rewrite_refiner_type =
      { ml_rw_name : string;
        ml_rw_rewrite : ml_rewrite;
        ml_rw_refiner : refiner
      }
   and ml_rule_refiner_type =
      { ml_rule_name : string;
        ml_rule_rule : ml_rule;
        ml_rule_refiner : refiner
      }
   and ml_condition_refiner_type =
      { ml_cond_arg : term;
        ml_cond_refiner : refiner
      }
   and prim_theorem_refiner_type =
      { pthm_proof : string array -> term list -> term list -> term;
        pthm_axiom : refiner;
        pthm_refiner : refiner
      }
   
   (*
    * The safe_tactic type is the basic refinement type, and every
    * element of safe_tactic always produces "correct" refinements
    * by construction.  In other words, only primitive rules can
    * be directly injected into the safe_tactic type, and all else is
    * by composition.
    *)
   and 'a safe_tactic = term -> 'a tactic_arg list * ext_just
   
   (*
    * A rewrite is a function on terms (that can be reversed)
    *)
   and 'a safe_rewrite = term -> 'a rewrite_arg * refiner
   
   (*
    * A conditional rewrite takes a goal, then applies the rewrite
    * and generates subgoals.
    *)
   and 'a safe_cond_rewrite = term -> term -> 'a rewrite_arg * 'a rewrite_arg list * ext_just
   
   (*
    * Abbreviations.
    *)
   and 'a tactic_arg = term * 'a
     
   and 'a tactic = 'a tactic_arg -> 'a safe_tactic

   and 'a rewrite_arg = term * 'a
   
   and 'a rw = 'a rewrite_arg -> 'a safe_rewrite

   and 'a cond_rewrite_arg = term * term * 'a
     
   and 'a cond_rewrite = 'a cond_rewrite_arg -> 'a safe_cond_rewrite

   (*
    * These are the forms created at compile time.
    *)
   and prim_tactic = address array * string array -> term list -> term -> term list * ext_just
   and prim_rewrite = term -> term * refiner
   and prim_cond_rewrite = (string array * term list) -> term -> term -> term * term list * ext_just
   and ml_rewrite = (string array * term list) -> term -> term
   and ml_rule = term -> term list
   and ml_condition = term -> term list
   
   (*
    * For destruction.
    *)
   type refiner_item =
      RIAxiom of axiom_type
    | RIRule of rule_type
    | RIRewrite of rewrite_type
    | RICondRewrite of cond_rewrite_type
    | RIPrimRewrite of prim_rewrite_type
    | RIMLRewrite of ml_rewrite_type
    | RIMLRule of ml_rule_type
    | RIMLCondition of ml_condition_type
    | RIPrimTheorem of prim_theorem_type
    | RIParent of refiner
    | RILabel of string

   and axiom_type =
      { ri_axiom_name : string; ri_axiom_term : term }
   and rule_type =
      { ri_rule_name : string; ri_rule_rule : meta_term }
   and rewrite_type =
      { ri_rw_name : string; ri_rw_redex : term; ri_rw_contractum : term }
   and cond_rewrite_type =
      { ri_crw_name : string;
        ri_crw_conds : term list;
        ri_crw_redex : term;
        ri_crw_contractum : term
      }
   and prim_rewrite_type =
      { ri_prw_rewrite : refiner }
   and ml_rewrite_type =
      { ri_ml_rw_name : string }
   and ml_rule_type =
      { ri_ml_rule_name : string }
   and ml_condition_type =
      { ri_ml_cond_arg : term }
   and prim_theorem_type =
      { ri_pthm_axiom : refiner }

   (*
    * Exceptions.
    *)
   exception BadTheorem of string * refiner

   (************************************************************************
    * TACTICS                                                              *
    ************************************************************************)
   
   (*
    * Refinement is just application.
    * The application is doubled: the first argument is
    * for type tactic, and the second is for type safe_tactic.
    *)
   let refine tac ((seq, args) as arg) =
      let subgoals, just = tac arg seq in
      let subgoals' = List.map fst subgoals in
         subgoals, { ext_goal = seq; ext_just = just; ext_subgoals = subgoals' }
   
   (*
    * ORELSE
    * orelse tries the first tactic, and if it fails, then it
    * tries the second tactic.
    *)
   let orelse tac1 tac2 (_, args) seq =
      try tac1 (seq, args) seq with
         RefineError x ->
            (try tac2 (seq, args) seq with
                RefineError y ->
                   raise (RefineError (PairError ("orelse", x, y))))
   
   (*
    * ANDTHEN: do tac1, then
    * do tac2 on all the subgoals,
    * passing the subgoal index.
    *)
   let andthen tac1 tac2 (_, args) seq =
      let subgoals, just =
         try tac1 (seq, args) seq with
            RefineError x ->
               raise (RefineError (GoalError ("andthen", x)))
      in
      let rec aux i = function
         ((subgoal, args') as h)::sgtl ->
            let subgoals', just' =
               try tac2 h subgoal with
                  RefineError x ->
                     raise (RefineError (SubgoalError ("andthen", i, x)))
            in
            let subgoals'', justs = aux (i + 1) sgtl in
               subgoals' @ subgoals'', just'::justs
       | [] ->
            [], []
      in
      let subgoals', justs = aux 0 subgoals in
         subgoals', ComposeJust (just, justs)
         
   (*
    * ANDTHENL.
    * Do tac1, then apply the list of tactics to the subgoals
    * in order.  Fail if the list lengths don't match.
    *)
   let andthenL tac1 tac2list (_, args) seq =
      let rec thenlist i = function
         tac::tactl, ((subgoal, args') as h)::sgtl ->
            let subgoals, just =
               try tac h subgoal with
                  RefineError x ->
                     raise (RefineError (SubgoalError ("andthenL", i, x)))
            in
            let subgoals', justs = thenlist (i + 1) (tactl, sgtl) in
               subgoals @ subgoals', just::justs
       | [], [] ->
            [], []
       | _ ->
            raise (RefineError (StringError "andthenL: argument mismatch"))
      in
      let subgoals, just =
         try tac1 (seq, args) seq with
            RefineError x ->
               raise (RefineError (GoalError ("andthenL", x)))
      in
      let subgoals', justs = thenlist 0 (tac2list, subgoals) in
         subgoals', ComposeJust (just, justs)
   
   (*
    * ANDTHENFL.
    * Do tac1, then apply the second tactic function to the
    * subgoal list.
    *)
   let andthenFL tac f (_, args) seq =
      let rec apply_list i = function
         stac::stactl, (subgoal, _)::sgtl ->
            let subgoals, just =
               try stac subgoal with
                  RefineError x ->
                     raise (RefineError (SubgoalError ("andthenFL", i, x)))
            in
            let subgoals', justs = apply_list (i + 1) (stactl, sgtl) in
               subgoals @ subgoals', just::justs
       | [], [] -> [], []
       | _ -> raise (RefineError (StringError "andthenFL: argument mismatch"))
      in
      let subgoals, just =
         try tac (seq, args) seq with
            RefineError x ->
               raise (RefineError (GoalError ("andthenFL", x)))
      in
      let stacs =
         try f subgoals with
            RefineError x ->
               raise (RefineError (SubgoalError ("andthenFL", 0, x)))
      in
      let subgoals', justs' = apply_list 0 (stacs, subgoals) in
         subgoals', ComposeJust (just, justs')
   
   (************************************************************************
    * REGULAR REWRITES                                                     *
    ************************************************************************)
   
   (*
    * Convert a rewrite to a tactic.
    *)
   let rwtactic rw (_, args) seq =
      let arg, refiner = rw (seq, args) seq in
         [arg], SingleJust { ext_names = [||]; ext_params = []; ext_refiner = refiner }
   
   (*
    * Apply a rewrite at an address. We use an imperative operation to
    * capture the refiner.  This could be performed functionally, but it
    * would require two applications of the rewrite (one to compute
    * the refiner, and one to compute the result term).
    *)
   let rwaddr addr rw (_, args) t =
      let rval = ref None in
      let rw' t =
         let (t', args'), refiner' = rw (t, args) t in
            rval := Some (args', refiner');
            t'
      in
      let t' =
         try apply_fun_at_addr rw' addr t with
            RefineError x ->
               raise (RefineError (RewriteAddressError ("rwaddr", addr, x)))
      in
         match !rval with
            Some (args', refiner') ->
               (t', args'), refiner'
          | None ->
               raise (RefineError (StringError "rwaddr: address out of range"))
   
   (*
    * Compose two rewrites.
    *)
   let andthenrw rw1 rw2 (_, args) t =
      let ((t', args') as arg), refiner =
         try rw1 (t, args) t with
            RefineError x ->
               raise (RefineError (GoalError ("andthenrw", x)))
      in
      let t'', refiner' =
         try rw2 arg t' with
            RefineError x ->
               raise (RefineError (SecondError ("andthenrw", x)))
      in
         t'', PairRefiner (refiner, refiner')
   
   (************************************************************************
    * CONDITIONAL REWRITES                                                 *
    ************************************************************************)
   
   (*
    * Inject a regular rewrite as a conditional rewrite.
    *)
   let mk_cond_rewrite rw (_, _, args) seq t =
      let arg, refiner = rw (t, args) t in
         arg, [], SingleJust { ext_names = [||]; ext_params = []; ext_refiner = refiner }
   
   (*
    * Apply the rewrite to an addressed term.
    *)
   let crwaddr addr rw (_, _, args) seq t =
      let tmp = ref None in
      let rw' t =
         let (t', args'), subgoals, just = rw (seq, t, args) seq t in
            tmp := Some (args', subgoals, just);
            t'
      in
      let t' =
         try apply_fun_at_addr rw' addr t with
            RefineError x ->
               raise (RefineError (RewriteAddressError ("crwaddr", addr, x)))
      in
         match !tmp with
            Some (args', subgoals, just) ->
               (t', args'), subgoals, just
          | None ->
               raise (RefineError (StringError "crwaddr: tactic never applied"))
   
   (*
    * Apply a conditional rewrite.
    *)
   let crwtactic rw (_, args) seq =
      let t', subgoals, just = rw (seq, seq, args) seq seq in
      let subgoals' = t'::subgoals in
         subgoals', just
   
   (*
    * Apply the rewrite, given the args.
    *)
   let apply_crw rw args seq t =
      let srw, args' = rw (seq, t, args) in
      let t', subgoals, just = srw seq t in
         t', subgoals, just, args'
   
   (*
    * Compose conditional rewrites.
    *)
   let candthenrw rw1 rw2 (_, _, args) seq t =
      let (t', args'), subgoals, just =
         try rw1 (seq, t, args) seq t with
            RefineError x ->
               raise (RefineError (GoalError ("candthenrw", x)))
      in
      let t'', subgoals', just' =
         try rw2 (seq, t', args') seq t' with
            RefineError x ->
               raise (RefineError (SecondError ("candthenrw", x)))
      in
         t'', subgoals @ subgoals', PairJust (just, just')
   
   (************************************************************************
    * REFINER CONSTRUCTION                                                 *
    ************************************************************************)
   
   (*
    * Empty refiner.
    *)
   let null_refiner = NullRefiner
   
   (*
    * Combine the refiners into a single refiner.
    * We will eventually have to worry about joining common
    * ancestors.
    *)
   let join_refiner ref1 ref2 =
      ref1 := PairRefiner (ref2, !ref1)
   
   (*
    * Label a refiner with the name of the module.
    *)
   let label_refiner ref1 name =
      ref1 := LabelRefiner (name, !ref1)
   
   (*
    * Search for an axiom by name.
    *)
   let find_refiner refiner name =
      let rec aux = function
         NullRefiner -> raise Not_found
       | AxiomRefiner { axiom_name = n; axiom_refiner = r' } as r ->
            if n = name then
               r
            else
               aux r'
       | RuleRefiner { rule_name = n; rule_refiner = r' } as r ->
            if n = name then
               r
            else
               aux r'
       | RewriteRefiner { rw_name = n; rw_refiner = r' } as r ->
            if n = name then
               r
            else
               aux r'
       | CondRewriteRefiner { crw_name = n; crw_refiner = r' } as r ->
            if n = name then
               r
            else
               aux r'
       | PrimRewriteRefiner { prw_refiner = r' } ->
            aux r'
       | MLRewriteRefiner { ml_rw_name = n; ml_rw_refiner = r' } as r ->
            if n = name then
               raise (BadTheorem (n, r))
            else
               aux r'
       | MLRuleRefiner { ml_rule_name = n; ml_rule_refiner = r' } as r ->
            if n = name then
               raise (BadTheorem (n, r))
            else
               aux r'
       | MLConditionRefiner { ml_cond_refiner = r' } ->
            aux r'
       | PrimTheoremRefiner { pthm_refiner = r' } ->
            aux r'
       | LabelRefiner (_, r') ->
            aux r'
       | PairRefiner (r1, r2) ->
            try aux r1 with
               _ -> aux r2
      in
         aux refiner
   
   (*
    * Get the term from an extract.
    * This will fail if some of the rules are not justified.
   let term_of_extract { ext_just = just } =
      let rec construct = function
         SingleJust { ext_names = names; ext_params = params; ext_refiner = refiner } ->
            begin
               match refiner with
    *)
   
   (*
    * An theorem is a special case of a rule, where to
    * arity is 1, and there are no addrs or params.
    * Still get a tactic by this name (the equivalent
    * of BackThruLemma `name`).
    *)
   let check_axiom term =
      match Term.context_vars term with
         [] ->
            true
       | l ->
            raise (FreeContextVars l)
   
   let add_axiom refiner name term =
      if debug_refiner then
         eprintf "Refiner.add_axiom: %s%t" name eflush;
      let refiner' = AxiomRefiner { axiom_name = name;
                                    axiom_term = term;
                                    axiom_refiner = refiner
                                  }
      in
      let tac _ t =
         if alpha_equal (nth_concl t 0) term then
            [], SingleJust { ext_names = [||]; ext_params = []; ext_refiner = refiner' }
         else
            raise (Term.TermMatch ("add_axiom_refine", t, ""))
      in
         check_axiom term;
         refiner', tac
   
   (*
    * Create a rule from a meta-term.
    * For now, we just allow first-order rules (T -> ... -> T)
    * where each T must be a term, and the arity is arbitrary,
    * and there are no dependencies.
    *)
   let add_rule refiner name addrs names params mterm =
      if debug_refiner then
         eprintf "Refiner.add_rule: %s%t" name eflush;
      let terms = unzip_mimplies mterm in
      let subgoals, goal = List_util.split_last terms in
      let rw =
         try Rewrite.term_rewrite (addrs, names) (goal::params) subgoals with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
      let refiner' = RuleRefiner { rule_name = name;
                                   rule_rule = mterm;
                                   rule_refiner = refiner
                                 }
      in
      let tac addrs_names params t =
         let subgoals, names' =
            try Rewrite.apply_rewrite rw addrs_names (t::params) with
               Rewrite.RewriteError error ->
                  raise (RefineError (RewriteError (name, error)))
         in
         let just = SingleJust { ext_names = names';
                                 ext_params = params;
                                 ext_refiner = refiner
                               }
         in
            subgoals, just
      in
         refiner', tac
   
   (*
    * Create a tactic from the rule.
    *)
   let tactic_of_rule (tac : prim_tactic) addrs_names params (_, args) t =
      let subgoals, just = tac addrs_names params t in
         List.map (function t -> (t, args)) subgoals, just
   
   (*
    * Just do the checking.
    *)
   let check_rule name addrs names params mterm =
      let terms = unzip_mimplies mterm in
      let subgoals, goal = List_util.split_last terms in
      let rw =
         try Rewrite.term_rewrite (addrs, names) (goal::params) subgoals with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
         true
   
   (*
    * Create a simple rewrite from a meta-term.
    * The rewrite must be a MetaIff.
    *)
   let add_rewrite refiner name redex contractum =
      if debug_refiner then
         eprintf "Refiner.add_rewrite: %s%t" name eflush;
      let rw =
         try Rewrite.term_rewrite ([||], [||]) [redex] [contractum] with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
      let refiner' = RewriteRefiner { rw_name = name;
                                      rw_rewrite = redex, contractum;
                                      rw_refiner = refiner
                                    }
      in
      let null_message = name ^ ": rewrite produced no contractum" in
      let mul_message = name ^ ": rewrite produced multiple contracta" in
      let rw t =
         match
            try Rewrite.apply_rewrite rw ([||], [||]) [t] with
               Rewrite.RewriteError error ->
                  raise (RefineError (RewriteError (name, error)))
         with
            [t'], _ -> t', refiner'
          | [], _ -> failwith null_message
          | _ -> failwith mul_message
      in
         refiner', rw
   
   let rewrite_of_rewrite (rw : prim_rewrite) (_, args) t =
      let t', refiner = rw t in
         (t', args), refiner
   
   (*
    * Conditional rewrite.
    *)
   let add_cond_rewrite refiner name vars params subgoals redex contractum =
      if debug_refiner then
         eprintf "Refiner.add_cond_rewrite: %s%t" name eflush;
      let rw =
         try Rewrite.term_rewrite ([||], vars) (redex::params) [contractum] with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
      let refiner' = CondRewriteRefiner { crw_name = name;
                                          crw_rewrite = subgoals, redex, contractum;
                                          crw_refiner = refiner
                                        }
      in
      let null_message = name ^ ": rewrite produced no contractum" in
      let mul_message = name ^ ": rewrite produced multiple contracta" in
      let rw' (vars, params) seq t =
         let subgoals' = mk_seq_subgoals seq subgoals in
            match
               try Rewrite.apply_rewrite rw ([||], vars) (t :: params) with
                  Rewrite.RewriteError error ->
                     raise (RefineError (RewriteError (name, error)))
            with
               [t'], names ->
                  t',
                  subgoals',
                  SingleJust { ext_names = names;
                               ext_params = params;
                               ext_refiner = refiner'
                             }
             | [], _ -> failwith null_message
             | _ -> failwith mul_message
      in
         refiner', rw'
   
   let rewrite_of_cond_rewrite (rw : prim_cond_rewrite) vars_params (_, _, args) seq t =
      let t', subgoals', just = rw vars_params seq t in
         (t', args), List.map (function t -> (t, args)) subgoals', just
   
   (*
    * Theorem for a previous rewrite.
    *)
   let add_prim_rewrite refiner name redex contractum =
      if debug_refiner then
         eprintf "Refiner.add_prim_rewrite: %s%t" name eflush;
      let rw = find_refiner refiner name in
         match rw with
            RewriteRefiner { rw_rewrite = redex', contractum' } ->
               let term1 = mk_xlist_term [redex; contractum] in
               let term2 = mk_xlist_term [redex'; contractum'] in
                  if alpha_equal term1 term2 then
                     PrimRewriteRefiner { prw_rewrite = rw; prw_refiner = refiner }
                  else
                     raise (BadTheorem (name, rw))
          | _ -> raise (BadTheorem (name, rw))
   
   (*
    * In this theorem, we ignore the vars and params.
    *)
   let add_prim_cond_rewrite refiner name vars params subgoals redex contractum =
      if debug_refiner then
         eprintf "Refiner.add_prim_cond_rewrite: %s%t" name eflush;
      let rw = find_refiner refiner name in
         match rw with
            CondRewriteRefiner { crw_rewrite = subgoals', redex', contractum' } ->
               let term1 = mk_xlist_term (redex :: contractum :: subgoals) in
               let term2 = mk_xlist_term (redex' ::  contractum' :: subgoals') in
                  if alpha_equal term1 term2 then
                     PrimRewriteRefiner { prw_rewrite = rw; prw_refiner = refiner }
                  else
                     raise (BadTheorem (name, rw))
          | _ -> raise (BadTheorem (name, rw))
   
   let check_rewrite name vars params subgoals redex contractum =
      let rw =
         try Rewrite.term_rewrite ([||], vars) (redex::params) [contractum] with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
         true
   
(*
   (*
    * An ML rewrite.
    *)
   let add_ml_rewrite refiner name subgoals rw =
      let refiner' = MLRewriteRefiner { ml_rw_name = name;
                                        ml_rw_rewrite = rw;
                                        ml_rw_refiner = refiner
                                      }
      in
      let rw' ((vars, params) as args) (_, _, args') seq t =
         let subgoals' = mk_seq_subgoals seq subgoals in
         let t' = rw args t in
         let just = SingleJust { ext_names = vars;
                                 ext_params = params;
                                 ext_refiner = refiner'
                               }
         in
            (t', args'),
            (List.map (function x -> x, args') subgoals'),
            just
      in
         refiner', rw'
*)
   
   (*
    * An ML condition.
    *)
   let add_ml_condition refiner arg cond =
      let refiner' = MLConditionRefiner { ml_cond_arg = arg;
                                          ml_cond_refiner = refiner
                                        }
      in
         refiner', cond
   
(*
   (*
    * An ML procedure.
    *)
   let add_ml_rule refiner name rule =
      let refiner' = MLRuleRefiner { ml_rule_name = name;
                                     ml_rule_rule = rule;
                                     ml_rule_refiner = refiner
                                   }
      in
      let just = SingleJust { ext_names = [||]; ext_params = []; ext_refiner = refiner' } in
      let tac (_, args) t = List.map (function x -> x, args) (rule t), just in
         refiner', tac
*)
   
   (*
    * Theorem for a previous theorem or rule.
    * We once again use the rewriter to compute the
    * extract.  The subextracts are shaped into a
    * term of the form:
    *    lambda(a. lambda(b. ... cons(arg1; cons(arg2; ... cons(argn, nil)))))
    *)
   let add_prim_theorem refiner name vars params args result =
      if debug_refiner then
         eprintf "Refiner.add_prim_theorem: %s%t" name eflush;
      (* Special case for trivial theorems *)
      let axiom = find_refiner refiner name in
         if vars = [||] & params = [] & args = [] then
            PrimTheoremRefiner { pthm_proof = (fun _ _ _ -> result);
                                 pthm_axiom = axiom;
                                 pthm_refiner = refiner
                               }
         else
            (* Create redex term *)
            let l = Array.length vars in
            let create_redex vars args =
               let args' = mk_xlist_term args in
               let rec aux j =
                  if j < l then
                     mk_xlambda_term vars.(j) (aux (j + 1))
                  else
                     args'
               in
                  aux 0
            in
            let rw =
               try Rewrite.term_rewrite ([||], [||]) ((create_redex vars args)::params) [result] with
                  Rewrite.RewriteError error ->
                     raise (RefineError (RewriteError (name, error)))
            in
            let compute_ext vars params args =
               match
                  try Rewrite.apply_rewrite rw ([||], [||]) ((create_redex vars args)::params) with
                     Rewrite.RewriteError error ->
                        raise (RefineError (RewriteError (name, error)))
               with
                  [c], x when Array.length x = 0 -> c
                | _ -> failwith "compute_ext: faulty extract"
            in
               PrimTheoremRefiner { pthm_proof = compute_ext;
                                    pthm_axiom = axiom;
                                    pthm_refiner = refiner
                                  }
   
   let check_theorem name vars params args result =
      (* Create redex term *)
      let l = Array.length vars in
      let create_redex vars args =
         let args' = mk_xlist_term args in
         let rec aux j =
            if j < l then
               mk_xlambda_term vars.(j) (aux (j + 1))
            else
               args'
         in
            aux 0
      in
      let rw =
         try Rewrite.term_rewrite ([||], [||]) ((create_redex vars args)::params) [result] with
            Rewrite.RewriteError error ->
               raise (RefineError (RewriteError (name, error)))
      in
         true
   
   (*
    * Creation functions.
    *)
   let create_axiom refiner name term =
      let refiner', tac = add_axiom !refiner name term in
         refiner := refiner';
         tac
   
   let create_rule refiner name addrs names params mterm =
      let refiner', tac = add_rule !refiner name addrs names params mterm in
         refiner := refiner';
         tac
   
   let create_rewrite refiner name redex contractum =
      let refiner', rw = add_rewrite !refiner name redex contractum in
         refiner := refiner';
         rw
   
   let create_cond_rewrite refiner name vars params args redex contractum =
      let refiner', rw = add_cond_rewrite !refiner name vars params args redex contractum in
         refiner := refiner';
         rw
   
   let prim_rewrite refiner name redex contractum =
      refiner := add_prim_rewrite !refiner name redex contractum
   
   let prim_cond_rewrite refiner name vars params args redex contractum =
      refiner := add_prim_cond_rewrite !refiner name vars params args redex contractum
   
(*
   let create_ml_rule refiner name rule =
      let refiner', tac = add_ml_rule !refiner name rule in
         refiner := refiner';
         tac
   
   let create_ml_rewrite refiner name subgoals rw =
      let refiner', rw' = add_ml_rewrite !refiner name subgoals rw in
         refiner := refiner';
         rw'
*)
   
   let create_ml_condition refiner term cond =
      let refiner', cond' = add_ml_condition !refiner term cond in
         refiner := refiner';
         cond'
   
   let prim_theorem refiner name vars params args result =
      let refiner' = add_prim_theorem !refiner name vars params args result in
         refiner := refiner'
   
   (************************************************************************
    * DESTRUCTORS                                                          *
    ************************************************************************)
   
   (*
    * Null refiners.
    *)
   let is_null_refiner = function
      NullRefiner -> true
    | _ -> false
   
   (*
    * Get the next item from a refiner.
    *)
   let dest_refiner = function
      NullRefiner ->
         raise (Invalid_argument "dest_refiner")
    | AxiomRefiner { axiom_name = n; axiom_term = t; axiom_refiner = r } ->
         RIAxiom { ri_axiom_name = n; ri_axiom_term = t }, r
    | RuleRefiner { rule_name = n; rule_rule = t; rule_refiner = r } ->
         RIRule { ri_rule_name = n; ri_rule_rule = t }, r
    | RewriteRefiner { rw_name = n; rw_rewrite = redex, con; rw_refiner = r } ->
         RIRewrite { ri_rw_name = n;
                     ri_rw_redex = redex;
                     ri_rw_contractum = con
                   },
         r
    | CondRewriteRefiner { crw_name = n; crw_rewrite = conds, redex, con; crw_refiner = r } ->
         RICondRewrite { ri_crw_name = n;
                         ri_crw_conds = conds;
                         ri_crw_redex = redex;
                         ri_crw_contractum = con
                       },
         r
    | PrimRewriteRefiner { prw_rewrite = r1; prw_refiner = r2 } ->
         RIPrimRewrite { ri_prw_rewrite = r1 }, r2
    | MLRewriteRefiner { ml_rw_name = n; ml_rw_refiner = r } ->
         RIMLRewrite { ri_ml_rw_name = n }, r
    | MLRuleRefiner { ml_rule_name = n; ml_rule_refiner = r } ->
         RIMLRule { ri_ml_rule_name = n }, r
    | MLConditionRefiner { ml_cond_arg = cond; ml_cond_refiner = r } ->
         RIMLCondition { ri_ml_cond_arg = cond }, r
    | PrimTheoremRefiner { pthm_axiom = axiom; pthm_refiner = r } ->
         RIPrimTheorem { ri_pthm_axiom = axiom }, r
    | PairRefiner (par, r) ->
         RIParent par, r
    | LabelRefiner (name, r) ->
         RILabel name, r
end

(*
 * $Log$
 * Revision 1.4  1998/04/17 20:48:39  jyh
 * Updating refiner for extraction.
 *
 * Revision 1.3  1997/08/07 19:43:45  jyh
 * Updated and added Lori's term modifications.
 * Need to update all pattern matchings.
 *
 * Revision 1.2  1997/08/06 16:18:12  jyh
 * This is an ocaml version with subtyping, type inference,
 * d and eqcd tactics.  It is a basic system, but not debugged.
 *
 * Revision 1.1  1997/04/28 15:51:30  jyh
 * This is the initial checkin of Nuprl-Light.
 * I am porting the editor, so it is not included
 * in this checkin.
 *
 * Directories:
 *     refiner: logic engine
 *     filter: front end to the Ocaml compiler
 *     editor: Emacs proof editor
 *     util: utilities
 *     mk: Makefile templates
 *
 * Revision 1.17  1996/09/25 22:52:00  jyh
 * Initial "tactical" commit.
 *
 * Revision 1.16  1996/05/21 02:14:04  jyh
 * This is a semi-working version before Wisconsin vacation.
 *
 * Revision 1.15  1996/04/07 18:24:49  jyh
 * This is an intermediate commit while adjusting the dforms.
 * We intend that dform printers just return a list of terms.
 *
 * Revision 1.14  1996/03/25 20:50:43  jyh
 * Intermediate commit while modifying grammer.  Restricting
 * ML hooks to condition terms.
 *
 * Revision 1.13  1996/03/11 18:34:23  jyh
 * The filterModule module is untested, but it seems to work
 * correctly on most inputs, except for mlbegin ... mlend expressions.
 * That's the next task.
 *
 * Revision 1.12  1996/03/08 15:40:48  jyh
 * This version works for most constructs except for ML rewrites.
 * The next step will be to break apart the rewriter so that
 * redices and contracta can be compiled separately.
 *
 * Revision 1.11  1996/03/05 19:48:34  jyh
 * Preliminary version with logical framework.
 *
 * Revision 1.10  1996/02/25 15:16:17  jyh
 * This is a partial checkin as filterModule is being developed.
 * After the meta-logical framework is developed, sequent.* will go away.
 *
 * Revision 1.9  1996/02/18 23:32:31  jyh
 * Changin Format module to more Nuprl-like format.
 *
 * Revision 1.8  1996/02/14 03:51:51  jyh
 * This is a version common to Caml-Light and Caml-Special-Light.
 *
 * Revision 1.7  1996/02/13 21:32:28  jyh
 * This is an intermediate checkin while matching is being added to the rewriter.
 *
 * Revision 1.6  1996/02/10 20:19:55  jyh
 * Initial checkin of filter (prlcomp).
 *
 * Revision 1.5  1996/02/08 16:02:30  jyh
 * Adding type Theory.
 *
 * Revision 1.4  1996/02/07 23:41:15  jyh
 * First working version in CamlSpecialLight.
 *
 * Revision 1.3  1996/02/07 17:34:08  jyh
 * This is Version 0 of the refiner in Caml-Light.  At this point,
 * Caml-Light becomes a branch, and main development will be
 * in Caml-Special-Light.
 *
 * Revision 1.2  1996/02/05 18:14:53  jyh
 * Merge context rewrites onto the main branch.
 *
 * Revision 1.1.4.1  1996/02/05 06:09:53  jyh
 * This version has the rewriter with contexts, and Rule application
 * in Sequent.ml, but it is not fully debugged.
 *
 * Revision 1.1  1996/01/31 20:02:39  jyh
 * Generalizing rewriter to work on Sequents.
 *
 * -*-
 * Local Variables:
 * Caml-master: "refiner.run"
 * End:
 * -*-
 *)
