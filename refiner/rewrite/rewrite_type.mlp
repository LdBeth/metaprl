(*
 * The rewriter compiles redices into a stack of terms
 * that is used to collect values when the redex is matched.
 *)

open Opname
open Term_sig
open Term_addr_sig

module MakeRewriteTypes (TermType : TermSig)
   (TermAddr : TermAddrSig
    with type term = TermType.term) =
struct
   type level_exp = TermType.level_exp
   type object_id = TermType.object_id
   type term = TermType.term
   type address = TermAddr.address
   type seq_hyps = TermType.seq_hyps

   (*
    * We need to define a term for matching rewrite rules.
    * This is similar to a DeBruijn term, but it includes second
    * order variables.
    *)
   type rwparam =
      RWNumber of Nl_num.num
    | RWString of string
    | RWToken of string
    | RWLevel of level_exp
    | RWVar of string
    | RWMNumber of int
    | RWMString of int
    | RWMToken of int
    | RWMLevel of int
    | RWMVar of int
    | RWSum of rwparam * rwparam
    | RWDiff of rwparam * rwparam
    | RWProduct of rwparam * rwparam
    | RWQuotient of rwparam * rwparam
    | RWRem of rwparam * rwparam
    | RWLessThan of rwparam * rwparam
    | RWEqual of rwparam * rwparam
    | RWNotEqual of rwparam * rwparam
    | RWObId of object_id
    | RWParamList of rwparam list
   and rwoperator = { rw_name : opname; rw_params : rwparam list }

   (*
    * These are the types of terms.
    * In a redex:
    *    RWComposite matches a term with a given pattern
    *    RWSOVar matches any term
    *    RWSOContext matches a second order context with an addressed subterm
    *    RWCheckVar matches the specific bound variable
    * In a contractum:
    *    RWComposite construct a term with the given pattern
    *    RWSOMatch matches an instantiated second order variable
    *    RWSOSubst instantiates a second order variable
    *    RWSOContextSubst instantiates a second order context
    *    RWCheckVar instantiates a bound variable
    *)
   and rwterm =
      RWComposite of rwcterm
    | RWSequent of rwterm * rw_seq_term list * rwterm list
    | RWSOVar of int * int list
    | RWSOMatch of int * (int list * string list * term list)
    | RWSOSubst of int * rwterm list
    | RWSOContext of int * int * rwterm * int list
    | RWSOContextSubst of int * rwterm * rwterm list
    | RWCheckVar of int
    | RWStackVar of int
    | RWError

   (* Match a specific term *)
   and rwcterm = { rw_op : rwoperator; rw_bterms : rw_bound_term list }

   (*
    * In the bound term, rw_bnames is used in the contractum
    * for suggesting names for the bound variables.
    *)
   and rw_bound_term = { rw_bvars : int; rw_bnames : varname list; rw_bterm : rwterm }

   (*
    * Special forms for sequents.
    *)
   and rw_seq_term =
      RWSeqHyp of varname * rwterm
    | RWSeqContext of int * int * int list
    | RWSeqContextSubst of int * rwterm list

   and varname =
      StackName of int
    | ArgName of int
    | SaveName of int

   (*
    * We keep arrays of hyps.
    *)
   type hyp_array = int * int * seq_hyps

   (*
    * During redex compilation, we keep track of
    * second order variables and binding variables.
    * We keep the so arg length for checking.
    *)
   type rstack =
      FOVarPattern of string
    | SOVarPattern of string * int
    | SOVarInstance of string * int
    | FOVar of string
    | CVar of string
    | PIVar of string
    | PSVar of string
    | PLVar of string

   (*
    * During reduction, we keep a stack of objects of all the
    * possible types.
    *)
   type stack =
      StackVoid
    | StackNumber of Nl_num.num
    | StackString of string
    | StackMString of string
    | StackLevel of level_exp
    | StackBTerm of term * string list
    | StackITerm of (term * string list * string list * term list) list
    | StackContext of string list * term * address
    | StackSeqContext of string list * hyp_array

   type rewrite_stack = stack array

   (*
    * A contractum can be a term to be instantiated,
    * or it can be a function to be called.
    *)
   type rwcontractum =
      RWCTerm of rwterm list * string array
    | RWCFunction of (term -> term)

   (*
    * The rewrite rule contains an rwterm for matching a redex,
    * and another for constructing the contractum.
    *)
   type rewrite_rule =
      {  (* Redex, and matching stack *)
         rr_redex : rwterm list;
         rr_gstacksize : int;

         (* The contractum is a term or a function *)
         rr_contractum : rwcontractum;

         (* After a reduction, the namer function extracts variable names *)
         rr_namer : stack array -> string array -> string array
      }

   (*
    * Separated formas.
    *)
   type rewrite_redex =
      { redex_stack : rstack array;
        redex_redex : rwterm list
      }

   type rewrite_contractum =
      { con_contractum : rwterm;
        con_new_vars : string array
      }

   (*
    * Types for redex matching.
    *)
   type rewrite_type =
      RewriteTermType of string
    | RewriteFunType of string
    | RewriteContextType of string
    | RewriteStringType of string
    | RewriteIntType of string
    | RewriteLevelType of string

   type rewrite_item =
      RewriteTerm of term
    | RewriteFun of (term list -> term)
    | RewriteContext of (term -> term list -> term)
    | RewriteString of string
    | RewriteInt of int
    | RewriteLevel of level_exp
end

(*
 * -*-
 * Local Variables:
 * Caml-master: "refiner"
 * End:
 * -*-
 *)
