(*
 * This module specifies rewrite rules, which require second
 * order variables.  Each rule has a "redex" and a "contractum",
 * although rewrites can be performed in either direction.
 *
 *)

#include "refine_error.h"

open Printf
open Debug
open Opname
open Term_sig
open Term_base_sig
open Term_man_sig
open Term_addr_sig
open Term_subst_sig
open Term_meta_sig
open Refine_error_sig

open Term_ds (* for debug_subst *)

(*
 * Show the file loading.
 *)
let _ =
   if !debug_load then
      eprintf "Loading Rewrite%t" eflush

let debug_rewrite =
   create_debug (**)
      { debug_name = "rewrite";
        debug_description = "Show term rewriting operations";
        debug_value = false
      }

let debug_subst =
   create_debug (**)
      { debug_name = "subst";
        debug_description = "Show substitution operations";
        debug_value = false
      }

(*
 * Rewrite module.
 *)
module Rewrite (**)
   (TermType : TermSig)
   (Term : TermBaseSig
    with type term = TermType.term
    with type term' = TermType.term'
    with type bound_term = TermType.bound_term
    with type bound_term' = TermType.bound_term'
    with type operator = TermType.operator
    with type operator' = TermType.operator'
    with type param = TermType.param
    with type param' = TermType.param'
    with type level_exp = TermType.level_exp
    with type level_exp' = TermType.level_exp'
    with type object_id = TermType.object_id)
   (TermMan : TermManSig
    with type term = TermType.term)
   (TermAddr : TermAddrSig
    with type term = TermType.term)
   (TermSubst : TermSubstSig
    with type term = TermType.term)
   (RefineError : RefineErrorSig
    with type level_exp = TermType.level_exp
    with type param = TermType.param
    with type term = TermType.term
    with type bound_term = TermType.bound_term)
=
struct
   open TermType
   open Term
   open TermMan
   open TermAddr
   open TermSubst
   open RefineError

   type term = Term.term
   type level_exp = Term.level_exp
   type operator = Term.operator
   type address = TermAddr.address

   (************************************************************************
    * Rewrites
    ************************************************************************)

   (*
    * We need to define a term for matching rewrite rules.
    * This is similar to a DeBruijn term, but it includes second
    * order variables.
    *)
   type rwparam =
      RWNumber of Num.num
    | RWString of string
    | RWToken of string
    | RWLevel of level_exp
    | RWVar of string
    | RWMNumber of int
    | RWMString of int
    | RWMToken of int
    | RWMLevel of int
    | RWMVar of int
    | RWSum of rwparam * rwparam
    | RWDiff of rwparam * rwparam
    | RWProduct of rwparam * rwparam
    | RWQuotient of rwparam * rwparam
    | RWRem of rwparam * rwparam
    | RWLessThan of rwparam * rwparam
    | RWEqual of rwparam * rwparam
    | RWNotEqual of rwparam * rwparam
    | RWObId of object_id
    | RWParamList of rwparam list
   and rwoperator = { rw_name : opname; rw_params : rwparam list }

   (*
    * These are the types of terms.
    * In a redex:
    *    RWComposite matches a term with a given pattern
    *    RWSOVar matches any term
    *    RWSOContext matches a second order context with an addressed subterm
    *    RWCheckVar matches the specific bound variable
    * In a contractum:
    *    RWComposite construct a term with the given pattern
    *    RWSOMatch matches an instantiated second order variable
    *    RWSOSubst instantiates a second order variable
    *    RWSOContextSubst instantiates a second order context
    *    RWCheckVar instantiates a bound variable
    *)
   and rwterm =
      RWComposite of rwcterm
    | RWSOVar of int * int list
    | RWSOMatch of int * (int list * string list * term list)
    | RWSOSubst of int * rwterm list
    | RWSOContext of int * int * rwterm * int list
    | RWSOContextSubst of int * rwterm * rwterm list
    | RWCheckVar of int
    | RWStackVar of int
    | RWError

   (* Match a specific term *)
   and rwcterm = { rw_op : rwoperator; rw_bterms : rwboundTerm list }

   (*
    * In the bound term, rw_bnames is used in the contractum
    * for suggesting names for the bound variables.
    *)
   and rwboundTerm = { rw_bvars : int; rw_bnames : varname list; rw_bterm : rwterm }

   and varname =
      StackName of int
    | ArgName of int
    | SaveName of string

   (*
    * During redex compilation, we keep track of
    * second order variables and binding variables.
    * We keep the so arg length for checking.
    *)
   type rstack =
      FOVarPattern of string
    | SOVarPattern of string * int
    | SOVarInstance of string * int
    | FOVar of string
    | CVar of string
    | PIVar of string
    | PSVar of string
    | PLVar of string

   (*
    * During reduction, we keep a stack of objects of all the
    * possible types.
    *)
   type stack =
      StackVoid
    | StackNumber of Num.num
    | StackString of string
    | StackLevel of level_exp
    | StackBTerm of term * string list
    | StackITerm of (term * string list * string list * term list) list
    | StackContext of string list * term * address

   type rewrite_stack = stack array

   (*
    * A contractum can be a term to be instantiated,
    * or it can be a function to be called.
    *)
   type rwcontractum =
      RWCTerm of rwterm list
    | RWCFunction of (term -> term)

   (*
    * The rewrite rule contains an rwterm for matching a redex,
    * and another for constructing the contractum.
    *)
   type rewrite_rule =
      {  (* Redex, and matching stack *)
         rr_redex : rwterm list;
         rr_gstacksize : int;

         (* The contractum is a term or a function *)
         rr_contractum : rwcontractum;

         (* After a reduction, the namer function extracts variable names *)
         rr_namer : stack array -> string array -> string array
      }

   (*
    * Separated formas.
    *)
   type rewrite_redex =
      { redex_stack : rstack array;
        redex_redex : rwterm list
      }

   type rewrite_contractum =
      { con_contractum : rwterm }

   (*
    * Types for redex matching.
    *)
   type rewrite_type =
      RewriteTermType of string
    | RewriteFunType of string
    | RewriteContextType of string
    | RewriteStringType of string
    | RewriteIntType of string
    | RewriteLevelType of string

   type rewrite_item =
      RewriteTerm of term
    | RewriteFun of (term list -> term)
    | RewriteContext of (term -> term list -> term)
    | RewriteString of string
    | RewriteInt of int
    | RewriteLevel of level_exp

   (************************************************************************
    * UTILITIES                                                            *
    ************************************************************************)

   (*
    * Upgrade a second-order instance to a pattern
    *)
   let rec rstack_upgrade v = function
      (SOVarInstance (v', i))::t when v' = v ->
         (SOVarPattern (v, i))::t
    | ((SOVarPattern (v', _))::t as stack) when v' = v ->
         stack
    | (FOVarPattern v')::t when v' = v ->
         (SOVarPattern (v, 0))::t
    | h::t ->
         h::(rstack_upgrade v t)
    | [] ->
         raise (Invalid_argument "rstack_upgrade")

   (*
    * Check the arity of a variable.
    *)
   let rec rstack_check_arity v arity = function
      [] ->
         raise (Failure "Rewrite.rstack_check_arity")
    | h::t ->
         match h with
            FOVarPattern v' ->
               if v' = v then
                  if arity = 0 then
                     ()
                  else
                     ref_raise(RefineError ("rstack_check_arity", RewriteSOVarArity v))
               else
                  rstack_check_arity v arity t
          | SOVarPattern (v', i) ->
               if v' = v then
                  if i = arity then
                     ()
                  else
                     ref_raise(RefineError ("rstack_check_arity", RewriteSOVarArity v))
               else
                  rstack_check_arity v arity t
          | SOVarInstance (v', i) ->
               if v' = v then
                  if i = arity then
                     ()
                  else
                     ref_raise(RefineError ("rstack_check_arity", RewriteSOVarArity v))
               else
                  rstack_check_arity v arity t
          | _ ->
               rstack_check_arity v arity t

   (*
    * Membership functions.
    *)
   let rstack_mem_prop v = function
      FOVarPattern v' -> v = v'
    | SOVarPattern (v', _) -> v = v'
    | SOVarInstance (v', _) -> v = v'
    | FOVar v' -> v = v'
    | CVar v' -> v = v'
    | PIVar v' -> v = v'
    | PSVar v' -> v = v'
    | PLVar v' -> v = v'

   let rstack_so_mem_prop v = function
      FOVarPattern v' -> v = v'
    | SOVarPattern (v', _) -> v = v'
    | SOVarInstance (v', _) -> v = v'
    | _ -> false

   let rstack_fo_mem_prop v = function
      FOVar v' -> v = v'
    | _ -> false

   let rstack_p_mem_prop v = function
      PIVar v' -> v = v'
    | PSVar v' -> v = v'
    | PLVar v' -> v = v'
    | _ -> false

   let rstack_c_mem_prop v = function
      CVar v' -> v = v'
    | _ -> false

   let rstack_mem v = List.exists (rstack_mem_prop v)
   let rstack_so_mem v = List.exists (rstack_so_mem_prop v)
   let rstack_fo_mem v = List.exists (rstack_fo_mem_prop v)
   let rstack_p_mem v = List.exists (rstack_p_mem_prop v)
   let rstack_c_mem v = List.exists (rstack_c_mem_prop v)

   let array_rstack_mem v = Array_util.exists (rstack_mem_prop v)
   let array_rstack_so_mem v = Array_util.exists (rstack_so_mem_prop v)
   let array_rstack_fo_mem v = Array_util.exists (rstack_fo_mem_prop v)
   let array_rstack_c_mem v = Array_util.exists (rstack_c_mem_prop v)
   let array_rstack_p_mem v = Array_util.exists (rstack_p_mem_prop v)

   (*
    * Indexing.
    *)
   let rstack_index v l = List_util.find_item (rstack_mem_prop v) l
   let rstack_so_index v l = List_util.find_item (rstack_so_mem_prop v) l
   let rstack_fo_index v l = List_util.find_item (rstack_fo_mem_prop v) l
   let rstack_p_index v l = List_util.find_item (rstack_p_mem_prop v) l
   let rstack_c_index v l = List_util.find_item (rstack_c_mem_prop v) l

   let array_rstack_index v l = Array_util.find_index (rstack_mem_prop v) l
   let array_rstack_so_index v l = Array_util.find_index (rstack_so_mem_prop v) l
   let array_rstack_fo_index v l = Array_util.find_index (rstack_fo_mem_prop v) l
   let array_rstack_p_index v l = Array_util.find_index (rstack_p_mem_prop v) l
   let array_rstack_c_index v l = Array_util.find_index (rstack_c_mem_prop v) l

   (*
    * Find the index of a binding var into the stack
    * given an association list of indices.
    *)
   let var_index bvars t =
      let s = dest_var t in
         try List.assoc s bvars with
            Not_found -> ref_raise(RefineError ("var_index", RewriteFreeSOVar s))

   let svar_index bvars s =
      try List.assoc s bvars with
         Not_found -> ref_raise(RefineError ("var_index", RewriteFreeSOVar s))

   (************************************************************************
    * DEBUGGING                                                            *
    ************************************************************************)

   (*
    * Print a term by printing its opname.
    *)
   let print_term out t =
      output_string out (string_of_opname (opname_of_term t))

   (*
    * Name in the stack.
    *)
   let print_varname out = function
      StackName i ->
         fprintf out "stack:%d" i
    | ArgName i ->
         fprintf out "arg:%d" i
    | SaveName s ->
         fprintf out "save:%s" s

   (*
    * List separated by semicolons.
    *)
   let rec print_any_list print out = function
      [h] ->
         print out h
    | h::t ->
         print out h;
         output_string out "; ";
         print_any_list print out t
    | [] ->
         ()

   let print_string_list =
      print_any_list output_string

   let print_term_list =
      print_any_list print_term

   let print_int_list =
      print_any_list (fun out i -> fprintf out "%d" i)

   let print_varname_list =
      print_any_list print_varname

   (*
    * Print a stack item.
    * We can't print terms.
    *)
   let print_stack_item out = function
      StackVoid ->
         fprintf out "Void"
    | StackNumber n ->
         fprintf out "Number %s" (Num.string_of_num n)
    | StackString s ->
         fprintf out "String %s" s
    | StackLevel l ->
         fprintf out "Level"
    | StackBTerm (t, vars) ->
         fprintf out "BTerm %a[%a]" print_term t print_string_list vars
    | StackITerm _ ->
         fprintf out "ITerm"
    | StackContext (vars, t, addr) ->
         fprintf out "Context (%a/%a/%s)" (**)
            print_string_list vars
            print_term t
            (string_of_address addr)

   (*
    * Stack is printed on lines.
    *)
   let print_stack out stack =
      let print_item item =
         output_char out '\t';
         print_stack_item out item;
         eflush out
      in
         fprintf out "Stack: %d%t" (Array.length stack) eflush;
         Array.iter print_item stack

   (*
    * Redex stack names.
    *)
   let print_rstack_item out = function
      FOVarPattern s ->
         fprintf out "FOVarPattern %s" s
    | SOVarPattern (s, i) ->
         fprintf out "SOVarPatterm %s[%d]" s i
    | SOVarInstance (s, i) ->
         fprintf out "SOVarInstance %s[%d]" s i
    | FOVar s ->
         fprintf out "FOVar %s" s
    | CVar s ->
         fprintf out "CVar %s" s
    | PIVar s ->
         fprintf out "PIVar %s" s
    | PSVar s ->
         fprintf out "PSVar %s" s
    | PLVar s ->
         fprintf out "PLVar %s" s

   let print_rstack out stack =
      let print_item item =
         output_char out '\t';
         print_rstack_item out item;
         eflush out
      in
         fprintf out "RStack: %d%t" (Array.length stack) eflush;
         Array.iter print_item stack

   (*
    * Parameters.
    *)
   let rec print_param out = function
      RWNumber n ->
         fprintf out "%s:n" (Num.string_of_num n)
    | RWString s ->
         fprintf out "%s:s" s
    | RWToken s ->
         fprintf out "%s:t" s
    | RWLevel l ->
         fprintf out "x:l"
    | RWVar s ->
         fprintf out "%s:v" s
    | RWMNumber i ->
         fprintf out "@%d:n" i
    | RWMString i ->
         fprintf out "@%d:s" i
    | RWMToken i ->
         fprintf out "@%d:t" i
    | RWMLevel i ->
         fprintf out "@%d:l" i
    | RWMVar i ->
         fprintf out "@%d:v" i
    | RWSum (p1, p2) ->
         fprintf out "(%a + %a)" print_param p1 print_param p2
    | RWDiff (p1, p2) ->
         fprintf out "(%a - %a)" print_param p1 print_param p2
    | RWProduct (p1, p2) ->
         fprintf out "(%a * %a)" print_param p1 print_param p2
    | RWQuotient (p1, p2) ->
         fprintf out "(%a / %a)" print_param p1 print_param p2
    | RWRem (p1, p2) ->
         fprintf out "(%a %% %a)" print_param p1 print_param p2
    | RWLessThan (p1, p2) ->
         fprintf out "(%a < %a)" print_param p1 print_param p2
    | RWEqual (p1, p2) ->
         fprintf out "(%a = %a)" print_param p1 print_param p2
    | RWNotEqual (p1, p2) ->
         fprintf out "(%a != %a)" print_param p1 print_param p2
    | RWObId id ->
         fprintf out "ObId"
    | RWParamList pl ->
         fprintf out "[%a]" print_param_list pl

   and print_param_list out pl =
      let rec collect = function
         [h] ->
            print_param out h
       | h::t ->
            fprintf out "%a; %a" print_param h print_param_list t
       | [] ->
            ()
      in
         collect pl

   (*
    * Tab to the tabstop.
    *)
   let tab out stop =
      for i = 0 to stop do
         output_char out ' '
      done

   (*
    * Print the rewrite program.
    *)
   let print_prog out prog =
      let rec print_prog tabstop out prog =
         tab out tabstop;
         match prog with
         RWComposite { rw_op = op; rw_bterms = bterms } ->
            fprintf out "RWComposite %a\n%a" (**)
               print_op op
               (print_bterms (tabstop + 3)) bterms
       | RWSOVar (i, il) ->
            fprintf out "RWSOVar (%d, %a)\n" i print_int_list il
       | RWSOMatch (i, (il, sl, tl)) ->
            fprintf out "RWSOMatch (%d, (%a, %a, %a))\n" (**)
               i
               print_int_list il
               print_string_list sl
               print_term_list tl
       | RWSOSubst (i, tl) ->
            fprintf out "RWSOSubst %d\n%a" i (print_prog_list (tabstop + 3)) tl
       | RWSOContext (i, j, t, il) ->
            fprintf out "RWSOContext (%d, %d, [%a])\n%a" (**)
               i j print_int_list il
               (print_prog (tabstop + 3)) t
       | RWSOContextSubst (i, t, tl) ->
            fprintf out "RWSOContextSubst %d\n%a\n%a" (**)
               i
               (print_prog (tabstop + 3)) t
               (print_prog_list (tabstop + 3)) tl
       | RWCheckVar i ->
            fprintf out "RWCheckVar %d\n" i
       | RWStackVar i ->
            fprintf out "RWStackVar %d\n" i
       | RWError ->
            fprintf out "RWError"

      and print_prog_list tabstop out tl =
         List.iter (print_prog tabstop out) tl

      and print_bterm tabstop out { rw_bvars = bvars; rw_bnames = bnames; rw_bterm = t } =
         tab out tabstop;
         fprintf out "Bterm %d(%a)\n%a" (**)
            bvars
            print_varname_list bnames
            (print_prog (tabstop + 3)) t

      and print_bterms tabstop out bterms =
         List.iter (print_bterm tabstop out) bterms

      and print_op out { rw_name = opname; rw_params = params } =
         fprintf out "%s%a" (string_of_opname opname) (**)
            print_param_list params
      in
         print_prog 0 out prog

   (************************************************************************
    * REWRITE RULE COMPILATION
    ************************************************************************)

   (*
    * Compile a term with second order variables into
    * a rewrite term.
    *
    * The stack contains a list of variable names.
    * All second order variables and first order
    * binding variables go on the stack.
    *
    * The bvars is an association list of the binding
    * variables at the current point being compiled, mapping
    * binding names to stack locations.
    *
    * Return the stack and the compiled term.
    *)

   let rec bnames i = function
      h::t -> (StackName i)::(bnames (i + 1) t)
    | [] -> []

   (* Add new bvars *)
   let rec new_bvar_items i = function
      h::t -> (h, i)::(new_bvar_items (i + 1) t)
    | [] -> []

   (* Determine if a term is a bound variable *)
   let is_bound_var bvars v =
      is_var_term v & List.mem_assoc (dest_var v) bvars

   (* Find the free variables and their indices *)
   let gen_subterms bvars subterms =
      let fv = List_util.intersect (free_vars_terms subterms) (List_util.fst_split bvars) in
         List.map (svar_index bvars) fv, fv, subterms

   let rec compile_so_redex_term addrs stack bvars term =
      (* Check for variables and contexts *)
      if is_so_var_term term then
         let v, subterms = dest_so_var term in
            (* This is a first or second order variable *)
            if List.mem_assoc v bvars then
               (* This is a first order variable instance *)
               if subterms <> [] then
                  ref_raise(RefineError ("compile_so_redex_term", RewriteBoundSOVar v))
               else
                  stack, RWCheckVar(svar_index bvars v)

            else if List.for_all (is_bound_var bvars) subterms then
               (* This is a second order variable, and all subterms are vars *)
               if rstack_so_mem v stack then
                  (* Treat this as an instance, but record that a pattern was found *)
                  let _ = rstack_check_arity v (List.length subterms) stack in
                     (rstack_upgrade v stack),
                     RWSOMatch(rstack_so_index v stack, gen_subterms bvars subterms)
               else if subterms = [] then
                  (stack @ [FOVarPattern v]),
                  RWSOVar(List.length stack, List.map (var_index bvars) subterms)
               else
                  (stack @ [SOVarPattern (v, List.length subterms)]),
                  RWSOVar(List.length stack, List.map (var_index bvars) subterms)


            (* This is a second order variable instance *)
            else if rstack_so_mem v stack then
               let _ = rstack_check_arity v (List.length subterms) stack in
                  stack, RWSOMatch(rstack_so_index v stack, gen_subterms bvars subterms)
            else
               (stack @ [SOVarInstance (v, List.length subterms)]),
               RWSOMatch(List.length stack, gen_subterms bvars subterms)

      else if is_context_term term then
         let v, term, vars = dest_context term in
            if rstack_mem v stack then
               (* The context should have a unique name *)
               ref_raise(RefineError ("is_context_term", RewriteBoundSOVar v))

            else if Array_util.mem v addrs then
               (* All the vars should be free variables *)
               let stack' = stack @ [CVar v] in
               let stack'', term' = compile_so_redex_term addrs stack' bvars term in
                  stack'', RWSOContext(Array_util.index v addrs,
                                       List.length stack,
                                       term',
                                       List.map (var_index bvars) vars)
            else
               (* No argument for this context *)
               ref_raise(RefineError ("is_context_term", RewriteMissingContextArg v))

      else
         (* This is normal term--not a var *)
         let { term_op = op; term_terms = bterms } = dest_term term in
         let { op_name = name; op_params = params } = dest_op op in
         let stack2, params2 = compile_so_redex_params stack params in
         let stack3, bterms3 = compile_so_redex_bterms addrs stack2 bvars bterms in
            stack3, RWComposite { rw_op = { rw_name = name; rw_params = params2 };
                                  rw_bterms = bterms3 }

   (*
    * We also compile parameters, and bind meta-variables.
    *)
   and compile_so_redex_params stack = function
      [] -> stack, []
    | param::params ->
         (* Do this param *)
         let stack', param' = compile_so_redex_param stack param in
         let stack'', params' = compile_so_redex_params stack' params in
            stack'', param'::params'

   and meta_param stack const pvar v =
      if rstack_p_mem v stack then
         (* This param is not free, do a match *)
         stack, const (rstack_p_index v stack)
      else
         (* Add it *)
         stack @ [pvar v], const (List.length stack)

   and compile_so_redex_param stack param =
      match dest_param param with
         MNumber v -> meta_param stack (fun i -> RWMNumber i) (fun v -> PIVar v) v
       | MString(v) -> meta_param stack (fun s -> RWMString s) (fun s -> PSVar s) v
       | MToken(v) -> meta_param stack (fun t -> RWMToken t) (fun s -> PSVar s) v
       | MLevel(v) -> meta_param stack (fun l -> RWMLevel l) (fun l -> PLVar l) v
       | MVar(v) -> meta_param stack (fun v -> RWMVar v) (fun v -> PSVar v) v
       | Number(i) -> stack, RWNumber(i)
       | String(s) -> stack, RWString(s)
       | Token(t) -> stack, RWToken(t)
       | Level(i) -> stack, RWLevel(i)
       | Var(v) -> stack, RWVar(v)
       | _ -> ref_raise(RefineError ("compile_so_redex_param", RewriteBadMatch (ParamMatch param)))

   (*
    * In bterms, have to add these vars to the binding stack.
    *)
   and compile_so_redex_bterms addrs stack bvars = function
      [] -> stack, []
    | bterm::bterms ->
         let stack', bterm' = compile_so_redex_bterm addrs stack bvars bterm in
         let stack'', bterms' = compile_so_redex_bterms addrs stack' bvars bterms in
            stack'', bterm'::bterms'

   and compile_so_redex_bterm addrs stack bvars bterm =
      match dest_bterm bterm with
         { bvars = vars; bterm = term } ->
            (* Add vars to the stack *)
            let stack' = stack @ (List.map (fun v -> FOVar v) vars) in
            let l = List.length stack in
            let bvars' = bvars @ (new_bvar_items l vars) in

            (* Compile the term *)
            let stack'', term' = compile_so_redex_term addrs stack' bvars' term in
               stack'', { rw_bvars = List.length vars; rw_bnames = bnames l vars; rw_bterm = term' }

   (*
    * This is the final version.
    *)
   let rec compile_so_redex_aux addrs stack = function
      [] -> stack, []
    | term::t ->
         let stack', term' = compile_so_redex_term addrs stack [] term in
         let stack'', terms' = compile_so_redex_aux addrs stack' t in
            stack'', term'::terms'

   let check_stack = function
      SOVarInstance (n, _) ->
         ref_raise(RefineError ("check_stack", RewriteAllSOInstances n))
    | _ -> ()

   let compile_so_redex addrs t =
      let stack, terms = compile_so_redex_aux addrs [] t in
      List.iter check_stack stack;
      Array.of_list stack, terms

   (*
    * When the contractum is compiled, the redex has already been
    * compiled, and the stack contains a list of the special variables.
    *)
   let compile_bname names stack n =
      if Array_util.mem n names then
         ArgName (Array_util.index n names)
      else if array_rstack_fo_mem n stack then
         StackName (array_rstack_fo_index n stack)
      else
         SaveName n

   let rec compile_so_contractum_term names stack bvars term =
      if is_so_var_term term then
         let v, subterms = dest_so_var term in
            (* This is a first or second order variable *)
            if List.mem v bvars then
               (* This is a first order variable instance *)
               if subterms <> [] then
                  ref_raise(RefineError ("compile_so_contractum_term", RewriteBoundSOVar v))
               else
                  RWCheckVar(List_util.find_index v bvars)

            else if array_rstack_so_mem v stack then
               (*
                * This is a second order variable.
                * The variable v should be bound, and we generate a
                * a substitution instance.  Check that the subterm counts
                * match.
                *)
               let index = array_rstack_so_index v stack in
               let v' = stack.(index) in
               let _ = v' = FOVar "x" in
               RWSOSubst(array_rstack_so_index v stack,
                         List.map (compile_so_contractum_term names stack bvars) subterms)

            else if array_rstack_fo_mem v stack & subterms = [] then
               (* This variable represents a binding occurrence *)
               RWStackVar (array_rstack_fo_index v stack)

            else
               (* This is a second order variable that is free *)
               ref_raise(RefineError ("compile_so_contractum_term", RewriteFreeSOVar v))

      else if is_context_term term then
         (* This is a second order context *)
         let v, term', subterms = dest_context term in
            if array_rstack_c_mem v stack then
               (*
                * Second order context and the v is bound.
                * We generate a substitution instance.
                *)
               RWSOContextSubst(
                  array_rstack_c_index v stack,
                  compile_so_contractum_term names stack bvars term',
                  List.map (compile_so_contractum_term names stack bvars) subterms)

            else
               (* Free second order context *)
               ref_raise(RefineError ("is_context_term", RewriteFreeSOVar v))

      else
         (* This is a normal term--not a var *)
         let { term_op = op; term_terms = bterms } = dest_term term in
         let { op_name = name; op_params = params } = dest_op op in
            (* This is a normal term *)
         let params' = List.map (compile_so_contractum_param stack) params in
         let bterms' = List.map (compile_so_contractum_bterm names stack bvars) bterms in
            RWComposite { rw_op = { rw_name = name; rw_params = params' };
                          rw_bterms = bterms'
            }

   (*
    * We also compile parameters, and bind meta-variables.
    *)
   and compile_so_contractum_param stack param =
      match dest_param param with
         MNumber v ->
            if array_rstack_p_mem v stack then
               (* New param *)
               RWMNumber (array_rstack_p_index v stack)
            else
               (* Free param *)
               ref_raise(RefineError ("compile_so_contractum_param", RewriteFreeParamVar v))

       | MString v ->
            if array_rstack_p_mem v stack then
               (* New param *)
               RWMString (array_rstack_p_index v stack)
            else
               (* Free param *)
               ref_raise(RefineError ("compile_so_contractum_param", RewriteFreeParamVar v))

       | MToken v ->
            if array_rstack_p_mem v stack then
               (* New param *)
               RWMToken (array_rstack_p_index v stack)
            else
               (* Free param *)
               ref_raise(RefineError ("compile_so_contractum_param", RewriteFreeParamVar v))

       | MLevel v ->
            if array_rstack_p_mem v stack then
               (* New param *)
               RWMLevel (array_rstack_p_index v stack)
            else
               (* Free param *)
               ref_raise(RefineError ("compile_so_contractum_param", RewriteFreeParamVar v))

       | MVar v ->
            if array_rstack_p_mem v stack then
               (* New param *)
               RWMVar(array_rstack_p_index v stack)
            else
               (* Free param *)
               ref_raise(RefineError ("compile_so_contractum_param", RewriteFreeParamVar v))

       | Number i -> RWNumber i
       | String s -> RWString s
       | Token t -> RWToken t
       | Level i -> RWLevel i
       | Var v -> RWVar v

       | MSum (a, b) -> RWSum (compile_so_contractum_param stack a,
                               compile_so_contractum_param stack b)
       | MDiff (a, b) -> RWDiff (compile_so_contractum_param stack a,
                                 compile_so_contractum_param stack b)
       | MProduct (a, b) -> RWProduct (compile_so_contractum_param stack a,
                                       compile_so_contractum_param stack b)
       | MQuotient (a, b) -> RWQuotient (compile_so_contractum_param stack a,
                                         compile_so_contractum_param stack b)
       | MRem (a, b) -> RWRem (compile_so_contractum_param stack a,
                               compile_so_contractum_param stack b)
       | MLessThan (a, b) -> RWLessThan (compile_so_contractum_param stack a,
                                         compile_so_contractum_param stack b)
       | MEqual (a, b) -> RWEqual (compile_so_contractum_param stack a,
                                   compile_so_contractum_param stack b)
       | MNotEqual (a, b) -> RWNotEqual (compile_so_contractum_param stack a,
                                         compile_so_contractum_param stack b)

       | ObId id ->
            RWObId id

       | ParamList l ->
            RWParamList (List.map (compile_so_contractum_param stack) l)

   (*
    * In bterms, have to add these vars to the binding stack.
    *)
   and compile_so_contractum_bterm names stack bvars bterm =
      let { bvars = vars; bterm = term } = dest_bterm bterm in
      let term' = compile_so_contractum_term names stack (bvars @ vars) term in
      let vars' = List.map (compile_bname names stack) vars in
         { rw_bvars = List.length vars; rw_bnames = vars'; rw_bterm = term' }

   let compile_so_contractum names stack = compile_so_contractum_term names stack []

   (*
    * Naming function.
    *)
   let compute_index stack v =
      if array_rstack_fo_mem v stack then
         Some (array_rstack_fo_index v stack)
      else
         None

   let compute_namer stack names =
      let indices = Array.map (compute_index stack) names in
      let length = Array.length names in
      let namer stack' names' =
         (* Compute an array of names to change *)
         let names' = Array.copy names' in
            if !debug_rewrite then
               begin
                  print_rstack stderr stack;
                  print_stack stderr stack';
                  eprintf "Indices: %d:" length;
                  Array_util.iter2 (fun name index ->
                        match index with
                           Some i -> eprintf " %s=%d" name i
                         | None -> eprintf " %s=*" name) names indices;
                  eflush stderr
               end;
            for i = 0 to length - 1 do
               match indices.(i) with
                  Some j ->
                     begin
                        match stack'.(j) with
                           StackString s ->
                              if !debug_rewrite then
                                 eprintf "Rewrite.compute_namer: names(%d)/%d <- %s%t" (**)
                                    i (Array.length names') s eflush;
                              names'.(i) <- s
                         | x ->
                              ref_raise(RefineError ("compute_namer", RewriteStringError "stack entry is not a string"))
                  end
             | None ->
                  ()
         done;
         names'
      in
         namer

   (*
    * Compile redex and contractum, and form a rewrite rule.
    *)
   let term_rewrite (addrs, names) redex contracta =
      let stack, redex' = compile_so_redex addrs redex in
      let namer = compute_namer stack names in
      let contracta' = List.map (compile_so_contractum names stack) contracta in
         { rr_redex = redex';
           rr_namer = namer;
           rr_contractum = RWCTerm contracta';
           rr_gstacksize = Array.length stack
         }

   (*
    * Make a ML function rewrite.
    *)
   let fun_rewrite redex f =
      let stack, redex' = compile_so_redex [||] [redex] in
         { rr_redex = redex';
           rr_namer = (fun stack names -> names);
           rr_contractum = RWCFunction(f);
           rr_gstacksize = Array.length stack
         }

   (*
    * Compile just the redex.
    *)
   let compile_redices addrs redices =
      let stack, redices = compile_so_redex addrs redices in
         { redex_stack = stack; redex_redex = redices }

   let compile_redex addrs redex =
      let redex = compile_redices addrs [redex] in
         match redex.redex_redex with
            [_] ->
               redex
          | _ ->
               failwith "compile_redex: too many redices"

   (*
    * Compile a contractum, given the previous redex.
    *)
   let compile_contractum { redex_stack = stack } contractum =
      let contractum = compile_so_contractum [||] stack contractum in
         { con_contractum = contractum }

   (************************************************************************
    * REWRITE RULE APPLICATION
    ************************************************************************)

   (*
    * Get the vars from their indices.
    *)
   let extract_bvar stack v =
      match stack.(v) with
         StackString s -> s
       | x -> ref_raise(RefineError ("extract_bvar", RewriteStringError "stack entry is not a string"))

   let extract_bvars stack l = List.map (extract_bvar stack) l

   (*
    * Assign the bvars.
    *)
   let set_bvars stack names vars =
      let aux v = function
         StackName i ->
            if !debug_rewrite then
               eprintf "Rewrite.set_bvars: stack(%d)/%d%t" i (Array.length stack) eflush;
            stack.(i) <- StackString v
       | _ ->
            ()
      in
         List.iter2 aux vars names

   (*
    * Check that two terms are equal under the given var equivalence
    *)
   let check_simple_match ((t, v) as tv) tv' =
      if not (alpha_equal_vars tv tv') then
         ref_raise(RefineError ("check_simple_match", RewriteBadMatch (TermMatch t)))

   (*
    * Check that the terms are all equivalent under the given instantiations
    *)
   let rec check_match tv = function
      h::tl ->
         if alpha_equal_match tv h then
            check_match tv tl
         else
            ref_raise(RefineError ("check_match", RewriteBadMatch (TermMatch (fst tv))))
    | [] ->
         ()

   (*
    * Match a term against the redex.
    *)
    let rec match_redex_term addrs stack t' t =
        match t' with
           RWComposite { rw_op = { rw_name = name'; rw_params = params' }; rw_bterms = bterms' } ->
              let { term_op = op; term_terms = bterms } = dest_term t in
              let { op_name = name; op_params = params } = dest_op op in
                 if !debug_rewrite then
                    eprintf "Rewrite.match_redex.RWComposite: %s/%s%t" (**)
                       (flat_opname name')
                       (flat_opname name)
                       eflush;
                 if name == name' then
                    begin
                       List.iter2 (match_redex_params stack) params' params;
                       List_util.rev_iter2 (match_redex_bterms addrs stack) bterms' bterms
                    end
                 else
                    ref_raise(RefineError ("match_redex_term", RewriteBadMatch (TermMatch t)))

         | RWCheckVar i ->
              begin
                 let v = dest_var t in
                    if !debug_rewrite then
                       eprintf "Rewrite.match_redex.RWCheckVar: %d/%s%t" i v eflush;
                     match stack.(i) with
                        StackString v' ->
                          if !debug_rewrite then
                             eprintf "Rewrite.match_redex.RWCheckVar: %s/%s%t" v' v eflush;
                           if v' <> v then
                              ref_raise(RefineError ("match_redex_term", RewriteBadMatch (VarMatch v)))
                      | x ->
                         ref_raise(RefineError ("match_redex_term", RewriteStringError "stack entry is not a string"))
              end

         | RWSOVar (i, l) ->
              (* Save the term at i *)
              begin
                 let vars = extract_bvars stack l in
                    if !debug_rewrite then
                       eprintf "Rewrite.match_redex.RWSOVar: stack(%d)/%d%t" i (Array.length stack) eflush;
                    match stack.(i) with
                       StackVoid ->
                          if !debug_rewrite then
                             eprintf "\tRWSoVar: Void%t" eflush;
                          stack.(i) <- StackBTerm (t, vars)
                     | StackBTerm (t', vars') ->
                          if !debug_rewrite then
                             eprintf "\tRWSOVar: Bterm: check_simple_match%t" eflush;
                          check_simple_match (t, vars) (t', vars);
                          if !debug_rewrite then
                             eprintf "\tRWSOVar: Bterm: check_simple_match: ok%t" eflush;
                     | StackITerm l ->
                          if !debug_rewrite then
                             eprintf "\tRWSOVar: ITerm: check_match%t" eflush;
                          check_match (t, vars) l;
                          if !debug_rewrite then
                             eprintf "\tRWSOVar: ITerm: check_match: ok%t" eflush;
                          stack.(i) <- StackBTerm (t, vars)
                     | _ ->
                          ref_raise(RefineError ("match_redex_term", RewriteStringError "stack entry is not valid"))
              end

         | RWSOMatch (i, (ivars, vars, subterms)) ->
              (* See if the term matches *)
              begin
                 let vars' = extract_bvars stack ivars in
                    if !debug_rewrite then
                       eprintf "Rewrite.match_redex.RWSOMatch: stack(%d)/%d%t" i (Array.length stack) eflush;
                     match stack.(i) with
                        StackVoid ->
                           stack.(i) <- StackITerm [t, vars', vars, subterms]
                      | StackBTerm (t'', vars'') ->
                           check_match (t'', vars'') [t, vars', vars, subterms]
                      | StackITerm l ->
                           stack.(i) <- StackITerm ((t, vars', vars, subterms)::l)
                      | _ ->
                           ref_raise(RefineError ("match_redex_term", RewriteStringError "stack entry is not valid"))
              end

         | RWSOContext (addr, i, term', l) ->
              (* Pull an address out of the addr argument *)
              let addr' = addrs.(addr) in
              if !debug_rewrite then
                 eprintf "Rewrite.match_redex.RWSOContext: %s%t" (string_of_address addr') eflush;
              let term = term_subterm t addr' in
                 if !debug_rewrite then
                    eprintf "Rewrite.match_redex.RWSOContext: stack(%d)/%d%t" i (Array.length stack) eflush;
                 stack.(i) <- StackContext (extract_bvars stack l, t, addr');
                 match_redex_term addrs stack term' term

         | _ ->
              ref_raise(RefineError ("match_redex_term", RewriteBadMatch (TermMatch t)))

    and match_redex_params stack p' p =
        match p', dest_param p with
           (* Literal matches *)
           RWNumber i, Number j ->
              if not (i = j) then
                 ref_raise(RefineError ("match_redex_params", RewriteBadMatch (ParamMatch p)))
         | RWString s', String s ->
              if not (s' = s) then
                 ref_raise(RefineError ("match_redex_params", RewriteBadMatch (ParamMatch p)))
         | RWToken t', Token t ->
              if not (t' = t) then
                 ref_raise(RefineError ("match_redex_params", RewriteBadMatch (ParamMatch p)))
         | RWLevel i', Level i ->
              if not (i' = i) then
                 ref_raise(RefineError ("match_redex_params", RewriteBadMatch (ParamMatch p)))
         | RWVar v', Var v ->
              if not (v' = v) then
                 ref_raise(RefineError ("match_redex_params", RewriteBadMatch (ParamMatch p)))

           (* Variable matches *)
         | RWMNumber i, Number j ->
              if !debug_rewrite then
                 eprintf "Rewrite.match_redex_params.RWMNumber: stack(%d)/%d <- %s%t" (**)
                    i (Array.length stack) (Num.string_of_num j) eflush;
              stack.(i) <- StackNumber j
         | RWMString i, String s ->
              if !debug_rewrite then
                 eprintf "Rewrite.match_redex_params.RWMString: stack(%d)/%d <- %s%t" (**)
                    i (Array.length stack) s eflush;
              stack.(i) <- StackString s
         | RWMToken i, Token t ->
              if !debug_rewrite then
                 eprintf "Rewrite.match_redex_params.RWMToken: stack(%d)/%d <- %s%t" (**)
                    i (Array.length stack) t eflush;
              stack.(i) <- StackString t
         | RWMVar i, Var v ->
              if !debug_rewrite then
                 eprintf "Rewrite.match_redex_params.RWMVar: stack(%d)/%d <- %s%t" (**)
                    i (Array.length stack) v eflush;
              stack.(i) <- StackString v
         | RWMLevel i, Level l ->
              if !debug_rewrite then
                 eprintf "Rewrite.match_redex_params.RWMLevel: stack(%d)/%d%t" (**)
                    i (Array.length stack) eflush;
              stack.(i) <- StackLevel l

         | _ -> ref_raise(RefineError ("match_redex_params", RewriteBadMatch (ParamMatch p)))

    and match_redex_bterms addrs stack bt' bt =
        match bt', dest_bterm bt with
            { rw_bvars = vars'; rw_bnames = names; rw_bterm = bterm' },
            { bvars = vars; bterm = bterm } ->
               set_bvars stack names vars;
               if vars' = List.length vars then
                  match_redex_term addrs stack bterm' bterm
               else
                  ref_raise(RefineError ("match_redex_bterms", RewriteBadMatch (BTermMatch bt)))

    let match_redex addrs stack progs tl =
       if !debug_rewrite then
          begin
             eprintf "match_redex: %d%t" (List.length progs) eflush;
             List.iter (print_prog stderr) progs
          end;
       List.iter2 (match_redex_term addrs stack) progs tl

   (*
    * The contractum is built as a second order substitution.
    * For variable renaming, we keep track of the varibale
    * and the name it has been renamed to.  Whenever a second
    * order term is instantiated, we do a calculation of
    * the variables to be renamed, and send it back up.
    *)

   (* Map name specifications to names *)
   let build_bname names bnames stack = function
      ArgName i ->
         let v = names.(i) in
         let rec check v = function
            vars :: tl ->
               if List.mem v vars then
                  ref_raise(RefineError ("build_bname", RewriteBoundSOVar v))
               else
                  check v tl
          | [] ->
               ()
         in
            check v bnames;
            v
    | StackName i ->
         begin
            match stack.(i) with
               StackString s ->
                  s
             | x ->
                  ref_raise(RefineError ("build_bname", RewriteStringError "stack entry is not a string"))
         end
    | SaveName n ->
         n

   (*
    * Append the var array.
    *)
   let append_vars bvars vars =
      Array.append bvars (Array.of_list vars)

   (*
    * Build the terms.
    *    names: variable names provided by argument
    *    bnames: string list list of all the bound variables in the term
    *    stack: stack compiled from match_redex
    *    bvars: array of bound vars explicit in the contractum.
    *    con: the contractum being constructed.
    *)
   let rec build_contractum_term names bnames stack bvars = function
      RWComposite { rw_op = { rw_name = name; rw_params = params }; rw_bterms = bterms } ->
         (* Build a regular term from the parts *)
         mk_term (mk_op name (build_contractum_params stack params)) (**)
            (build_contractum_bterms names bnames stack bvars bterms)

    | RWSOSubst(i, terms) ->
         begin
             (*
              * Instantiate a second order term.
              * Find its free variables, and rename the binding stack
              * if necessary.
              *)
             match stack.(i) with
                StackBTerm(term, vars) ->
                   let terms = List.map (build_contractum_term names bnames stack bvars) terms in
                   let _ =
                      assert (if !debug_subst then
                                 begin
                                    eprintf "RWSOSubst: %a%t" debug_print term eflush;
                                    List.iter2 (fun name term ->
                                          eprintf "\t%s: %a%t" name debug_print term eflush) (**)
                                       vars terms
                                 end;
                              true)
                   in
                   let term = subst term terms vars in
                      assert (if !debug_subst then
                                 eprintf "\t%a%t" debug_print term eflush;
                              true);
                      term
              | _ ->
                   ref_raise(RefineError ("build_contractum_term", RewriteStringError "stack entry is not valid"))
         end

    | RWSOContextSubst(i, t, terms) ->
         begin
             (*
              * Instantiate a context.
              *)
             match stack.(i) with
                StackContext(vars, term, addr) ->
                   let term = replace_subterm term addr (**)
                                 (build_contractum_term names bnames stack bvars t)
                   in
                   let terms = List.map (build_contractum_term names bnames stack bvars) terms in
                      assert (if !debug_subst then
                                 begin
                                    eprintf "RWSOContextSubst: %a%t" debug_print term eflush;
                                    List.iter2 (fun name term ->
                                          eprintf "\t%s: %a%t" name debug_print term eflush) (**)
                                       vars terms
                                 end;
                              true);
                   subst term terms vars
              | _ ->
                   ref_raise(RefineError ("build_contractum_term", RewriteStringError "stack entry is not valid"))
         end

    | RWCheckVar i ->
         (*
          * This is a bound occurrence.
          *)
         mk_var_term bvars.(i)

    | RWStackVar i ->
         (*
          * This is a bound occurrence.
          *)
         begin
            match stack.(i) with
               StackString s ->
                  mk_var_term s
             | x ->
                  ref_raise(RefineError ("build_contractum_term", RewriteStringError "stack entry is not valid"))
         end

    | t ->
         ref_raise(RefineError ("build_contractum_term", RewriteStringError "bad contractum"))

   and build_con_exn = RefineError ("build_contractum_param", RewriteStringError "stack entry is not valid")

   and raise_param p =
      ref_raise(RefineError ("build_contractum_param", RewriteBadMatch (ParamMatch (make_param p))))

   and build_contractum_param stack = function
      RWNumber i ->
         Number i
    | RWString s ->
         String s
    | RWToken s ->
         Token s
    | RWLevel l ->
         Level l
    | RWVar v ->
         Var v
    | RWMNumber i ->
         begin
             match stack.(i) with
                StackNumber j -> Number j
              | StackString s -> Number (Num.num_of_string s)
              | t -> ref_raise(build_con_exn)
         end
    | RWMString i ->
         begin
             match stack.(i) with
                StackString s -> String s
              | StackNumber j -> String (Num.string_of_num j)
              | t -> ref_raise(build_con_exn)
         end
    | RWMToken i ->
         begin
             match stack.(i) with
                StackString s -> Token s
              | StackNumber j -> String (Num.string_of_num j)
              | t -> ref_raise(build_con_exn)
         end
    | RWMLevel i ->
         begin
             match stack.(i) with
                StackLevel l -> Level l
              | t -> ref_raise(build_con_exn)
         end
    | RWMVar i ->
         begin
             match stack.(i) with
                StackString v -> Var v
              | StackNumber j -> Var (Num.string_of_num j)
              | t -> ref_raise(build_con_exn)
         end
    | RWSum (p1, p2) ->
         begin
             match (build_contractum_param stack p1, build_contractum_param stack p2) with
                (Number i, Number j) -> Number (Num.add_num i j)
              | (Number i, p) -> raise_param p
              | (p, _) -> raise_param p
         end
    | RWDiff (p1, p2) ->
         begin
             match (build_contractum_param stack p1, build_contractum_param stack p2) with
                (Number i, Number j) -> Number (Num.sub_num i j)
              | (Number i, p) -> raise_param p
              | (p, _) -> raise_param p
         end
    | RWProduct (p1, p2) ->
         begin
             match (build_contractum_param stack p1, build_contractum_param stack p2) with
                (Number i, Number j) -> Number (Num.mult_num i j)
              | (Number i, p) -> raise_param p
              | (p, _) -> raise_param p
         end
    | RWQuotient (p1, p2) ->
         begin
             match (build_contractum_param stack p1, build_contractum_param stack p2) with
                (Number i, Number j) -> Number (Num.quo_num i j)
              | (Number i, p) -> raise_param p
              | (p, _) -> raise_param p
         end
    | RWRem (p1, p2) ->
         begin
             match (build_contractum_param stack p1, build_contractum_param stack p2) with
                (Number i, Number j) -> Number (Num.mod_num i j)
              | (Number i, p) -> raise_param p
              | (p, _) -> raise_param p
         end
    | RWLessThan (p1, p2) ->
         begin
             match (build_contractum_param stack p1, build_contractum_param stack p2) with
                (Number i, Number j) -> Token (if i < j then "true" else "false")
              | (Number i, p) -> raise_param p
              | (p, _) -> raise_param p
         end
    | RWEqual (p1, p2) ->
         begin
             match (build_contractum_param stack p1, build_contractum_param stack p2) with
                (Number i, Number j) -> Token (if i = j then "true" else "false")
              | (Number i, p) -> raise_param p
              | (p, _) -> raise_param p
         end
    | RWNotEqual (p1, p2) ->
         begin
             match (build_contractum_param stack p1, build_contractum_param stack p2) with
                (Number i, Number j) -> Token (if i = j then "false" else "true")
              | (Number i, p) -> raise_param p
              | (p, _) -> raise_param p
         end
    | RWObId id ->
         ObId id
    | RWParamList l ->
         ParamList (build_contractum_params stack l)

   and build_contractum_params stack params =
      let build_contractum_param' p =
         make_param (build_contractum_param stack p)
      in
         List.map build_contractum_param' params

   and build_contractum_bterm names bnames stack bvars = function
      { rw_bvars = vcount; rw_bnames = vars; rw_bterm = term } ->
         let vars' = List.map (build_bname names bnames stack) vars in
            mk_bterm vars' (build_contractum_term names (vars' :: bnames) stack (append_vars bvars vars') term)

   and build_contractum_bterms names bnames stack bvars =
      List.map (build_contractum_bterm names bnames stack bvars)

   let build_contractum names bnames stack =
      build_contractum_term names bnames stack [||]

   let opname_exn = RefineError ("Rewrite.apply_rewrite", RewriteStringError "opnames do not match")

   (*
    * To do the rewrite. match agaist the redex, then
    * instantiate the contractum.
    *)
   let apply_rewrite
       { rr_redex = redex;
         rr_contractum = contractum;
         rr_namer = namer;
         rr_gstacksize = gstacksize
       } (addrs, names, bnames) terms =
      let _ =
         (* Check the opnames to short-circuit applications that quickly fail *)
         match redex, terms with
            (RWComposite { rw_op = { rw_name = opname1 } } :: _, t :: _) ->
               if opname1 != opname_of_term t then
                  ref_raise(opname_exn)
          | _ ->
               ()
      in
      let gstack = Array.create gstacksize StackVoid in
         if !debug_rewrite then
            eprintf "Rewrite.apply_rewrite: match_redex%t" eflush;
         match_redex addrs gstack redex terms;
         if !debug_rewrite then
            eprintf "Rewrite.apply_rewrite: namer%t" eflush;
         let names' = namer gstack names in
         let result =
            match contractum with
               RWCTerm con ->
                  if !debug_rewrite then
                     eprintf "Rewrite.apply_rewrite: build_contractum%t" eflush;
                  List.map (build_contractum names bnames gstack) con, names'
             | RWCFunction f ->
                  match terms with
                     [t] ->
                        [f t], names'
                   | _ ->
                        ref_raise(RefineError ("apply_rewrite", RewriteBadMatch (TermMatch xnil_term)))
         in
            if !debug_rewrite then
               eprintf "Rewrite.apply_rewrite: done%t" eflush;
            result

   (*
    * Compute the redex types.
    *)
   let extract_redex_type = function
      FOVarPattern s -> RewriteTermType s
    | SOVarPattern (s, _) -> RewriteFunType s
    | SOVarInstance (s, _) -> RewriteFunType s
    | FOVar s -> RewriteStringType s
    | CVar s -> RewriteContextType s
    | PIVar s -> RewriteIntType s
    | PSVar s -> RewriteStringType s
    | PLVar s -> RewriteLevelType s

   let extract_redex_types { redex_stack = stack } =
      let l = Array.length stack in
      let rec aux j =
         if j < l then
            (extract_redex_type stack.(j))::(aux (j + 1))
         else
            []
      in
         aux 0

   (*
    * Given the two stack, extract values that can be used in a program.
    * For each object:
    *    1. A second order variable becomes a function
    *       that takes a list of subexpressions and performs the substitution.
    *    2. A first order variable becomes the string with the name.
    *    3. A context variable is converted to a function
    *       that takes the hole and the subexpressions and
    *       performs the substitution
    *    4. A param variable becaome the param that was matched.
    *)
   let extract_exn = RefineError ("extract_redex_values", RewriteStringError "stack entry is not valid")

   let extract_redex_values_aux gstack = function
      FOVarPattern _ ->
         begin
            match gstack with
               StackBTerm (t, []) -> RewriteTerm t
             | _ -> ref_raise(extract_exn)
         end
    | SOVarPattern _ ->
         begin
            match gstack with
               StackBTerm (t, l) ->
                  RewriteFun (fun l' -> subst t l' l)
             | _ -> ref_raise(extract_exn)
         end
    | SOVarInstance _ ->
         failwith "extract_redex_values: SOVarInstance"
    | FOVar _ ->
         begin
            match gstack with
               StackString s -> RewriteString s
             | _ -> ref_raise(extract_exn)
         end
    | CVar _ ->
         begin
            match gstack with
               StackContext (l, t, addr) ->
                  RewriteContext (fun c l' -> subst (replace_subterm t addr c) l' l)
             | _ -> ref_raise(extract_exn)
         end
    | PIVar _ ->
         begin
            match gstack with
               StackNumber i -> RewriteInt (Num.int_of_num i)
             | _ -> ref_raise(extract_exn)
         end
    | PSVar _ ->
         begin
            match gstack with
               StackString s -> RewriteString s
             | _ -> ref_raise(extract_exn)
         end
    | PLVar _ ->
         begin
            match gstack with
               StackLevel l -> RewriteLevel l
             | _ -> ref_raise(extract_exn)
         end

   let extract_redex_values gstack stack=
      let l = Array.length gstack in
      let rec aux' i =
         if i < l then
            (extract_redex_values_aux gstack.(i) stack.(i))::(aux' (i + 1))
         else
            []
      in
         aux' 0

   (*
    * Match with a redex, and extract the forms to be bound.
    *)
   let apply_redex { redex_stack = stack; redex_redex = redex } addrs terms =
      let gstack = Array.create (Array.length stack) StackVoid in
         match_redex addrs gstack redex terms;
         gstack

   let apply_redex' { redex_stack = stack; redex_redex = redex } addrs terms =
      let gstack = Array.create (Array.length stack) StackVoid in
         match_redex addrs gstack redex terms;
         gstack, extract_redex_values gstack stack

   (*
    * Build a contractum from the spec and a stack.
    *)
   let make_contractum { con_contractum = con } gstack =
      build_contractum [||] [] gstack con

   (************************************************************************
    * REDEX RELEVANCY                                                      *
    ************************************************************************)

   (*
    * See if an operator generalizes another.
    *)

   let compare_params p rwp =
      match dest_param p, rwp with
         Number a, RWNumber b -> a = b
       | String a, RWString b -> a = b
       | Token a, RWToken b -> a = b
       | Var a, RWVar b -> a = b
       | Level a, RWLevel b -> a = b
       | MNumber a, RWNumber b -> true
       | MNumber a, RWMNumber b -> true
       | MString a, RWString b -> true
       | MString a, RWMString b -> true
       | MToken a, RWToken b -> true
       | MToken a, RWMToken b -> true
       | MLevel a, RWLevel b -> true
       | MLevel a, RWMLevel b -> true
       | MVar a, RWVar b -> true
       | MVar a, RWMVar b -> true
       | _ -> false

   let compare_param_lists = List_util.for_all2 compare_params

   let relevant_operator op rw =
      match dest_op op, rw with
         { op_name = name1; op_params = params1 },
         { rw_name = name2; rw_params = params2 } ->
            name1 = name2 & compare_param_lists params1 params2

   (*
    * See if the bterms can be described by these arities.
    *)
   let rec relevant_bterms = function
      arity::arities, { rw_bvars = vars }::t ->
         if vars = arity then
            relevant_bterms (arities, t)
         else
            false
    | [], [] -> true
    | _ -> false

   (*
    * See if a rule is relevant to a term description.
    *)
   let relevant_rule op1 arities = function
      { rr_redex = (RWComposite { rw_op = op2; rw_bterms = bterms })::_ } ->
         if relevant_operator op1 op2 then
            relevant_bterms (arities, bterms)
         else
            false
     | _ -> false

   (*
    * Get the operator of a rewrite rule.
    *)
   let rec convert_param' = function
      RWNumber i -> Number(i)
    | RWString s -> String s
    | RWToken t -> Token t
    | RWLevel i -> Level i
    | RWVar v -> Var v
    | RWMNumber i -> MNumber ("v" ^ (string_of_int i))
    | RWMString i -> MString ("v" ^ (string_of_int i))
    | RWMToken i -> MToken ("v" ^ (string_of_int i))
    | RWMLevel i -> MLevel ("v" ^ (string_of_int i))
    | RWMVar i -> MVar ("v" ^ (string_of_int i))
    | RWSum (i, j) -> MSum (convert_param i, convert_param j)
    | RWDiff (i, j) -> MDiff (convert_param i, convert_param j)
    | RWProduct (i, j) -> MProduct (convert_param i, convert_param j)
    | RWQuotient (i, j) -> MQuotient (convert_param i, convert_param j)
    | RWRem (i, j) -> MRem (convert_param i, convert_param j)
    | RWLessThan (i, j) -> MLessThan (convert_param i, convert_param j)
    | RWEqual (i, j) -> MEqual (convert_param i, convert_param j)
    | RWNotEqual (i, j) -> MNotEqual (convert_param i, convert_param j)
    | RWObId id -> ObId id
    | RWParamList l -> ParamList (List.map convert_param l)
   and convert_param p =
      make_param (convert_param' p)

   let rewrite_operator = function
      { rr_redex = (RWComposite { rw_op = { rw_name = name; rw_params = params } })::_ } ->
           mk_op name (List.map convert_param params)
    | _ -> ref_raise(RefineError ("rewrite_operator", RewriteNoRuleOperator))

   (*
    * Get the arities of the subterms.
    *)
   let bterm_eval_flags = function
      { rw_bvars = bvars; rw_bterm = bterm } ->
         bvars, (if bvars = 0 then
                     match bterm with
                        RWSOVar _ -> true
                      | _ -> false
                  else
                     false)

   let rewrite_eval_flags = function
      { rr_redex = (RWComposite { rw_bterms = bterms })::_ } ->
         List.map bterm_eval_flags bterms
    | _ -> ref_raise(RefineError ("rewrite_eval_flags", RewriteNoRuleOperator))
end

(*
 * -*-
 * Local Variables:
 * Caml-master: "refiner.run"
 * End:
 * -*-
 *)
