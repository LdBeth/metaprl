(*
 * The refiner deals with proofs and functions on them.
 * We have the following objects in a refiner:
 *    + validation: a validation is a function on proofs
 *       for instance:
 *           f: (H, x:A, y:B, J[pair(x, y)] >> C[pair(x, y)]) -->
 *               (H, x:A, J[x] >> C[x])
 *        this declares "f" to be a validation, which is a function
 *        that takes a proof of the first sequent, and produces a
 *        proof of the second.  These validations can have
 *        arbitrary arity.
 *    + extract: an extract is a form of validation generated
 *          during proof refinement using tactics.
 *    + tactic: a tactic is a "reverse" application of a
 *      validation.  That is, given a validation f: A --> B,
 *      to produce a proof of B, all that is necessary is to
 *      produce a proof of A (modus ponens).
 *
 *    + rewrite: a rewrite can be reduced to an equivalence
 *      of terms in any context:
 *         f: A <--> B
 *      declares a rewrite that will convert an A to a B, or
 *      vice versa in any context.  This is the same as the
 *      validation:
 *         f: C:[A] <--> C:[B]
 *
 *    + cond_rewrite: conditional rewrite that requires
 *      a proof to be valid.  For instance,
 *         p: (x in A # B) --> (pair(x.1, x.2) <--> x)
 *      this rewrite can only be applied in a sequent
 *      calculus, and it means:
 *         p: (H >> x in A # B) --> (C:[pair(x.1, x.2)] <--> C:[x])
 *
 *)

open Printf
open Debug

open Term_sig
open Term_man_sig
open Term_subst_sig
open Term_addr_sig
open Term_meta_sig
open Rewrite_sig
open Refine_sig

(*
 * Show the file loading.
 *)
let _ =
   if !debug_load then
      eprintf "Loading Refine%t" eflush

let debug_refiner =
   create_debug (**)
      { debug_name = "refine";
        debug_description = "Display refinement operations";
        debug_value = false
      }

module Refine (**)
   (Term : TermSig)
   (TermMan : TermManSig
    with type term = Term.term)
   (TermSubst : TermSubstSig
    with type term = Term.term)
   (TermAddr : TermAddrSig
    with type term = Term.term)
   (TermMeta : TermMetaSig
    with type term = Term.term)
   (Rewrite : RewriteSig
    with type term = Term.term
    with type address = TermAddr.address) =
struct
   open Term
   open TermMan
   open TermSubst
   open TermAddr
   open TermMeta
   open Rewrite

   type term = Term.term
   type address = TermAddr.address
   type meta_term = TermMeta.meta_term
   type rewrite_error = Rewrite.rewrite_error

   (************************************************************************
    * ERRORS                                                               *
    ************************************************************************)

   exception FreeContextVars of string list

   (*
    * Unfortunately, we need to declare the general TacticException
    * type here, because the following combinators need to
    * collect exceptions of their subtactics.
    *)
   type refine_error_info =
      StringError of string
    | IntError of int
    | TermError of term
    | StringIntError of string * int
    | StringStringError of string * string
    | StringTermError of string * term
    | GoalError of refine_error
    | SecondError of refine_error
    | SubgoalError of int * refine_error
    | PairError of refine_error * refine_error
    | RewriteAddressError of address * refine_error
    | RewriteError of rewrite_error
    | NodeError of string * term * refine_error list
    | TermMatchError of string * term * string
    | TermPairMatchError of term * term
    | AddressError of address * term
    | MetaTermMatchError of meta_term

   and refine_error = string * refine_error_info

   exception RefineError of refine_error

   (*
    * A ML rewrite replaces a term with another,
    * no extract.
    *)
   type ml_rewrite = (string array * term list) -> term -> term

   (*
    * A condition relaces an goal with a list of subgoals,
    * and it provides a function to compute the extract.
    *)
   type ml_rule =
      { ml_rule_rewrite : (string array * term list) -> term -> term list;
        ml_rule_extract : (string array * term list) -> term list -> term * term list
      }

   (*
    * Refinements are on meta-sequents,
    * which are a restricted form of meta terms,
    * having only dependent functions format.
    *
    * Each hyp is labelled by its first argument.
    *)
   type msequent =
      { mseq_goal : term;
        mseq_hyps : term list
      }

   type 'a tactic_arg = msequent * 'a

   (************************************************************************
    * TYPES                                                                *
    ************************************************************************)

   (*
    * A proof has either been computed,
    * or the computation is delayed.
    *)
   type 'a proof =
      Extracted of 'a
    | Delayed of (unit -> 'a)

   (*
    * An extract summarizes a validation that is generated by a tactic.
    *
    * The extract type is a tree of terms.  The substitution is
    * delayed, since in most cases the extract term is never
    * computed.
    *
    * The refiner describes the rule that was applied, and
    * in most cases we also list the params to the rule that
    * was applied so that the validation can be called if
    * necessary.  The head rule of the refiner is the applied
    * rule.
    *)
   type extract =
      { ext_goal : msequent;
        ext_just : ext_just;
        ext_subgoals : msequent list
      }

   and ext_just =
      SingleJust of single_just
    | PairJust of ext_just * ext_just
    | ComposeJust of ext_just * ext_just list
    | NthHypJust of int

   and single_just =
      { (* Parameters to the rule and the rule itself *)
         ext_names : string array;
         ext_params : term list;
         ext_refiner : refiner
      }

   (*
    * A refiner contains the following items:
    *    + theorems: terms that are true in a sequent calculus
    *    + rules: implications on proofs
    *    + rewrite: term equivalences in any context
    *    + ml versions of the above
    *
    * refiners can be combined using PairRefiner.
    *)
   and refiner =
      NullRefiner

    | AxiomRefiner of axiom_refiner
    | PrimAxiomRefiner of prim_axiom_refiner

    | RuleRefiner of rule_refiner
    | PrimRuleRefiner of prim_rule_refiner
    | MLRuleRefiner of ml_rule_refiner

    | RewriteRefiner of rewrite_refiner
    | PrimRewriteRefiner of prim_rewrite_refiner

    | CondRewriteRefiner of cond_rewrite_refiner
    | PrimCondRewriteRefiner of prim_cond_rewrite_refiner
    | MLRewriteRefiner of ml_rewrite_refiner

    | PairRefiner of refiner * refiner
    | LabelRefiner of string * refiner

   and axiom_refiner =
      { axiom_name : string;
        axiom_term : term;
        axiom_refiner : refiner
      }
   and prim_axiom_refiner =
      { mutable pax_proof : term proof;
        pax_axiom : axiom_refiner;
        pax_refiner : refiner
      }

   and rule_refiner =
      { rule_name : string;
        rule_count : int;
        rule_rule : msequent;
        rule_refiner : refiner
      }
   and prim_rule_refiner =
      { mutable prule_proof : (string array -> term list -> term list -> term) proof;
        prule_rule : rule_refiner;
        prule_refiner : refiner
      }
   and ml_rule_refiner =
      { ml_rule_arg : term;
        ml_rule_rule : ml_rule;
        ml_rule_refiner : refiner
      }

   and rewrite_refiner =
      { rw_name : string;
        rw_rewrite : term * term;
        rw_refiner : refiner
      }
   and prim_rewrite_refiner =
      { mutable prw_proof : unit proof;
        prw_rewrite : rewrite_refiner;
        prw_refiner : refiner
      }

   and cond_rewrite_refiner =
      { crw_name : string;
        crw_count : int;
        crw_rewrite : term list * term * term;
        crw_refiner : refiner
      }
   and prim_cond_rewrite_refiner =
      { mutable pcrw_proof : unit proof;
        pcrw_rewrite : cond_rewrite_refiner;
        pcrw_refiner : refiner
      }
   and ml_rewrite_refiner =
      { ml_rw_name : string;
        ml_rw_rewrite : ml_rewrite;
        ml_rw_refiner : refiner
      }

   (*
    * A hashtable is constructed for looking up justifications.
    *)
   type hash =
      { hash_rewrite : (string, prim_rewrite_refiner) Hashtbl.t;
        hash_cond_rewrite : (string, prim_cond_rewrite_refiner) Hashtbl.t;
        hash_axiom : (string, prim_axiom_refiner) Hashtbl.t;
        hash_rule : (string, prim_rule_refiner) Hashtbl.t
      }

   type find =
      { find_rewrite : string -> prim_rewrite_refiner;
        find_cond_rewrite : string -> prim_cond_rewrite_refiner;
        find_axiom : string -> prim_axiom_refiner;
        find_rule : string -> prim_rule_refiner
      }

   type check =
      { check_rewrite : rewrite_refiner -> prim_rewrite_refiner;
        check_cond_rewrite : cond_rewrite_refiner -> prim_cond_rewrite_refiner;
        check_axiom : axiom_refiner -> prim_axiom_refiner;
        check_rule : rule_refiner -> prim_rule_refiner
      }

   (*
    * The safe_tactic type is the basic refinement type, and every
    * element of safe_tactic always produces "correct" refinements
    * by construction.  In other words, only primitive rules can
    * be directly injected into the safe_tactic type, and all else is
    * by composition.
    *
    * Note: the first argument should really be type msequent,
    * but it is more efficient to use ('a msequent) because
    * the coercion ('a msequent -> msequent) costs a needless
    * memory allocation.
    *)
   and tactic = msequent -> msequent list * ext_just

   (*
    * A rewrite replaces a term with another term.
    *)
   and rw = term -> term * refiner

   (*
    * A conditional rewrite takes a goal, then applies the rewrite
    * and generates subgoals.  The first argument is the sequent
    * the rewrite is being applied to, and the second is the
    * particular subterm to be rewritted.
    *)
   and cond_rewrite = term -> term -> term * term list * ext_just

   (*
    * These are the forms created at compile time.
    *)
   and prim_tactic = address array * string array -> term list -> tactic
   and prim_rewrite = rw
   and prim_cond_rewrite = string array * term list -> cond_rewrite

   (*
    * For destruction.
    *)
   type refiner_item =
      RIAxiom of ri_axiom
    | RIRule of ri_rule
    | RIPrimTheorem of ri_prim_theorem
    | RIMLRule of ri_ml_rule

    | RIRewrite of ri_rewrite
    | RICondRewrite of ri_cond_rewrite
    | RIPrimRewrite of ri_prim_rewrite
    | RIMLRewrite of ri_ml_rewrite

    | RIParent of refiner
    | RILabel of string

   and ri_axiom =
      { ri_axiom_name : string;
        ri_axiom_term : term
      }
   and ri_rule =
      { ri_rule_name : string;
        ri_rule_rule : msequent
      }
   and ri_ml_rule =
      { ri_ml_rule_arg : term }
   and ri_prim_theorem =
      { ri_pthm_axiom : refiner }

   and ri_rewrite =
      { ri_rw_name : string;
        ri_rw_redex : term;
        ri_rw_contractum : term
      }
   and ri_cond_rewrite =
      { ri_crw_name : string;
        ri_crw_conds : term list;
        ri_crw_redex : term;
        ri_crw_contractum : term
      }
   and ri_prim_rewrite =
      { ri_prw_rewrite : refiner }
   and ri_ml_rewrite =
      { ri_ml_rw_name : string }

   (************************************************************************
    * SEQUENT OPERATIONS                                                   *
    ************************************************************************)

    (*
     * Check that all the hyps in the list are equal.
     *)
   let equal_hyps hyps t =
      let check hyps' =
         List.for_all2 alpha_equal hyps' hyps
      in
         List.for_all check t

   (*
    * Compare two sequents for alpha eqivalence.
    *)
   let msequent_alpha_equal seq1 seq2 =
      if seq1 == seq2 then
         (* This is the common case *)
         true
      else
         let { mseq_goal = goal1; mseq_hyps = hyps1 } = seq1 in
         let { mseq_goal = goal2; mseq_hyps = hyps2 } = seq2 in
         let rec compare = function
            hyp1::hyps1, hyp2::hyps2 ->
               alpha_equal hyp1 hyp2 & compare (hyps1, hyps2)
          | [], [] ->
               true
          | _ ->
               false
         in
            alpha_equal goal1 goal2 & compare (hyps1, hyps2)

   (*
    * Split the goals from the hyps.
    *)
   let rec split_msequent_list = function
      { mseq_goal = goal; mseq_hyps = hyps }::t ->
         let goals, hypsl = split_msequent_list t in
            goal :: goals, hyps :: hypsl
    | [] ->
         [], []

   (************************************************************************
    * TACTICS                                                              *
    ************************************************************************)

   (*
    * Refinement is just application.
    * The application is doubled: the first argument is
    * for type tactic, and the second is for type safe_tactic.
    *)
   let refine (tac : tactic) (seq : msequent) =
      let subgoals, just = tac seq in
         subgoals, { ext_goal = seq; ext_just = just; ext_subgoals = subgoals }

   (*
    * NTH_HYP
    * The base tactic proves by assumption.
    *)
   let nth_hyp i seq =
      let { mseq_goal = goal; mseq_hyps = hyps } = seq in
         try
            if alpha_equal (List.nth hyps i) goal then
               [], NthHypJust i
            else
               raise (RefineError ("nth_hyp", StringError "hyp mismatch"))
         with
            Failure "nth" ->
               raise (RefineError ("nth_hyp", IntError i))

   (*
    * COMPOSE
    * Compose two extracts.
    * The subgoals of the first must match with the goals of the second.
    *)
   let compose ext extl =
      let { ext_goal = goal; ext_just = just; ext_subgoals = subgoals } = ext in
      let subgoals' = List.map (fun ext -> ext.ext_goal) extl in
      let _ =
         if not (List_util.for_all2 msequent_alpha_equal subgoals subgoals') then
            raise (RefineError ("compose", StringError "goal mistmatch"))
      in
      let justl = List.map (fun ext -> ext.ext_just) extl in
      let just = ComposeJust (just, justl) in
      let subgoals'' = List_util.flat_map (fun ext -> ext.ext_subgoals) extl in
         { ext_goal = goal; ext_just = just; ext_subgoals = subgoals }

   (************************************************************************
    * REGULAR REWRITES                                                     *
    ************************************************************************)

   (*
    * Convert a rewrite to a tactic.
    *)
   let rwtactic (rw : rw) (seq : msequent) =
      let { mseq_goal = goal; mseq_hyps = hyps } = seq in
      let goal, refiner = rw goal in
         [{ mseq_goal = goal; mseq_hyps = hyps }],
         SingleJust { ext_names = [||]; ext_params = []; ext_refiner = refiner }

   (*
    * Apply a rewrite at an address.
    *)
   let rwaddr addr rw t =
      try apply_fun_arg_at_addr rw addr t with
         RefineError x ->
            raise (RefineError ("rwaddr", RewriteAddressError (addr, x)))

   (*
    * Composition is supplied for efficiency.
    *)
   let andthenrw rw1 rw2 t =
      let t', refiner =
         try rw1 t with
            RefineError x ->
               raise (RefineError ("andthenrw", GoalError x))
      in
      let t'', refiner' =
         try rw2 t' with
            RefineError x ->
               raise (RefineError ("andthenrw", SecondError x))
      in
         t'', PairRefiner (refiner, refiner')

   let orelserw rw1 rw2 t =
      try rw1 t with
         RefineError x ->
            try rw2 t with
               RefineError y ->
                  raise (RefineError ("orelserw", PairError (x, y)))

   (************************************************************************
    * CONDITIONAL REWRITES                                                 *
    ************************************************************************)

   (*
    * Inject a regular rewrite as a conditional rewrite.
    *)
   let mk_cond_rewrite rw seq t =
      let arg, refiner = rw t in
         arg, [], SingleJust { ext_names = [||]; ext_params = []; ext_refiner = refiner }

   (*
    * Apply the rewrite to an addressed term.
    *)
   let crwaddr addr crw seq t =
      try
         let t, (subgoals, just) =
            let f t =
               let t, subgoals, just = crw seq t in
                  t, (subgoals, just)
            in
               apply_fun_arg_at_addr f addr t
         in
            t, subgoals, just
      with
         RefineError x ->
            raise (RefineError ("crwaddr", RewriteAddressError (addr, x)))

   (*
    * Apply a conditional rewrite.
    *)
   let crwtactic (rw : cond_rewrite) (seq : msequent) =
      let { mseq_goal = goal; mseq_hyps = hyps } = seq in
      let t', subgoals, just = rw goal goal in
      let mk_subgoal subgoal =
         { mseq_goal = subgoal; mseq_hyps = hyps }
      in
      let subgoals' = List.map mk_subgoal (t' :: subgoals) in
         subgoals', just

   (*
    * Composition is supplied for efficiency.
    *)
   let candthenrw crw1 crw2 seq t =
      let t', subgoals, just =
         try crw1 seq t with
            RefineError x ->
               raise (RefineError ("candthenrw", GoalError x))
      in
      let t'', subgoals', just' =
         try crw2 seq t' with
            RefineError x ->
               raise (RefineError ("candthenrw", SecondError x))
      in
         t'', subgoals @ subgoals', PairJust (just, just')

   let corelserw crw1 crw2 seq t =
      try crw1 seq t with
         RefineError x ->
            try crw2 seq t with
               RefineError y ->
                  raise (RefineError ("corelserw", PairError (x, y)))

   (************************************************************************
    * UTILITIES                                                            *
    ************************************************************************)

   (*
    * Empty refiner.
    *)
   let null_refiner = NullRefiner

   (*
    * Combine the refiners into a single refiner.
    *)
   let join_refiner ref1 ref2 =
      ref1 := PairRefiner (ref2, !ref1)

   (*
    * Label a refiner with the name of the module.
    *)
   let label_refiner ref1 name =
      ref1 := LabelRefiner (name, !ref1)

   (*
    * Search for an axiom by name.
    *)
   let find_refiner refiner name =
      let rec search refiners refiner =
         if List.memq refiner refiners then
            raise Not_found;
         let refiners = refiner :: refiners in
            match refiner with
               NullRefiner ->
                  raise Not_found
             | AxiomRefiner { axiom_name = n; axiom_refiner = next } as r ->
                  if n = name then
                     r
                  else
                     search refiners next
             | PrimAxiomRefiner { pax_refiner = next } ->
                  search refiners next

             | RuleRefiner { rule_name = n; rule_refiner = next } as r ->
                  if n = name then
                     r
                  else
                     search refiners next
             | PrimRuleRefiner { prule_refiner = next } ->
                  search refiners next
             | MLRuleRefiner { ml_rule_refiner = next } ->
                  search refiners next

             | RewriteRefiner { rw_name = n; rw_refiner = next } as r ->
                  if n = name then
                     r
                  else
                     search refiners next
             | PrimRewriteRefiner { prw_refiner = next } ->
                  search refiners next

             | CondRewriteRefiner { crw_name = n; crw_refiner = next } as r ->
                  if n = name then
                     r
                  else
                     search refiners next
             | PrimCondRewriteRefiner { pcrw_refiner = next } ->
                  search refiners next
             | MLRewriteRefiner { ml_rw_name = n; ml_rw_refiner = next } as r ->
                  if n = name then
                     raise (RefineError (n, StringError "ML rewrites can't be justified"))
                  else
                     search refiners next

             | LabelRefiner (_, next) ->
                  search refiners next
             | PairRefiner (next1, next2) ->
                  try search refiners next1 with
                     Not_found ->
                        search refiners next2
      in
         search [] refiner

   (************************************************************************
    * EXTRACTION                                                           *
    ************************************************************************)

   (*
    * When an term is calculated from an extract, we have to search
    * for the justifications in the current refiner.  We save them
    * in a hashtable by their names and their types.
    *)
   let hash_refiner refiner =
      let rewrites = Hashtbl.create 19 in
      let cond_rewrites = Hashtbl.create 19 in
      let axioms = Hashtbl.create 19 in
      let rules = Hashtbl.create 19 in
      let maybe_add hash name info =
         try Hashtbl.find hash name; () with
            Not_found ->
               Hashtbl.add hash name info
      in
      let rec insert = function
         PrimAxiomRefiner pax ->
            let { pax_axiom = { axiom_name = name }; pax_refiner = next } = pax in
               maybe_add axioms name pax;
               insert next
       | PrimRuleRefiner prule ->
            let { prule_rule = { rule_name = name }; prule_refiner = next } = prule in
               maybe_add rules name prule;
               insert next
       | PrimRewriteRefiner prw ->
            let { prw_rewrite = { rw_name = name }; prw_refiner = next  } = prw in
               maybe_add rewrites name prw;
               insert next
       | PrimCondRewriteRefiner pcrw ->
            let { pcrw_rewrite = { crw_name = name }; pcrw_refiner = next  } = pcrw in
               maybe_add cond_rewrites name pcrw;
               insert next
       | AxiomRefiner { axiom_refiner = next } ->
            insert next
       | RuleRefiner { rule_refiner = next } ->
            insert next
       | RewriteRefiner { rw_refiner = next } ->
            insert next
       | CondRewriteRefiner { crw_refiner = next } ->
            insert next
       | MLRewriteRefiner { ml_rw_refiner = next } ->
            insert next
       | MLRuleRefiner { ml_rule_refiner = next } ->
            insert next
       | LabelRefiner (_, next) ->
            insert next
       | PairRefiner (next1, next2) ->
            insert next1;
            insert next2
       | NullRefiner ->
            ()
      in
      let _ = insert refiner in
         { hash_axiom = axioms;
           hash_rule = rules;
           hash_rewrite = rewrites;
           hash_cond_rewrite = cond_rewrites
         }

   (*
    * Lookup values in the hashtable, or print error messages.
    *)
   let find_of_hash { hash_axiom = axioms;
                      hash_rule = rules;
                      hash_rewrite = rewrites;
                      hash_cond_rewrite = cond_rewrites
       } =
      let find_axiom name =
         try Hashtbl.find axioms name with
            Not_found ->
               raise (RefineError (name, StringError "axiom is not justified"))
      in
      let find_rule name =
         try Hashtbl.find rules name with
            Not_found ->
               raise (RefineError (name, StringError "rule is not justified"))
      in
      let find_rewrite name =
         try Hashtbl.find rewrites name with
            Not_found ->
               raise (RefineError (name, StringError "rewrite is not justified"))
      in
      let find_cond_rewrite name =
         try Hashtbl.find cond_rewrites name with
            Not_found ->
               raise (RefineError (name, StringError "cond_rewrite is not justified"))
      in
         { find_axiom = find_axiom;
           find_rule = find_rule;
           find_rewrite = find_rewrite;
           find_cond_rewrite = find_cond_rewrite
         }

   (*
    * Also check the matching.
    *)
   let check_of_find { find_axiom = find_axiom;
                       find_rule = find_rule;
                       find_rewrite = find_rewrite;
                       find_cond_rewrite = find_cond_rewrite
       } =
      let check_axiom ax =
         let { axiom_name = name } = ax in
         let pax = find_axiom name in
            if pax.pax_axiom == ax then
               pax
            else
               raise (RefineError (name, StringError "axiom proof does not match"))
      in
      let check_rule rule =
         let { rule_name = name } = rule in
         let prule = find_rule name in
            if prule.prule_rule == rule then
               prule
            else
               raise (RefineError (name, StringError "rule proof does not match"))
      in
      let check_rewrite rw =
         let { rw_name = name } = rw in
         let prw = find_rewrite name in
            if prw.prw_rewrite == rw then
               prw
            else
               raise (RefineError (name, StringError "rewrite proof does not match"))
      in
      let check_cond_rewrite crw =
         let { crw_name = name } = crw in
         let pcrw = find_cond_rewrite name in
            if pcrw.pcrw_rewrite == crw then
               pcrw
            else
               raise (RefineError (name, StringError "cond_rewrite proof does not match"))
      in
         { check_axiom = check_axiom;
           check_rule = check_rule;
           check_rewrite = check_rewrite;
           check_cond_rewrite = check_cond_rewrite
         }

   (*
    * Get the extract term for an axiom.
    *)
   let axiom_proof pax =
      match pax.pax_proof with
         Extracted t ->
            t
       | Delayed f ->
            let t = f () in
               pax.pax_proof <- Extracted t;
               t

   let rule_proof prule =
      match prule.prule_proof with
         Extracted t ->
            t
       | Delayed f ->
            let t = f () in
               prule.prule_proof <- Extracted t;
               t

   let rewrite_proof prw =
      match prw.prw_proof with
         Extracted () ->
            ()
       | Delayed f ->
            prw.prw_proof <- Extracted (f ())

   let cond_rewrite_proof pcrw =
      match pcrw.pcrw_proof with
         Extracted () ->
            ()
       | Delayed f ->
            pcrw.pcrw_proof <- Extracted (f ())

   (*
    * Expand the extracts of the components.
    *)
   let check = function
      PrimAxiomRefiner pax ->
         axiom_proof pax;
         ()
    | PrimRuleRefiner prule ->
         let _ = rule_proof prule in
            ()
    | PrimRewriteRefiner prw ->
         rewrite_proof prw;
         ()
    | PrimCondRewriteRefiner pcrw ->
         cond_rewrite_proof pcrw;
         ()
    | _ ->
         ()

   (*
    * Get the term from an extract.
    * This will fail if some of the rules are not justified.
    *)
   let term_of_extract refiner { ext_just = just } (args : term list) =
      let { check_axiom = find_axiom;
            check_rule = find_rule;
            check_rewrite = find_rewrite;
            check_cond_rewrite = find_cond_rewrite
          } = check_of_find (find_of_hash (hash_refiner refiner))
      in
      let split_first = function
         h::t ->
            h, t
       | [] ->
            raise (Failure "Refine.term_of_extract: extract list is empty")
      in
      let split_list i l =
         try List_util.split_list i l with
            Failure _ ->
               raise (Failure "Refine.term_of_extract: extract list too short")
      in
      let nth_tl i l =
         try List_util.nth_tl i l with
            Failure _ ->
               raise (Failure "Refine.term_of_extract: extract list too short")
      in
      let rec construct extracts = function
         SingleJust { ext_names = names; ext_params = params; ext_refiner = refiner } ->
            begin
               match refiner with
                  AxiomRefiner ax ->
                     axiom_proof (find_axiom ax), extracts
                | RuleRefiner rule ->
                     let { rule_count = count } = rule in
                     let hd, tl = split_list count extracts in
                        rule_proof (find_rule rule) names params hd, tl
                | MLRuleRefiner { ml_rule_rule = { ml_rule_extract = f } } ->
                     f (names, params) extracts
                | RewriteRefiner rw ->
                     find_rewrite rw;
                     split_first extracts
                | CondRewriteRefiner crw ->
                     let { crw_count = count } = crw in
                     let hd, tl = split_first extracts in
                        find_cond_rewrite crw;
                        hd, nth_tl count tl
                | MLRewriteRefiner _ ->
                     split_first extracts
                | _ ->
                     raise (Failure "Refine.term_of_extract: refine error")
            end
       | PairJust (just1, just2) ->
            let extract, extracts = construct extracts just2 in
               construct (extract :: extracts) just1
       | ComposeJust (just, justl) ->
            let rec collect extracts = function
               just :: justl ->
                  let extract, extracts = construct extracts just in
                     extract :: collect extracts justl
             | [] ->
                  extracts
            in
               construct (collect extracts justl) just
       | NthHypJust i ->
            List.nth args i, extracts
      in
         fst (construct [] just)

   (************************************************************************
    * AXIOM                                                                *
    ************************************************************************)

   (*
    * We wrap the rewrite to map the exceptions.
    *)
   let apply_rewrite name rw addrs_names terms =
      try Rewrite.apply_rewrite rw addrs_names terms with
         Rewrite.RewriteError error ->
            raise (RefineError (name, RewriteError error))
       | Term.TermMatch (s1, t, s2) ->
            raise (RefineError (name, TermMatchError (s1, t, s2)))
       | Term.BadMatch (t1, t2) ->
            raise (RefineError (name, TermPairMatchError (t1, t2)))
       | TermAddr.IncorrectAddress (addr, t) ->
            raise (RefineError (name, AddressError (addr, t)))
       | TermMeta.MetaTermMatch t ->
            raise (RefineError (name, MetaTermMatchError t))

   (*
    * An theorem is a special case of a rule, where to
    * arity is 1, and there are no addrs or params.
    * Still get a tactic by this name (the equivalent
    * of BackThruLemma `name`).
    *)
   let check_axiom term =
      match TermSubst.context_vars term with
         [] ->
            true
       | l ->
            raise (FreeContextVars l)

   let add_axiom refiner name term =
      if !debug_refiner then
         eprintf "Refiner.add_axiom: %s%t" name eflush;
      let refiner' =
         AxiomRefiner { axiom_name = name;
                        axiom_term = term;
                        axiom_refiner = refiner
         }
      in
      let tac _ _ { mseq_goal = goal; mseq_hyps = hyps } =
         if alpha_equal (nth_concl goal 0) term then
            [], SingleJust { ext_names = [||]; ext_params = []; ext_refiner = refiner' }
         else
            raise (Term.TermMatch ("refine_axiom", goal, name))
      in
         check_axiom term;
         refiner', tac

   let add_prim_axiom refiner name term =
      if !debug_refiner then
         eprintf "Refiner.prim_axiom: %s%t" name eflush;
      match find_refiner refiner name with
         AxiomRefiner ax ->
            PrimAxiomRefiner { pax_proof = Extracted term;
                               pax_axiom = ax;
                               pax_refiner = refiner
            }
       | _ ->
            raise (RefineError (name, StringError "not an axiom"))

   let add_delayed_axiom refiner name extf =
      if !debug_refiner then
         eprintf "Refiner.delayed_axiom: %s%t" name eflush;
      match find_refiner refiner name with
         AxiomRefiner ax ->
            let compute () =
               let { axiom_term = goal } = ax in
               let ext = extf () in
               let { ext_goal = { mseq_goal = goal' }; ext_subgoals = subgoals } = ext in
                  if not (alpha_equal (nth_concl goal' 0) goal) or subgoals != [] then
                     raise (RefineError (name, StringError "not justified"));
                  term_of_extract refiner ext []
            in
               PrimAxiomRefiner { pax_proof = Delayed compute;
                                  pax_axiom = ax;
                                  pax_refiner = refiner
               }
       | _ ->
            raise (RefineError (name, StringError "not an axiom"))

   (************************************************************************
    * RULE                                                                 *
    ************************************************************************)

   (*
    * Create a rule from a meta-term.
    * We allow first-order rules (T -> ... -> T)
    * where each T must be a term, and the arity is arbitrary,
    * and there are no dependencies.
    *)
   let add_rule refiner name addrs names params mterm =
      if !debug_refiner then
         eprintf "Refiner.add_rule: %s%t" name eflush;
      let terms = unzip_mimplies mterm in
      let subgoals, goal = List_util.split_last terms in
      let seq = { mseq_goal = goal; mseq_hyps = subgoals } in
      let rw =
         try Rewrite.term_rewrite (addrs, names) (goal :: params) subgoals with
            Rewrite.RewriteError error ->
               raise (RefineError (name, RewriteError error))
      in
      let refiner' =
         RuleRefiner { rule_name = name;
                       rule_count = List.length subgoals;
                       rule_rule = seq;
                       rule_refiner = refiner
         }
      in
      let tac addrs_names params { mseq_goal = goal; mseq_hyps = hyps } =
         let subgoals, names' = apply_rewrite name rw addrs_names (goal :: params) in
         let make_subgoal subgoal =
            { mseq_goal = subgoal; mseq_hyps = hyps }
         in
         let just =
            SingleJust { ext_names = names';
                         ext_params = params;
                         ext_refiner = refiner'
            }
         in
            List.map make_subgoal subgoals, just
      in
         refiner', tac

   (*
    * Theorem for a previous theorem or rule.
    * We once again use the rewriter to compute the
    * extract.  The subextracts are shaped into a
    * term of the form:
    *    lambda(a. lambda(b. ... cons(arg1; cons(arg2; ... cons(argn, nil)))))
    *)
   let compute_rule_ext name vars params args result =
      (* Create redex term *)
      let l = Array.length vars in
      let create_redex vars args =
         let args' = mk_xlist_term args in
         let rec aux j =
            if j < l then
               mk_xlambda_term vars.(j) (aux (j + 1))
            else
               args'
         in
            aux 0
      in
      let rw =
         try Rewrite.term_rewrite ([||], [||]) (create_redex vars args :: params) [result] with
            Rewrite.RewriteError error ->
               raise (RefineError (name, RewriteError error))
      in
      let compute_ext vars params args =
         match apply_rewrite name rw ([||], [||]) (create_redex vars args :: params) with
            [c], x when Array.length x = 0 ->
               c
          | _ ->
               raise (Failure "Refine.add_prim_theorem.compute_ext: faulty extract")
      in
         compute_ext

   let add_prim_rule refiner name vars params args result =
      if !debug_refiner then
         eprintf "Refiner.add_prim_theorem: %s%t" name eflush;
      match find_refiner refiner name with
         RuleRefiner rule ->
            let compute_ext = compute_rule_ext name vars params args result in
               PrimRuleRefiner { prule_proof = Extracted compute_ext;
                                 prule_rule = rule;
                                 prule_refiner = refiner
               }
       | _ ->
            raise (RefineError (name, StringError "not a rule"))

   let add_delayed_rule refiner name vars params args ext =
      if !debug_refiner then
         eprintf "Refiner.delayed_rule: %s%t" name eflush;
      match find_refiner refiner name with
         RuleRefiner rule ->
            let compute_ext () =
               let ext = ext () in
               let { rule_rule = goal } = rule in
               let { ext_goal = goal'; ext_subgoals = subgoals } = ext in
               let _ =
                  if not (msequent_alpha_equal goal' goal) or subgoals <> [] then
                     raise (RefineError (name, StringError "extract does not match"))
               in
               let t = term_of_extract refiner ext args in
                  compute_rule_ext name vars params args t
            in
               PrimRuleRefiner { prule_proof = Delayed compute_ext;
                                 prule_rule = rule;
                                 prule_refiner = refiner
               }
       | _ ->
            raise (RefineError (name, StringError "not a rule"))

   (*
    * An ML condition.
    *)
   let add_ml_rule refiner arg rule =
      if !debug_refiner then
         eprintf "Refiner.add_ml_rule%t" eflush;
      let refiner' =
         MLRuleRefiner { ml_rule_arg = arg;
                         ml_rule_rule = rule;
                         ml_rule_refiner = refiner
         }
      in
      let { ml_rule_rewrite = rw } = rule in
      let tac (_, names) params { mseq_goal = goal; mseq_hyps = hyps } =
         let subgoals = rw (names, params) goal in
         let make_subgoal subgoal =
            { mseq_goal = subgoal; mseq_hyps = hyps }
         in
         let just =
            SingleJust { ext_names = names;
                         ext_params = params;
                         ext_refiner = refiner'
            }
         in
            List.map make_subgoal subgoals, just
      in
         refiner', tac

   (*
    * Just do the checking.
    *)
   let check_rule name addrs names params mterm =
      let terms = unzip_mimplies mterm in
      let subgoals, goal = List_util.split_last terms in
      let rw =
         try Rewrite.term_rewrite (addrs, names) (goal::params) subgoals with
            Rewrite.RewriteError error ->
               raise (RefineError (name, RewriteError error))
      in
         true

   (************************************************************************
    * REWRITE                                                              *
    ************************************************************************)

   (*
    * See if the rewrite will compile.
    *)
   let check_rewrite name vars params subgoals redex contractum =
      let rw =
         try Rewrite.term_rewrite ([||], vars) (redex::params) [contractum] with
            Rewrite.RewriteError error ->
               raise (RefineError (name, RewriteError error))
      in
         true

   (*
    * Create a simple rewrite from a meta-term.
    * The rewrite must be a MetaIff.
    *)
   let add_rewrite refiner name redex contractum =
      if !debug_refiner then
         eprintf "Refiner.add_rewrite: %s%t" name eflush;
      let rw =
         try Rewrite.term_rewrite ([||], [||]) [redex] [contractum] with
            Rewrite.RewriteError error ->
               raise (RefineError (name, RewriteError error))
      in
      let refiner' =
         RewriteRefiner { rw_name = name;
                          rw_rewrite = redex, contractum;
                          rw_refiner = refiner
         }
      in
      let rw t =
         match apply_rewrite name rw ([||], [||]) [t] with
            [t'], _ ->
               t', refiner'
          | [], _ ->
               raise (Failure "Refine.add_rewrite: no contracta")
          | _ ->
               raise (Failure "Refine.add_Rewrite: multiple contracta")
      in
         refiner', rw

   let add_prim_rewrite refiner name redex contractum =
      if !debug_refiner then
         eprintf "Refiner.add_prim_rewrite: %s%t" name eflush;
      match find_refiner refiner name with
         RewriteRefiner rw ->
            let { rw_rewrite = redex', contractum' } = rw in
            let term1 = mk_xlist_term [redex; contractum] in
            let term2 = mk_xlist_term [redex'; contractum'] in
               if alpha_equal term1 term2 then
                  PrimRewriteRefiner { prw_rewrite = rw;
                                       prw_refiner = refiner;
                                       prw_proof = Extracted ()
                  }
               else
                  raise (RefineError (name, StringError "not a rewrite"))
       | _ ->
            raise (RefineError (name, StringError "not a rewrite"))

   let add_delayed_rewrite refiner name redex contractum ext =
      if !debug_refiner then
         eprintf "Refiner.add_delayed_rewrite: %s%t" name eflush;
      match find_refiner refiner name with
         RewriteRefiner rw ->
            let compute_ext () =
               let { rw_rewrite = redex, contractum } = rw in
               let ext = ext () in
               let { ext_goal = goal; ext_subgoals = subgoals } = ext in
               let t =
                  match goal, subgoals with
                     { mseq_goal = goal; mseq_hyps = [] },
                     [{ mseq_goal = subgoal; mseq_hyps = [] }] ->
                        if alpha_equal goal redex & alpha_equal subgoal contractum then
                           term_of_extract refiner ext []
                        else
                           raise (RefineError (name, StringError "extract does not match"))
                   | _ ->
                        raise (RefineError (name, StringError "bogus proof"))
               in
                  ()
            in
               PrimRewriteRefiner { prw_proof = Delayed compute_ext;
                                    prw_rewrite = rw;
                                    prw_refiner = refiner
               }
       | _ ->
            raise (RefineError (name, StringError "not a rewrite"))

   (************************************************************************
    * CONDITIONAL REWRITE                                                  *
    ************************************************************************)

   (*
    * Conditional rewrite.
    *)
   let add_cond_rewrite refiner name vars params subgoals redex contractum =
      if !debug_refiner then
         eprintf "Refiner.add_cond_rewrite: %s%t" name eflush;
      let rw =
         try Rewrite.term_rewrite ([||], vars) (redex::params) [contractum] with
            Rewrite.RewriteError error ->
               raise (RefineError (name, RewriteError error))
      in
      let refiner' =
         CondRewriteRefiner { crw_name = name;
                              crw_count = List.length subgoals;
                              crw_rewrite = subgoals, redex, contractum;
                              crw_refiner = refiner
         }
      in
      let rw' (vars, params) seq t =
         (* BUG: is alpha variance compute correctly by replace_goal? *)
         let subgoals' = List.map (replace_goal seq) subgoals in
            match apply_rewrite name rw ([||], vars) (t :: params) with
               [t'], names ->
                  t',
                  subgoals',
                  SingleJust { ext_names = names;
                               ext_params = params;
                               ext_refiner = refiner'
                  }
             | [], _ ->
                  raise (Failure "Refine.add_cond_rewrite: no contracta")
             | _ ->
                  raise (Failure "Refine.add_cond_rewrite: multiple contracta")
      in
         refiner', rw'

   let add_prim_cond_rewrite refiner name vars params subgoals redex contractum =
      if !debug_refiner then
         eprintf "Refiner.add_prim_cond_rewrite: %s%t" name eflush;
      match find_refiner refiner name with
         CondRewriteRefiner crw ->
            let { crw_rewrite = subgoals', redex', contractum' } = crw in
            let term1 = mk_xlist_term (redex :: contractum :: subgoals) in
            let term2 = mk_xlist_term (redex' ::  contractum' :: subgoals') in
               if alpha_equal term1 term2 then
                  PrimCondRewriteRefiner { pcrw_proof = Extracted ();
                                           pcrw_rewrite = crw;
                                           pcrw_refiner = refiner
                  }
               else
                  raise (RefineError (name, StringError "not a conditional rewrite"))
       | _ ->
            raise (RefineError (name, StringError "not a conditional rewrite"))

   let add_delayed_cond_rewrite refiner name vars params subgoals redex contractum ext =
      if !debug_refiner then
         eprintf "Refiner.add_delayed_cond_rewrite: %s%t" name eflush;
      match find_refiner refiner name with
         CondRewriteRefiner crw ->
            let compute_ext () =
               let ext = ext () in
               let { ext_goal = goal; ext_subgoals = subgoals' } = ext in
               let { mseq_goal = goal; mseq_hyps = goal_hyps } = goal in
               let subgoals', sub_hyps = split_msequent_list subgoals' in
               let { crw_rewrite = subgoals, redex, contractum } = crw in
               let redex = replace_goal goal redex in
               let contractum = replace_goal goal contractum in
               let subgoals = List.map (replace_goal goal) subgoals in
                  if equal_hyps goal_hyps sub_hyps &
                     List_util.for_all2 alpha_equal (redex :: contractum :: subgoals) (goal :: subgoals)
                  then
                     term_of_extract refiner ext []
                  else
                     raise (RefineError (name, StringError "derivation does not match"));
                  ()
            in
               PrimCondRewriteRefiner { pcrw_proof = Delayed compute_ext;
                                        pcrw_rewrite = crw;
                                        pcrw_refiner = refiner
               }
       | _ ->
            raise (RefineError (name, StringError "not a conditional rewrite"))

   (*
    * An ML rewrite.
    *)
   let add_ml_rewrite refiner name subgoals rw =
      let refiner' =
         MLRewriteRefiner { ml_rw_name = name;
                            ml_rw_rewrite = rw;
                            ml_rw_refiner = refiner
         }
      in
      let rw' ((vars, params) as args) seq t =
         let subgoals' = List.map (replace_goal seq) subgoals in
         let t' = rw args t in
         let just = SingleJust { ext_names = vars;
                                 ext_params = params;
                                 ext_refiner = refiner'
                    }
         in
            t', subgoals', just
      in
         refiner', rw'

   (************************************************************************
    * API FUNCTIONS                                                        *
    ************************************************************************)

   (*
    * Axiom creation.
    *)
   let create_axiom refiner name term =
      let refiner', tac = add_axiom !refiner name term in
         refiner := refiner';
         (tac : prim_tactic)

   let prim_axiom refiner name term =
      refiner := add_prim_axiom !refiner name term

   let delayed_axiom refiner name extf =
      refiner := add_delayed_axiom !refiner name extf

   let derived_axiom refiner name ext =
      let extf () = ext in
      let refiner' = add_delayed_axiom !refiner name extf in
         check refiner';
         refiner := refiner'

   (*
    * Rules.
    *)
   let create_rule refiner name addrs names params mterm =
      let refiner', tac = add_rule !refiner name addrs names params mterm in
         refiner := refiner';
         tac

   let prim_rule refiner name vars params args result =
      refiner :=  add_prim_rule !refiner name vars params args result

   let delayed_rule refiner name vars params args extf =
      refiner := add_delayed_rule !refiner name vars params args extf

   let derived_rule refiner name vars params args ext =
      let extf () = ext in
      let refiner' = add_delayed_rule !refiner name vars params args extf in
         check refiner';
         refiner := refiner'

   let create_ml_rule refiner term mlr =
      let refiner', tac = add_ml_rule !refiner term mlr in
         refiner := refiner';
         tac

   (*
    * Rewrites.
    *)
   let create_rewrite refiner name redex contractum =
      let refiner', rw = add_rewrite !refiner name redex contractum in
         refiner := refiner';
         rw

   let prim_rewrite refiner name redex contractum =
      refiner := add_prim_rewrite !refiner name redex contractum

   let delayed_rewrite refiner name redex contractum extf =
      refiner := add_delayed_rewrite !refiner name redex contractum extf

   let derived_rewrite refiner name redex contractum ext =
      let extf () = ext in
      let refiner' = add_delayed_rewrite !refiner name redex contractum extf in
         check refiner';
         refiner := refiner'

   (*
    * Condiitional rewrites.
    *)
   let create_cond_rewrite refiner name vars params args redex contractum =
      let refiner', rw = add_cond_rewrite !refiner name vars params args redex contractum in
         refiner := refiner';
         rw

   let prim_cond_rewrite refiner name vars params args redex contractum =
      refiner := add_prim_cond_rewrite !refiner name vars params args redex contractum

   let delayed_cond_rewrite refiner name vars params args redex contractum extf =
      refiner := add_delayed_cond_rewrite !refiner name vars params args redex contractum extf

   let derived_cond_rewrite refiner name vars params args redex contractum ext =
      let extf () = ext in
      let refiner' = add_delayed_cond_rewrite !refiner name vars params args redex contractum extf in
         check refiner';
         refiner := refiner'

   let create_ml_rewrite refiner name subgoals rw =
      let refiner', rw' = add_ml_rewrite !refiner name subgoals rw in
         refiner := refiner';
         (rw' : prim_cond_rewrite)

   (************************************************************************
    * DESTRUCTORS                                                          *
    ************************************************************************)

   (*
    * Null refiners.
    *)
   let is_null_refiner = function
      NullRefiner -> true
    | _ -> false

   (*
    * Get the next item from a refiner.
    *)
   let dest_refiner = function
      NullRefiner ->
         raise (Invalid_argument "dest_refiner")

    | AxiomRefiner { axiom_name = n; axiom_term = t; axiom_refiner = r } ->
         RIAxiom { ri_axiom_name = n; ri_axiom_term = t }, r
    | PrimAxiomRefiner { pax_axiom = ax; pax_refiner = r } ->
         RIPrimTheorem { ri_pthm_axiom = AxiomRefiner ax }, r

    | RuleRefiner { rule_name = n; rule_rule = t; rule_refiner = r } ->
         RIRule { ri_rule_name = n; ri_rule_rule = t }, r
    | MLRuleRefiner { ml_rule_arg = cond; ml_rule_refiner = r } ->
         RIMLRule { ri_ml_rule_arg = cond }, r
    | PrimRuleRefiner { prule_rule = rule; prule_refiner = r } ->
         RIPrimTheorem { ri_pthm_axiom = RuleRefiner rule }, r

    | RewriteRefiner { rw_name = n; rw_rewrite = redex, con; rw_refiner = r } ->
         RIRewrite { ri_rw_name = n;
                     ri_rw_redex = redex;
                     ri_rw_contractum = con
         }, r
    | PrimRewriteRefiner { prw_rewrite = r1; prw_refiner = r2 } ->
         RIPrimRewrite { ri_prw_rewrite = RewriteRefiner r1 }, r2

    | CondRewriteRefiner { crw_name = n; crw_rewrite = conds, redex, con; crw_refiner = r } ->
         RICondRewrite { ri_crw_name = n;
                         ri_crw_conds = conds;
                         ri_crw_redex = redex;
                         ri_crw_contractum = con
         },
         r
    | PrimCondRewriteRefiner { pcrw_rewrite = r1; pcrw_refiner = r2 } ->
         RIPrimRewrite { ri_prw_rewrite = CondRewriteRefiner r1 }, r2
    | MLRewriteRefiner { ml_rw_name = n; ml_rw_refiner = r } ->
         RIMLRewrite { ri_ml_rw_name = n }, r

    | PairRefiner (par, r) ->
         RIParent par, r
    | LabelRefiner (name, r) ->
         RILabel name, r
end

(*
 * $Log$
 * Revision 1.5  1998/06/15 22:32:29  jyh
 * Added CZF.
 *
 * Revision 1.4  1998/06/12 13:46:54  jyh
 * D tactic works, added itt_bool.
 *
 * Revision 1.3  1998/06/03 15:23:16  jyh
 * Generalized many the term_addr, term_man, and term_shape modules.
 *
 * Revision 1.2  1998/06/01 19:53:37  jyh
 * Working addition proof.  Removing polymorphism from refiner(?)
 *
 * Revision 1.1  1998/05/28 15:00:23  jyh
 * Partitioned refiner into subdirectories.
 *
 * Revision 1.10  1998/05/27 15:13:51  jyh
 * Functorized the refiner over the Term module.
 *
 * Revision 1.9  1998/04/29 14:48:16  jyh
 * Added ocaml_sos.
 *
 * Revision 1.8  1998/04/28 18:30:40  jyh
 * ls() works, adding display.
 *
 * Revision 1.7  1998/04/24 02:42:45  jyh
 * Added more extensive debugging capabilities.
 *
 * Revision 1.6  1998/04/22 14:06:35  jyh
 * Implementing proof editor.
 *
 * Revision 1.5  1998/04/21 19:53:57  jyh
 * Upgraded refiner for program extraction.
 *
 * Revision 1.4  1998/04/17 20:48:39  jyh
 * Updating refiner for extraction.
 *
 * Revision 1.3  1997/08/07 19:43:45  jyh
 * Updated and added Lori's term modifications.
 * Need to update all pattern matchings.
 *
 * Revision 1.2  1997/08/06 16:18:12  jyh
 * This is an ocaml version with subtyping, type inference,
 * d and eqcd tactics.  It is a basic system, but not debugged.
 *
 * Revision 1.1  1997/04/28 15:51:30  jyh
 * This is the initial checkin of Nuprl-Light.
 * I am porting the editor, so it is not included
 * in this checkin.
 *
 * Directories:
 *     refiner: logic engine
 *     filter: front end to the Ocaml compiler
 *     editor: Emacs proof editor
 *     util: utilities
 *     mk: Makefile templates
 *
 * Revision 1.17  1996/09/25 22:52:00  jyh
 * Initial "tactical" commit.
 *
 * Revision 1.16  1996/05/21 02:14:04  jyh
 * This is a semi-working version before Wisconsin vacation.
 *
 * Revision 1.15  1996/04/07 18:24:49  jyh
 * This is an intermediate commit while adjusting the dforms.
 * We intend that dform printers just return a list of terms.
 *
 * Revision 1.14  1996/03/25 20:50:43  jyh
 * Intermediate commit while modifying grammer.  Restricting
 * ML hooks to condition terms.
 *
 * Revision 1.13  1996/03/11 18:34:23  jyh
 * The filterModule module is untested, but it seems to work
 * correctly on most inputs, except for mlbegin ... mlend expressions.
 * That's the next task.
 *
 * Revision 1.12  1996/03/08 15:40:48  jyh
 * This version works for most constructs except for ML rewrites.
 * The next step will be to break apart the rewriter so that
 * redices and contracta can be compiled separately.
 *
 * Revision 1.11  1996/03/05 19:48:34  jyh
 * Preliminary version with logical framework.
 *
 * Revision 1.10  1996/02/25 15:16:17  jyh
 * This is a partial checkin as filterModule is being developed.
 * After the meta-logical framework is developed, sequent.* will go away.
 *
 * Revision 1.9  1996/02/18 23:32:31  jyh
 * Changin Format module to more Nuprl-like format.
 *
 * Revision 1.8  1996/02/14 03:51:51  jyh
 * This is a version common to Caml-Light and Caml-Special-Light.
 *
 * Revision 1.7  1996/02/13 21:32:28  jyh
 * This is an intermediate checkin while matching is being added to the rewriter.
 *
 * Revision 1.6  1996/02/10 20:19:55  jyh
 * Initial checkin of filter (prlcomp).
 *
 * Revision 1.5  1996/02/08 16:02:30  jyh
 * Adding type Theory.
 *
 * Revision 1.4  1996/02/07 23:41:15  jyh
 * First working version in CamlSpecialLight.
 *
 * Revision 1.3  1996/02/07 17:34:08  jyh
 * This is Version 0 of the refiner in Caml-Light.  At this point,
 * Caml-Light becomes a branch, and main development will be
 * in Caml-Special-Light.
 *
 * Revision 1.2  1996/02/05 18:14:53  jyh
 * Merge context rewrites onto the main branch.
 *
 * Revision 1.1.4.1  1996/02/05 06:09:53  jyh
 * This version has the rewriter with contexts, and Rule application
 * in Sequent.ml, but it is not fully debugged.
 *
 * Revision 1.1  1996/01/31 20:02:39  jyh
 * Generalizing rewriter to work on Sequents.
 *
 * -*-
 * Local Variables:
 * Caml-master: "refiner.run"
 * End:
 * -*-
 *)
