(*
 * This is the simple term module, where the
 * implementation of the term mirrors the interface.
 * Destructors are identity functions.
 *)

#include "refine_error.h"

open Printf

open Debug
open Opname
open Refine_error_sig
open Term_std

(*
 * Show the file loading.
 *)
let _ =
   if !debug_load then
      eprintf "Loading Term%t" eflush

(*
 * Simple term module.
 *)
module Term (**)
#ifdef VERBOSE_EXN
   (RefineError : RefineErrorSig
    with type level_exp = TermType.level_exp
    with type param = TermType.param
    with type term = TermType.term
    with type bound_term = TermType.bound_term)
#endif VERBOSE_EXN
=
struct
   (************************************************************************
    * Type definitions                                                     *
    ************************************************************************)

   open TermType

#ifdef VERBOSE_EXN
   open RefineError
#endif VERBOSE_EXN

   type level_exp_var = TermType.level_exp_var
   type level_exp = TermType.level_exp
   type param = TermType.param
   type operator = TermType.operator
   type term = TermType.term
   type bound_term = TermType.bound_term

   type level_exp_var' = TermType.level_exp_var'
   type level_exp' = TermType.level_exp'
   type object_id = TermType.object_id
   type param' = TermType.param'
   type operator' = TermType.operator'
   type term' = TermType.term'
   type bound_term' = TermType.bound_term'

   (*
    * Simple substitution.
    *)
   type term_subst = (string * term) list

   (************************************************************************
    * DEBUGGING                                                            *
    ************************************************************************)

   (*
    * Printer is installed by client.
    *)
   let print_term = ref (fun _ _ -> raise (Failure "Term_ds.print_term: printer not installed"))

   let debug_print out t =
      !print_term out t

   let install_debug_printer f =
      print_term := f

   (************************************************************************
    * Term de/constructors                                                 *
    ************************************************************************)

   (*
    * These are basically identity functions for this implementation.
    *)
   let mk_term op bterms = { term_op = op; term_terms = bterms }

   external make_term : term' -> term = "%identity"

   external dest_term : term -> term' = "%identity"

   let mk_op name params =
      { op_name = name; op_params = params }

   external make_op : operator' -> operator = "%identity"

   external dest_op : operator -> operator' = "%identity"

   let mk_bterm bvars term = { bvars = bvars; bterm = term }

   external make_bterm : bound_term' -> bound_term = "%identity"

   external dest_bterm : bound_term -> bound_term' = "%identity"

   external make_param : param' -> param = "%identity"

   external dest_param : param -> param' = "%identity"

   let mk_level_var v i =
      { le_var = v; le_offset = i }

   external make_level_var : level_exp_var' -> level_exp_var = "%identity"

   external dest_level_var : level_exp_var -> level_exp_var' = "%identity"

   let mk_level i l =
      { le_const = i; le_vars = l }

   external make_level : level_exp' -> level_exp = "%identity"

   external dest_level : level_exp -> level_exp' = "%identity"

   external make_object_id : param list -> object_id = "%identity"

   external dest_object_id : object_id -> param list = "%identity"

   (*
    * Operator names.
    *)
   let opname_of_term = function
      { term_op = { op_name = name } } ->
         name

   (*
    * Get the subterms.
    * None of the subterms should be bound.
    *)
   let subterms_of_term t =
      List.map (fun { bterm = t } -> t) t.term_terms

   let subterm_count { term_terms = terms } =
      List.length terms

   let subterm_arities { term_terms = terms } =
      List.map (fun { bvars = vars } -> List.length vars) terms

   (************************************************************************
    * Variables                                                            *
    ************************************************************************)

   let var_opname = make_opname ["var"]

   (*
    * See if a term is a variable.
    *)
   let is_var_term = function
      { term_op = { op_name = opname; op_params = [Var v] };
        term_terms = []
      } when opname == var_opname -> true
    | _ ->
         false

   (*
    * Destructor for a variable.
    *)
   let dest_var = function
      { term_op = { op_name = opname; op_params = [Var v] };
        term_terms = []
      } when opname == var_opname -> v
    | t ->
         ref_raise(RefineError ("dest_var", TermMatchError (t, "not a variable")))

   (*
    * Make a variable.
    *)
   let mk_var_term v =
      { term_op = { op_name = var_opname; op_params = [Var v] };
        term_terms = []
      }

   let mk_var_op v = { op_name = var_opname; op_params = [Var v] }

   (*
    * Second order variables have subterms.
    *)
   let is_so_var_term = function
      ({ term_op = { op_name = opname; op_params = [Var(_)] }; term_terms = bterms } : term)
      when opname == var_opname ->
         List.for_all (function { bvars = [] } -> true | _ -> false) bterms
    | _ -> false

   let dest_so_var = function
      ({ term_op = { op_name = opname; op_params = [Var(v)] };
         term_terms = bterms
       } : term) as term when opname == var_opname ->
         v, List.map (function
            { bvars = []; bterm = t } ->
               t
          | _ ->
               ref_raise(RefineError ("dest_so_var", TermMatchError (term, "bvars exist"))))
         bterms
    | term ->
         ref_raise(RefineError ("dest_so_var", TermMatchError (term, "not a so_var")))

   (*
    * Second order variable.
    *)
   let mk_so_var_term v terms =
      let mk_bterm term =
         { bvars = []; bterm = term }
      in
         { term_op = { op_name = var_opname; op_params = [Var(v)] };
           term_terms = List.map mk_bterm terms
         }

   (*
    * Second order context, contains a context term, plus
    * binding variables like so vars.
    *)
   let context_opname = make_opname ["context"]

   let is_context_term = function
      ({ term_op = { op_name = opname; op_params = [Var _] }; term_terms = bterms } : term)
      when opname == context_opname ->
         List.for_all (function { bvars = [] } -> true | _ -> false) bterms
    | term ->
         false

   let dest_context = function
      ({ term_op = { op_name = opname; op_params = [Var v] };
         term_terms = bterms
       } : term) as term when opname == context_opname ->
         let rec collect = function
            [{ bvars = []; bterm = t }] ->
               [], t
          | { bvars = []; bterm = t } :: tl ->
               let args, term = collect tl in
                  t :: args, term
          | _ ->
               ref_raise(RefineError ("dest_context", TermMatchError (term, "bvars exist")))
         in
         let args, term = collect bterms in
            v, term, args
    | term ->
         ref_raise(RefineError ("dest_context", TermMatchError (term, "not a context")))

   let mk_context_term v term terms =
      let rec collect term = function
         [] ->
            [{ bvars = []; bterm = term }]
       | h::t ->
            { bvars = []; bterm = h } :: collect term t
      in
         { term_op = { op_name = context_opname; op_params = [Var v] };
           term_terms = collect term terms
         }

   (************************************************************************
    * Simple terms                                                         *
    ************************************************************************)

   (*
    * "Simple" terms have no parameters and no binding variables.
    *)
   let is_simple_term_opname name = function
      { term_op = { op_name = name'; op_params = [] };
        term_terms = bterms
      } when name' == name ->
         let rec aux = function
            { bvars = []; bterm = _ }::t -> aux t
          | _::t -> false
          | [] -> true
         in
            aux bterms
    | _ -> false

   let mk_any_term op terms =
      let aux t =
         { bvars = []; bterm = t }
      in
         { term_op = op; term_terms = List.map aux terms }

   let mk_simple_term name terms =
      mk_any_term { op_name = name; op_params = [] } terms

   let dest_simple_term = function
      ({ term_op = { op_name = name; op_params = [] };
         term_terms = bterms
       } : term) as t ->
         let aux = function
            { bvars = []; bterm = t } ->
               t
          | _ ->
               ref_raise(RefineError ("dest_simple_term", TermMatchError (t, "binding vars exist")))
         in
            name, List.map aux bterms
    | t ->
         ref_raise(RefineError ("dest_simple_term", TermMatchError (t, "params exist")))

   let dest_simple_term_opname name = function
      ({ term_op = { op_name = name'; op_params = [] };
         term_terms = bterms
       } : term) as t ->
         if name == name' then
            let aux = function
               { bvars = []; bterm = t } -> t
             | _ -> ref_raise(RefineError ("dest_simple_term_opname", TermMatchError (t, "binding vars exist")))
            in
               List.map aux bterms
         else
            ref_raise(RefineError ("dest_simple_term_opname", TermMatchError (t, "opname mismatch")))
    | t ->
         ref_raise(RefineError ("dest_simple_term_opname", TermMatchError (t, "params exist")))

   (*
    * Bound terms.
    *)
   let mk_simple_bterm bterm =
      { bvars = []; bterm = bterm }

   let dest_simple_bterm t = function
      { bvars = []; bterm = bterm } ->
         bterm
    | _ ->
         ref_raise(RefineError ("dest_simple_bterm", TermMatchError (t, "bterm is not simple")))
end

(*
 * $Log$
 * Revision 1.2  1998/07/02 22:25:12  jyh
 * Created term_copy module to copy and normalize terms.
 *
 * Revision 1.1  1998/07/02 18:36:31  jyh
 * Refiner modules now raise RefineError exceptions directly.
 * Modules in this revision have two versions: one that raises
 * verbose exceptions, and another that uses a generic exception.
 *
 * Revision 1.11  1998/06/22 19:45:57  jyh
 * Rewriting in contexts.  This required a change in addressing,
 * and the body of the context is the _last_ subterm, not the first.
 *
 * Revision 1.10  1998/06/15 22:53:56  nogin
 * Use == for comparing opnames
 *
 * Revision 1.9  1998/06/15 21:57:21  jyh
 * Added a few new functions.
 *
 * Revision 1.8  1998/06/12 13:47:10  jyh
 * D tactic works, added itt_bool.
 *
 * Revision 1.7  1998/06/03 22:19:37  jyh
 * Nonpolymorphic refiner.
 *
 * Revision 1.6  1998/06/03 15:23:58  jyh
 * Generalized many the term_addr, term_man, and term_shape modules.
 *
 * Revision 1.5  1998/06/02 21:52:00  nogin
 * Use == for comparing opnames
 *
 * Revision 1.4  1998/06/01 19:53:51  jyh
 * Working addition proof.  Removing polymorphism from refiner(?)
 *
 * Revision 1.3  1998/06/01 13:55:32  jyh
 * Proving twice one is two.
 *
 * Revision 1.2  1998/05/30 19:18:48  nogin
 * Eliminated white space in empty lines.
 *
 * Revision 1.1  1998/05/28 15:02:41  jyh
 * Partitioned refiner into subdirectories.
 *
 * Revision 1.1  1998/05/27 15:14:54  jyh
 * Functorized the refiner over the Term module.
 *
 *
 * -*-
 * Local Variables:
 * Caml-master: "refiner.run"
 * End:
 * -*-
 *)
