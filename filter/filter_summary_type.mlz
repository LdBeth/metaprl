(*
 * This module defines an interface for saving information about
 * modules.  We record information about each module interface,
 * to be used in the definition of the module and in submodules.
 *
 * This is just like a FileBase, but we add more structure to it.
 *
 *)

open Term
open Opname

open File_base_type

open Filter_type
open Filter_summary

(*
 * Abbreviations.
 *)
type module_name = string

type loc = int * int

(*
 * This module just provides subaddressing of its objects.
 *)
module type AddressSig =
sig
   type t
   val create : unit -> t
   val find_sub_module : t -> module_path -> t
end

(*
 * This is a module base that loads modules automatically
 * given a directory path to look for module files.
 * The proof type must be specified (so we know what kind
 * of proofs are in the file).
 *)
module type SummaryBaseSig =
sig
   (*
    * select: a type of tags for typecase on the info
    * info: an abstract type for represeting modules in this base
    * t: the database type
    *)
   type cooked
   type select
   type info
   type t

   (* Creation *)
   val create : string list -> t
   val set_path : t -> string list -> unit
   val create_info : t -> select -> dir_name -> file_name -> info
   
   (* Loading and saving *)
   val find : t -> module_path -> select -> info
   val find_match : t -> info -> select -> info
   val save : t -> info -> unit
   
   (* Info about a module *)
   val info : t -> info -> cooked
   val set_info : t -> info -> cooked -> unit
   val sub_info : t -> info -> string -> info
   val name : t -> info -> module_name
   val pathname : t -> info -> module_path
   val root : t -> info -> info
   val file_name : t -> info -> file_name
   val type_of : t -> info -> select
end

(*
 * This module just contains types to express sharing contraints.
 * We need all four type arguments to module_info.
 *)
module type MarshalSig =
sig
   (* These are the types used for module_info *)
   type proof
   type ctyp
   type expr
   type item

   (* Type and id for this module *)
   type select
   val select : select

   (* Marshaling *)
   type cooked
   val marshal : (proof, ctyp, expr, item) module_info -> cooked
   val unmarshal : cooked -> (proof, ctyp, expr, item) module_info
end

(*
 * This is an enhanced SummaryBase.
 * It caches the following items:
 *    1. opnames in the current module
 *    2. infix operators in the current module
 *    3. resources in the current module
 *    4. summary of the current module, recorded as a module_info
 *
 * The cache also takes care of recursively opening parent modules
 * when a module is opened.  All the opnames of the parents are
 * recorded in the current module.  A hook function is allowed that
 * can be called as the parents are opened.
 *
 * The summary cache operates on (proof, ctyp, expr, item) module_info, but
 * the signature type is allowed to differ from the type being constructed.
 * The sig_* types parameterize the signatures, and the str_* types
 * parameterize the module_info being constructed.
 *)
module type SummaryCacheSig =
sig
   (*
    * proof, ctyp, expr, item: parameters to module_info
    * select: a type of tags for typecase on the info
    * info: an abstract type for represeting modules in this base
    * t: the database type
    *)
   type sig_proof
   type sig_ctyp
   type sig_expr
   type sig_item
   type sig_elem = (sig_proof, sig_ctyp, sig_expr, sig_item) summary_item
   type sig_info = (sig_proof, sig_ctyp, sig_expr, sig_item) module_info
   
   type str_proof
   type str_ctyp
   type str_expr
   type str_item
   type str_elem = (str_proof, str_ctyp, str_expr, str_item) summary_item
   type str_info = (str_proof, str_ctyp, str_expr, str_item) module_info
   
   type select
   type info
   type t
   
   (* Hook that is called whenever a module is loaded *)
   type 'a hook = info -> module_path * sig_info -> 'a -> 'a

   (* Creation *)
   val create : string list -> t
   val set_path : t -> string list -> unit
   
   (* Loading *)
   val create_cache : t -> module_name -> select -> select -> info
   val load : t -> module_name -> select -> select -> 'a hook -> 'a -> info * 'a
   val check : info -> select -> unit
   val save : info -> unit

   (* Access *)
   val info : info -> str_info
   val sub_info : info -> module_path -> sig_info

   (* Expand a partial path specification to a complete one *)
   val expand_path : info -> module_path -> module_path

   (* Opname management *)
   val optable : info -> (string -> opname)
   val op_prefix : info -> opname
   val add_opname : info -> string -> opname -> unit
   val rm_opname : info -> string -> unit
   val mk_opname : info -> string list -> opname

   (* Inherited access for module_info *)
   val find_axiom : info -> string -> (str_elem * loc) option
   val find_rewrite : info -> string -> (str_elem * loc) option
   val find_mlterm : info -> term -> (str_elem * loc) option
   val find_condition : info -> term -> (str_elem * loc) option
   val find_dform : info -> term -> (str_elem * loc) option
   val find_prec : info -> string -> bool
   val resources : info -> (module_path * str_ctyp resource_info) list

   (*
    * Update.
    *)
   val add_command : info -> (str_elem * loc) -> unit
   val add_resource : info -> module_path -> str_ctyp resource_info -> unit
   val add_prec : info -> string -> unit
   
   (*
    * An inlined module includes its opnames in the current
    * space.  This function recursively inlines all modules in
    * the hierarchy, calling the hook on each.
    *)
   val inline_module : info -> module_path -> 'a hook -> 'a -> sig_info * 'a
end

(*
 * $Log$
 * Revision 1.5  1998/02/23 14:46:24  jyh
 * First implementation of binary file compilation.
 *
 * Revision 1.4  1998/02/21 20:57:56  jyh
 * Two phase parse/extract.
 *
 * Revision 1.3  1998/02/19 17:14:04  jyh
 * Splitting filter_parse.
 *
 * Revision 1.2  1997/09/12 17:21:39  jyh
 * Added MLast <-> term conversion.
 * Splitting filter_parse into two phases:
 *    1. Compile into Filter_summary
 *    2. Compile Filter_summary into code.
 *
 * Revision 1.1  1997/08/06 16:17:35  jyh
 * This is an ocaml version with subtyping, type inference,
 * d and eqcd tactics.  It is a basic system, but not debugged.
 *
 * Revision 1.1  1997/04/28 15:51:00  jyh
 * This is the initial checkin of Nuprl-Light.
 * I am porting the editor, so it is not included
 * in this checkin.
 *
 * Directories:
 *     refiner: logic engine
 *     filter: front end to the Ocaml compiler
 *     editor: Emacs proof editor
 *     util: utilities
 *     mk: Makefile templates
 *
 * Revision 1.1  1996/09/02 19:43:18  jyh
 * Semi working package management.
 *
 * -*-
 * Local Variables:
 * Caml-master: "refiner"
 * End:
 * -*-
 *)
