/*
 * This is an internal window for editing.
 */
package edu.cornell.cs.jyh.nuprl;

import java.io.*;
import java.net.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Hashtable;

import javax.swing.*;
import javax.swing.text.*;
import javax.swing.text.html.*;
import javax.swing.event.*;

public class NuprlText
extends JScrollPane
implements KeyListener, ComponentListener
{
    /**
     * Text attributes.
     */
    protected Style stderr_style;
    protected Style stdout_style;
    protected Style prompt_style;
    protected Style stdin_style;

    /**
     * Terminal styles.
     */
    protected static final int TERMINAL_STYLE_COUNT     = 8;
    protected static final int OVERWRITE_MODE           = 0;
    protected static final int INSERT_MODE              = 1;

    protected Style[] terminal_styles                     = new Style[TERMINAL_STYLE_COUNT];
    protected Style terminal_style;
    protected int terminal_cursor                         = 0;
    protected int terminal_mode                           = OVERWRITE_MODE;
    protected int terminal_width                          = 80;
    protected int terminal_height                         = 65;
    protected char[] terminal_blanks;

    /**
     * Text window.
     */
    protected static final int MAX_SIZE = 65536;
    protected HTMLDocument document;
    protected HTMLEditorKit editor;
    protected String saved_text;
    protected JTextPane textPane;
    protected Caret textCaret;

    /**
     * Actions for key bindings.
     */
    protected Hashtable actions;

    /**
     * Target for commands.
     */
    protected NuprlBusPort client;
    protected String host;

    /**
     * Our endpoint on the bus.
     */
    protected NuprlBus bus;
    protected NuprlBusEndpoint endpoint;

    /**
     * Enclosing frame.
     */
    protected NuprlFrame frame;

    /*
     * Default style sheet.
     * HACK!  We need this because the default Sun implementation of CSS isn't ready yet.
     * We have to correct "tt" to be "monospaced" (the implementation doesn't recognize "monospace"),
     * and we use the italic font for a symbol font (the implementation doesn't handle the
     * <font> tag), and the CSS parser implementation doesn't handle "+i" options for the font
     * size.  Also, it is better to use ".tt" and ".i", but the implementation doesn't handle it.
     * Ok, so we load this hack for every window...
     *
     * Also hack the table style.  We really want invisible table cells,
     * but the Sub code doesn't seem to want to grant them.
     */
    private final static String table_style =
    "{border-width:0;"
    + "border-style:line;"
    + "margin:0;"
    + "margin-left:-2;"
    + "margin-right:-2;"
    + "margin-top:-2;"
    + "margin-bottom:-2;"
    + "padding-left:0;"
    + "padding-right:0;"
    + "padding-top:0;"
    + "padding-bottom:0;"
    + "border-left-width:0;"
    + "border-right-width:0;"
    + "border-top-width:0;"
    + "border-bottom-width:0};";

    private final static String hacked_style = "tt {font-family:monospaced}; i {font-family:symbol;font-size:18};"
    + "table " + table_style
    + "tr" + table_style
    + "td" + table_style;

    /**
     * Initial position into document.
     * HACK!  This is an arbitrary number provided by the HTMLDocument.
     */
    private final static int INITIAL_POS = 5;
    
    /************************************************************************
     * IMPLEMENTATION                                                       *
     ************************************************************************/

    /**
     * Override processInputMethodEvent
     * to turn off bells.
     */
    static class NuprlPane
    extends JTextPane
    {
        /**
         * Override replaceSelection.
         */
        public void replaceSelection(String content)
        {
            if(isEditable())
                super.replaceSelection(content);
        }

        protected void processInputMethodEvent(InputMethodEvent e)
        {
            if(isEditable())
                super.processInputMethodEvent(e);
        }
    }

    static class NuprlEditor
        extends HTMLEditorKit
    {
        public void insertHTML(HTMLDocument doc, int offset, String html,
                               int popDepth, int pushDepth,
                               HTML.Tag insertTag)
            throws BadLocationException, IOException
        {
            System.err.println("Insertion: pop=" + popDepth + " push=" + pushDepth);
            super.insertHTML(doc, offset, html, popDepth, pushDepth, insertTag);
        }
    }

    /*
     * Create the window.
     */
    NuprlText(NuprlBus bus, String host, int port, NuprlFrame frame)
        throws NuprlException
    {
        // Some initial setup
        super(VERTICAL_SCROLLBAR_ALWAYS, HORIZONTAL_SCROLLBAR_AS_NEEDED);

        // Remember the frame
        this.frame = frame;

        // Create the text pane and configure it.
        textPane = new NuprlPane();
        textPane.setContentType("text/html");
        editor = (HTMLEditorKit) new NuprlEditor();
        textPane.setEditorKit(editor);
        document = (HTMLDocument) textPane.getDocument();
        textPane.setDocument(document);
        textPane.setText("<body><table><tr><td></td></tr></table></body>");
        // editor = (HTMLEditorKit) textPane.getEditorKit();
        textCaret = textPane.getCaret();

        // Load the style sheet and initial contents
        try {
            StyleSheet style_sheet = document.getStyleSheet();
            StringReader reader = new StringReader(hacked_style);
            style_sheet.loadRules(reader, null);
        }
        catch(IOException e) {
            // Ignore it
        }

/*
        try {
            insertCell(21, "Hello");
        }
        catch(Throwable e) {
            System.err.println("Location error inserting table cell");
            e.printStackTrace();
            System.exit(1);
        }
*/

        // Initialize editor
        initStyles();
        textPane.setMargin(new Insets(5, 5, 5, 5));
        addComponentListener(this);
        setTerminalMode();

        // Set the contents
        setViewportView(textPane);
        setPreferredSize(new Dimension(400, 80));

        // Subscribe to the bus
        this.endpoint = bus.Subscribe(new NuprlTextClient(host), port);
        this.bus = bus;
    }

    /**
     * Close this window by unsubscribing to the bus.
     */
    void Close()
    {
        endpoint.Unsubscribe();
    }

    /**
     * Set the destination for input event.
     */
    void setClient(NuprlBusPort client)
    {
        this.client = client;
    }

    /**
     * Put the window in terminal mode.
     */
    public void setTerminalMode()
    {
        textPane.addKeyListener(this);
        terminal_blanks = new char[terminal_width];
        for(int i = 0; i != terminal_width; i++)
            terminal_blanks[i] = ' ';
        terminal_mode = OVERWRITE_MODE;
        // textPane.setEditable(false);
        // Keymap keymap = textPane.getKeymap();
        // keymap.removeBindings();
        // keymap.setDefaultAction(new KeystrokeAction());
        // textPane.setKeymap(keymap);
        textCaret.setDot(INITIAL_POS);
        textCaret.setVisible(true);
        terminal_cursor = document.getLength();
    }

    /*
     * Text attributes.
     */
    protected void initStyles()
    {
        Style default_style = StyleContext.getDefaultStyleContext().getStyle(StyleContext.DEFAULT_STYLE);

        /*
         * Set up the styles for the editor.
         */
        stdout_style = document.addStyle("stdout", default_style);
        StyleConstants.setBold(stdout_style, false);
        StyleConstants.setForeground(stdout_style, Color.black);

        stderr_style = document.addStyle("stderr", stdout_style);
        StyleConstants.setForeground(stderr_style, Color.red);

        prompt_style = document.addStyle("prompt", stdout_style);
        StyleConstants.setBold(prompt_style, true);
        StyleConstants.setForeground(prompt_style, new Color((float) 0.5, (float) 0.0, (float) 0.2));

        stdin_style = document.getStyle("default");
        StyleConstants.setFontFamily(stdin_style, "SansSerif");
        StyleConstants.setFontSize(stdin_style, 12);
        StyleConstants.setBold(stdin_style, true);
        StyleConstants.setForeground(stdin_style, new Color((float) 0.1, (float) 0.3, (float) 0.5));

        /*
         * Set up the styles for the terminal.
         */
        Style fixed_style = document.addStyle("terminal", stdout_style);
        StyleConstants.setFontFamily(fixed_style, "Monospaced");
        StyleConstants.setFontSize(fixed_style, 12);

        for(int i = 0; i != 4; i++)
            terminal_styles[i] = document.addStyle("terminal" + i, fixed_style);
        StyleConstants.setBold(terminal_styles[1], true);
        StyleConstants.setUnderline(terminal_styles[2], true);
        StyleConstants.setForeground(terminal_styles[3], Color.blue);

        terminal_styles[4] = document.addStyle("terminal4", stdout_style);
        StyleConstants.setBackground(terminal_styles[4], Color.blue);
        StyleConstants.setForeground(terminal_styles[4], Color.white);
        for(int i = 5; i != 8; i++)
            terminal_styles[i] = document.addStyle("terminal" + i, terminal_styles[4]);
        StyleConstants.setBold(terminal_styles[6], true);
        StyleConstants.setUnderline(terminal_styles[7], true);

        terminal_style = terminal_styles[0];
    }

    /************************************************************************
     * I/O                                                                  *
     ************************************************************************/

    /**
     * Escape an HTML string so HTML will interpret it appropriately.
     */
    protected void appendEscapedString(StringBuffer buf, String text)
    {
        int len = text.length();
        int i = 0;
        int j = 0;
        while(i != len) {
            char c = text.charAt(i);
            String replacement = null;
            switch(c) {
            case '&':
                replacement = "&amp;";
                break;
            case '<':
                replacement = "&lt;";
                break;
            case '>':
                replacement = "&gt;";
                break;
            case ' ':
            case '\t':
                replacement = "&nbsp;";
                break;
            case '\n':
                replacement = "<br>";
                break;
            }
            if(replacement != null) {
                if(j < i - 1)
                    buf.append(text.substring(j, i));
                buf.append(replacement);
                j = i + 1;
            }
            i++;
        }
            
        // Check last block
        if(j < i)
            buf.append(text.substring(j));
    }

    /**
     * Put a string out to the document.
     * We have to ignore the style because the HTMLEditor can't handle it.
     */
    protected void insertString(int off, String text, Style style)
        throws BadLocationException
    {
        document.insertString(off, text, null);
    }

    /**
     * Create a new line.
     * This inserts a new table into the document.
     */
    protected void insertNL(int offset)
        throws BadLocationException
    {
        try {
            editor.insertHTML(document, offset, "<body><table><tr><td></td></tr></table></body>", 4, 0, HTML.Tag.TABLE);
        }
        catch(IOException e) {
            System.err.println("Insertion of NL failed: " + e.getMessage());
        }
    }

    /**
     * Insert a new table cell at the address on the current line.
     */
    protected void insertCell(int offset, String contents)
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(offset);
        int start = elem.getStartOffset();
        int end = elem.getEndOffset();
        System.err.println("Inserting cell at " + end + " " + document.getText(start, end - start));
        String text = "<body><table><tr><td>" + contents + "</td></tr></table></body>";
/*
        HTMLEditorKit.InsertHTMLTextAction action = new HTMLEditorKit.InsertHTMLTextAction("InsertTableCell", text, HTML.Tag.TR, HTML.Tag.TD);
        ActionEvent event = new ActionEvent(editor, ActionEvent.ACTION_FIRST, "InsertTableCell");
        textCaret.setDot(end);
        action.actionPerformed(event);
*/
        try {
            editor.insertHTML(document, end + 1, text, 2, 0, HTML.Tag.TD);
        }
        catch(IOException e) {
            System.err.println("Insertion of table cell failed");
        }
    }

    /*
     * Add to window.
     * Reset the prompt region, then insert
     * just before region.
     */
    public synchronized void Append(String line)
    {
        try {
            int length = document.getLength();
            if(terminal_cursor >= length) {
                if(NuprlDebug.debug_text_terminal)
                    System.err.println("Append(" + line.length() + "): " + line);
                insertString(length, line, terminal_style);
                terminal_cursor = length + line.length();
            }
            else if(terminal_mode == OVERWRITE_MODE) {
                if(NuprlDebug.debug_text_terminal)
                    System.err.println("Overwrite(" + line.length() + "): " + line);
                OverwriteText(line);
            }
            else {
                if(NuprlDebug.debug_text_terminal)
                    System.err.println("Insert(" + line.length() + "): " + line);
                InsertText(line);
            }
            textCaret.setDot(terminal_cursor);
            textCaret.setVisible(true);
        }
        catch(BadLocationException e) {
            System.err.println("AppendLine: terminal cursor is out of range: 0 <= "
                               + terminal_cursor
                               + " <= "
                               + document.getLength());
        }
    }

    /**
     * What to do when a key is pressed.
     */
    protected class KeystrokeAction
        extends AbstractAction
    {
        public KeystrokeAction() {
            super("Keystroke");
            setEnabled(false);
        }
          
        public void actionPerformed(ActionEvent e)
        {
            System.err.println("Got a char");
        }
    }    

    /**
     * Handle the key typed event from the text area.
     * This isn't supported on Win32, so we ignore it.
     */
    public void keyTyped(KeyEvent e)
    {
        e.consume();
    }

    /** Handle the key pressed event from the text field. */
    public void keyPressed(KeyEvent e)
    {
        if(client != null) {
            char c = e.getKeyChar();
            if(c >= 0 && c < 256)
                endpoint.Send(client, new NuprlDataToken((byte) c));
            e.consume();
        }
    }

    /**
     * Handle the key released event from the text area.
     * Ignore it.
     */
    public void keyReleased(KeyEvent e)
    {
        e.consume();
    }

    /************************************************************************
     * ComponentListener for NuprlCommand                                   *
     ************************************************************************/

    /**
     * Applet is hidden.
     */
    public void componentHidden(ComponentEvent event)
    {
    }

    /**
     * Component is shown.
     */
    public void componentShown(ComponentEvent event)
    {
    }

    /**
     * Component was moved.
     */
    public void componentMoved(ComponentEvent event)
    {
    }

    /**
     * Component was resized.
     */
    public void componentResized(ComponentEvent event)
    {
        Dimension dim = getViewport().getExtentSize();
        Font font = new Font("monospaced", 0, 12);
        FontMetrics metrics = textPane.getFontMetrics(font);
        int width = metrics.charWidth('M');
        int height = metrics.getHeight();
        if(width < 4)
            width = 4;
        if(height < 6)
            height = 6;
        terminal_width = dim.width / width - 4;
        if(terminal_width < 10)
            terminal_width = 10;
        terminal_height = dim.height / height;
        if(terminal_height < 1)
            terminal_height = 1;
        terminal_blanks = new char[terminal_width];
        for(int i = 0; i != terminal_width; i++)
            terminal_blanks[i] = ' ';
        if(NuprlDebug.debug_text_terminal) {
            System.err.println("SIGWINCH: Pixels (" + dim.width + ", " + dim.height
                               + ") Charpixels (" + width + ", " + height
                               + ") Charsize (" + terminal_width + ", " + terminal_height + ")");
        }
        if(client != null)
            endpoint.Send(client, windowSizeToken());
    }

    /************************************************************************
     * TERMINAL FUNCTIONS                                                   *
     ************************************************************************/

    /**
     * Generate a string of the given width.
     */
    protected String blankString(int count)
    {
        return new String(terminal_blanks, 0, count);
    }

    /**
     * Append a completely blank line to the document.
     */
    protected void insertBlankLine(int pos)
        throws BadLocationException
    {
        insertString(pos, blankString(terminal_width), terminal_style);
    }
        
    /**
     * Validate a line by making sure it has at least as many characters
     * to give a valid cursor.  The element should be valid.
     */
    protected void validateLine(Element elem)
        throws BadLocationException
    {
        int start = elem.getStartOffset() + terminal_width;
        int end = elem.getEndOffset() - 1;
        if(start < end)
            document.remove(start, end - start);
        else if(start > end)
            insertString(end, blankString(start - end), terminal_style);
        if(terminal_cursor >= start)
            terminal_cursor = start - 1; 
    }

    /**
     * Validate this many lines including the current one.
     * Possibly scroll.
     */
    protected void validateDown(int count)
        throws BadLocationException
    {
    }

    /**
     * Move home.
     */
    protected void CursorHome()
    {
        terminal_cursor = INITIAL_POS;
    }

    /**
     * Move to beginning of line.
     */
    protected void CursorCR()
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        if(NuprlDebug.debug_text_terminal)
            System.err.println("CTRL-M: old: " + terminal_cursor + " new: " + elem.getStartOffset());
        terminal_cursor = elem.getStartOffset();
        if(terminal_cursor < INITIAL_POS)
            terminal_cursor = INITIAL_POS;
    }

    /**
     * Move to the next line.
     */
    protected void CursorNL()
        throws BadLocationException
    {
        int length = document.getLength();
        if(terminal_cursor == length) {
            insertNL(terminal_cursor);
            terminal_cursor++;
        }
        else {
            Element elem = document.getParagraphElement(terminal_cursor);
            int end = elem.getEndOffset();
            if(NuprlDebug.debug_text_terminal) {
                System.err.println("CTRL-J: old: " + terminal_cursor
                                   + " start: " + elem.getStartOffset()
                                   + " new: " + end
                                   + " length: " + length);
            }
            terminal_cursor = end;
            if(terminal_mode == INSERT_MODE || end >= length)
                insertNL(end);
        }
    }

    /**
     * Move to a particular position.
     */
    protected void CursorMove(int row, int col)
        throws BadLocationException
    {
        terminal_cursor = 0;
        CursorDown(row);
        CursorRight(col);
    }
    
    /**
     * Move the cursor left.
     * Do not move past the left margin.
     */
    protected void CursorLeft(int count)
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        int start = elem.getStartOffset();
        if(terminal_cursor - count < start)
            terminal_cursor = start;
        else
            terminal_cursor -= count;
    }

    /**
     * Move right.
     * Extend the line if necessary, but do not
     * extend past the right margin.
     */
    protected void CursorRight(int count)
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        int start = elem.getStartOffset();

        // Don't extend past the line width
        if(terminal_cursor + count - start > terminal_width)
            terminal_cursor = start + terminal_width;
        else
            terminal_cursor += count;

        // Extend the line if necessary
        validateLine(elem);
    }

    /**
     * Move down.
     * Scroll the window if necessary.
     */
    protected void CursorDown(int count)
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        validateLine(elem);
        while(count > 0) {
            terminal_cursor += terminal_width + 1;
            int length = document.getLength();
            if(terminal_cursor > length)
                insertBlankLine(length);
            else {
                elem = document.getParagraphElement(terminal_cursor);
                validateLine(elem);
            }
            count--;
        }
    }

    /**
     * Move up, but don't go past the beginning of the document.
     */
    protected void CursorUp(int count)
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        validateLine(elem);
        while(count > 0 && terminal_cursor > terminal_width) {
            terminal_cursor -= terminal_width + 1;
            elem = document.getParagraphElement(terminal_cursor);
            validateLine(elem);
        }
    }

    /**
     * Insert some lines before this one.
     */
    protected void InsertLines(int count)
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        int start = elem.getStartOffset();
        while(count >= 0) {
            insertBlankLine(start);
            terminal_cursor += terminal_width + 1;
        }
    }
            
    /**
     * Insert some blank chars.
     */
    protected void InsertBlanks(int count)
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        int start = elem.getStartOffset();
        validateLine(elem);
        insertString(terminal_cursor, blankString(count), terminal_style);
        document.remove(start + terminal_width, count);
    }

    /**
     * Delete one char back.
     */
    protected void BackSpace()
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        int start = elem.getStartOffset();
        if(terminal_cursor > start)
            document.remove(--terminal_cursor, 1);
    }

    /**
     * Add some tabs.
     */
    protected void Tab()
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        int start = elem.getStartOffset();
        int count = 8 - ((terminal_cursor - start) % 8);
        Append(blankString(count));
    }

    /**
     * Delete some chars.
     */
    protected void DeleteChars(int count)
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        int start = elem.getStartOffset();
        int remaining = terminal_width - terminal_cursor + start;
        if(count > remaining)
            count = remaining;
        validateLine(elem);
        document.remove(terminal_cursor, count);
        insertString(start + terminal_width - count, blankString(count), terminal_style);
    }

    /**
     * Delete the current line.
     */
    protected void DeleteLines(int count)
        throws BadLocationException
    {
        while(count >= 0) {
            Element elem = document.getParagraphElement(terminal_cursor);
            int start = elem.getStartOffset();
            int end = elem.getEndOffset() - 1;
            document.remove(start, end - start + 1);
            terminal_cursor = start;
            count--;
        }
    }

    /**
     * Delete to end-of-screen.
     */
    protected void KillScreen()
        throws BadLocationException
    {
        int pos = terminal_cursor;
        while(true) {
            int length = document.getLength();
            if(pos >= length)
                break;
            Element elem = document.getParagraphElement(pos);
            int start = elem.getStartOffset();
            int end = elem.getEndOffset() - 1;
            document.remove(pos, end - pos);
            insertString(pos, blankString(start + terminal_width - pos), terminal_style);
            pos = start + terminal_width + 1;
        }
    }

    /**
     * Delete to end of line.
     */
    protected void KillLine()
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        int start = elem.getStartOffset();
        int end = elem.getEndOffset() - 1;
        if(start + terminal_width > terminal_cursor)
            insertString(end, blankString(start + terminal_width - terminal_cursor), terminal_style);
        if(end > terminal_cursor)
            document.remove(terminal_cursor, end - terminal_cursor);
    }

    /**
     * Scroll region.
     * I don't know what this means.
     */
    protected void ScrollRegion(int line1, int line2)
    {
    }

    /**
     * Start overwrite mode.
     */
    protected void OverwriteMode()
    {
        terminal_mode = OVERWRITE_MODE;
    }

    /**
     * Start insert mode.
     */
    protected void InsertMode()
    {
        terminal_mode = INSERT_MODE;
    }

    /**
     * Insert a line of text.
     */
    protected void InsertText(String text)
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        int start = elem.getStartOffset();
        int end = elem.getEndOffset() - 1;
        int length = text.length();
        insertString(terminal_cursor, text, terminal_style);
        if(end + length > start + terminal_width) {
            document.remove(start + terminal_width, end + length - start - terminal_width);
            terminal_cursor = end;
        }
        else
            terminal_cursor += length;
    }

    /**
     * Overwrite a pice of text.
     */
    protected void OverwriteText(String text)
        throws BadLocationException
    {
        Element elem = document.getParagraphElement(terminal_cursor);
        int start = elem.getStartOffset();
        int end = elem.getEndOffset() - 1;
        int length = text.length();

        if(NuprlDebug.debug_text_terminal) {
            System.err.println("OverwriteText(" + length + ") " + text
                               + " old: " + terminal_cursor
                               + " start: " + start
                               + " end: " + end
                               + " length: " + document.getLength());
        }

        // This is a hack because Sun's code doesn't like to insert at the end
        if(terminal_cursor == start)
            insertString(terminal_cursor, " ", terminal_style);

        insertString(terminal_cursor, text, terminal_style);
        if(terminal_cursor + length > start + terminal_width) {
            length = terminal_cursor + length - start - terminal_width;
            document.remove(start + terminal_width, length);
            terminal_cursor = start + terminal_width - 1;
        }
        else {
            int amount = length;
            if(end - terminal_cursor < length)
                amount = end - terminal_cursor - 1;
            if(amount > 0)
                document.remove(terminal_cursor + length, amount);
            terminal_cursor += length;
        }
    }

    /**
     * Set the title.  Check for the special title
     *   MetaPRL http://hostname:port/password
     */
    protected static String title_head = "MetaPRL ";
    protected static int title_head_length = title_head.length();

    protected void setTitle(String title)
    {
        if(title_head.regionMatches(0, title, 0, title_head_length)) {
            try {
                URL url = new URL(title.substring(title_head_length));
                endpoint.Send(NuprlConstants.CONTROL_NAME, 1, new NuprlURLToken(NuprlURLToken.PASSWORD, url));
            }
            catch(MalformedURLException e) {
                frame.setTitle(title);
            }
        }
        else
            frame.setTitle(title);
    }

    /************************************************************************
     * OPTION HANDLING                                                      *
     ************************************************************************/

    /**
     * Handle a terminal argument.
     */
    private void HandleArgumentError(NuprlArgumentToken token)
        throws BadLocationException
    {
        // Try to parse the arguments into numbers
        String[] string_args = token.arguments;
        boolean[] int_flags = new boolean[string_args.length];
        int[] int_args = new int[string_args.length];
        for(int i = 0; i != string_args.length; i++) {
            if(string_args[i].length() == 0) {
                int_flags[i] = true;
                int_args[i] = 0;
            }
            else {
                try {
                    int_args[i] = Integer.parseInt(string_args[i]);
                    int_flags[i] = true;
                }
                catch(NumberFormatException e) {
                    // Ignore it
                }
            }
        }

        // Now parse the command
        switch(token.charcode) {
        case ']':
            if(NuprlDebug.debug_text_terminal)
                System.err.println("ESC ]");

            if(token.arguments.length == 2) {
                if(int_flags[0] && int_args[0] == 0)
                    setTitle(string_args[1]);
            }
            break;

        case '[':
        case '?':
            if(NuprlDebug.debug_text_terminal) {
                StringBuffer buffer = new StringBuffer();
                buffer.append("ESC [");
                for(int i = 0; i != string_args.length; i++) {
                    if(i != 0)
                        buffer.append(";");
                    buffer.append(string_args[i]);
                }
                buffer.append((char) token.c);
                buffer.append(" (");
                buffer.append(token.c);
                buffer.append(")");
                System.err.println(buffer.toString());
            }
            switch(token.c) {
            case 'm':
                // Change the printing mode
                if(int_flags[0]) {
                    int index = int_args[0] % TERMINAL_STYLE_COUNT;
                    terminal_style = terminal_styles[index];
                }
                break;

            case 'L':
                // Insert %1 lines
                if(int_flags[0])
                    InsertLines(int_args[0]);
                break;

            case 'P':
                // Delete %1 characters
                if(int_flags[0])
                    DeleteChars(int_args[0]);
                break;

            case 'M':
                // Delete %1 lines
                if(int_flags[0])
                    DeleteLines(int_args[0]);
                break;

            case 'B':
                // Cursor down %1 lines
                if(int_flags[0])
                    CursorDown(int_args[0] + 1);
                break;

            case '@':
                // Insert %d characters
                if(int_flags[0])
                    InsertBlanks(int_args[0]);
                break;

            case 'D':
                // Cursor left %1 characters
                if(int_flags[0])
                    CursorLeft(int_args[0]);
                break;

            case 'C':
                // Cursir right %1 characters
                if(int_flags[0])
                    CursorRight(int_args[0]);
                break;

            case 'A':
                // Cursor up %1 lines
                if(int_flags[0])
                    CursorUp(int_args[0]);
                break;

            case 'J':
                // Clear to end of screen
                KillScreen();
                break;

            case 'K':
                // Clear to end of line
                KillLine();
                break;

            case 'H':
                // Move to row %1, column %2
                if(int_flags.length >= 2 && int_flags[0] && int_flags[1])
                    CursorMove(int_args[0] - 1, int_args[1] - 1);
                else
                    CursorHome();
                break;

            case 'r':
                // Scroll region from line %1 to line %2
                if(int_flags.length >= 2 && int_flags[0] && int_flags[1])
                    ScrollRegion(int_args[0] - 1, int_args[1] - 1);
                break;

            case 'l':
                if(int_flags[0]) {
                    switch(int_args[0]) {
                    case 4:
                        // End insert mode
                        OverwriteMode();
                        break;
                    }
                }
                break;

            case 'h':
                if(int_flags[0]) {
                    switch(int_args[0]) {
                    case 4:
                        InsertMode();
                        break;
                    }
                }
                break;

            default:
                System.err.println("NuprlText.ESC [ " + ((char) token.c) + " (" + token.c + ") not handled");
                break;
            }
            break;

        default:
            System.err.println("NuprlText.ESC " + ((char) token.charcode) + " " + ((char) token.c) + " not handled");
            break;
        }
    }

    protected void HandleArgument(NuprlArgumentToken token)
    {
        try {
            HandleArgumentError(token);
            textCaret.setDot(terminal_cursor);
            textCaret.setVisible(true);
        }
        catch(BadLocationException e) {
            System.err.println("HandleArgument: bad location");
        }
    }

    /**
     * Handle a control char.
     */
    protected void HandleControl(NuprlControlToken token)
    {
        if(NuprlDebug.debug_text_terminal)
            System.err.println("CTRL-" + ((char) (token.c + '@')) + " (" + token.c + ")");

        try {
            switch(token.c) {
            case 'H' - '@':
                BackSpace();
                break;
            case 'M' - '@':
                CursorCR();
                break;
            case 'J' - '@':
                CursorNL();
                break;
            case 'I' - '@':
                Tab();
                break;
            }
            textCaret.setDot(terminal_cursor);
            textCaret.setVisible(true);
        }
        catch(BadLocationException e) {
            System.err.println("HandleControl: bad location");
        }
    }

    /**
     * Format the window size token.
     */
    private NuprlToken windowSizeToken()
    {
        byte[] buffer = new byte[5];
        int width = terminal_width - 1;
        buffer[0] = NuprlClient.TELNET_OPT_NAWS;
        buffer[1] = (byte) ((width >> 8) & 0xff);
        buffer[2] = (byte) (width & 0xff);
        buffer[3] = (byte) ((terminal_height >> 8) & 0xff);
        buffer[4] = (byte) (terminal_height & 0xff);
        return new NuprlOptionSBToken(buffer);
    }

    /**
     * Respond to an option.
     */
    private void OptionReply(NuprlBusEndpoint endpt, String host, int port, byte option)
    {
        byte[] buffer;

        // Show negotiation
        if(NuprlDebug.debug_text)
            System.err.println("NuprlText.OptionReply: " + host + "." + port + " " + option);

        // Don't take any options except binary mode
        switch(option) {
        case NuprlClient.TELNET_OPT_BINARY:
            endpt.Send(host, port, new NuprlOptionResponseToken(option, true));
            break;
        case NuprlClient.TELNET_OPT_TTYPE:
            endpt.Send(host, port, new NuprlOptionResponseToken(option, true));
            buffer = new byte[7];
            buffer[0] = NuprlClient.TELNET_OPT_TTYPE;
            buffer[1] = NuprlClient.TELNET_OPT_SB_IS;
            buffer[2] = (byte) 'x';
            buffer[3] = (byte) 't';
            buffer[4] = (byte) 'e';
            buffer[5] = (byte) 'r';
            buffer[6] = (byte) 'm';
            endpt.Send(host, port, new NuprlOptionSBToken(buffer));
            endpt.Send(host, port, new NuprlOptionRequestToken(NuprlClient.TELNET_OPT_NAWS, true));
            break;
        case NuprlClient.TELNET_OPT_NAWS:
            endpt.Send(host, port, new NuprlOptionResponseToken(option, true));
            endpt.Send(host, port, windowSizeToken());
            break;
        case NuprlClient.TELNET_OPT_ECHO:
        default:
            endpt.Send(host, port, new NuprlOptionResponseToken(option, false));
            break;
        }
    }

    /**
     * Handle an option request.
     */
    private void OptionRequest(NuprlBusEndpoint endpt, String host, int port, NuprlOptionRequestToken token)
    {
        OptionReply(endpt, host, port, token.option);
    }

    /**
     * Record the option status.
     */
    private void OptionResponse(NuprlBusEndpoint endpt, String host, int port, NuprlOptionResponseToken token)
    {
        OptionReply(endpt, host, port, token.option);
    }

    /**
     * Drop any extended options.
     */
    private void OptionBlock(NuprlBusEndpoint endpt, String host, int port, NuprlOptionBlockToken token)
    {
    }

    /**
     * Handle an incoming token.
     */
    public synchronized void Poll(NuprlBusEndpoint endpt)
    {
        NuprlBusMessage msg;
        while((msg = endpt.getMessage()) != null) {
            NuprlToken token = msg.token;
            if(token instanceof NuprlDataToken)
                Append(new String(((NuprlDataToken) token).getData()));
            else if(token instanceof NuprlArgumentToken)
                HandleArgument((NuprlArgumentToken) token);
            else if(token instanceof NuprlControlToken)
                HandleControl((NuprlControlToken) token);
            else if(token instanceof NuprlOptionRequestToken)
                OptionRequest(endpt, msg.src_host, msg.src_port, (NuprlOptionRequestToken) token);
            else if(token instanceof NuprlOptionResponseToken)
                OptionResponse(endpt, msg.src_host, msg.src_port, (NuprlOptionResponseToken) token);
            else if(token instanceof NuprlOptionBlockToken)
                OptionBlock(endpt, msg.src_host, msg.src_port, (NuprlOptionBlockToken) token);
        }
    }

    /**
     * This is the client interface.
     */
    class NuprlTextClient
        implements NuprlBusClient
    {
        /**
         * Our hostname.
         */
        String host;

        /**
         * Create the client.
         */
        NuprlTextClient(String host)
        {
            this.host = host;
        }

        /**
         * Our hostname.
         */
        public String getHost()
        {
            return host;
        }

        /**
         * Handle a wakeup from the bus.
         */
        public void wakeup(NuprlBusEndpoint endpt)
        {
            Poll(endpt);
        }
    }

    /************************************************************************
     * VIEW SOURCE                                                          *
     ************************************************************************/

    /**
     * Swap the contents of the buffer.
     */
    class ViewSourceAction
        extends AbstractAction
    {
        public ViewSourceAction()
        {
            super("View Source");
        }
          
        public void actionPerformed(ActionEvent e)
        {
            if(saved_text == null) {
                String text = textPane.getText();
                StringBuffer buf = new StringBuffer();
                buf.append("<body>");
                appendEscapedString(buf, text);
                buf.append("</body>");

                // Now swap the contents
                saved_text = text;
                textPane.setText(buf.toString());
            }
            else {
                // Swap back the old contents
                textPane.setText(saved_text);
                editor = (HTMLEditorKit) textPane.getEditorKit();
                document = (HTMLDocument) textPane.getDocument();
                textCaret = textPane.getCaret();
                int len = document.getLength();
                if(terminal_cursor > len)
                    terminal_cursor = len;
                saved_text = null;
            }
        }
    }    


    /*
     * The edit menu allows undo/redo and copy/paste.
     */
    JMenu createEditMenu()
    {
        JMenu menu = new JMenu("Edit");
        menu.add(new ViewSourceAction());
        menu.add(new HTMLEditorKit.InsertHTMLTextAction("InsertTableCell", "<table border=1><tr><td></td></tr></table>", HTML.Tag.TR, HTML.Tag.TD));
        return menu;
    }
}
