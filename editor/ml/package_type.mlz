(*
 * The editor collects information about each theory and
 * summarizes it in a "package".  At start-up, the pre-loaded packages
 * are collected and presented as read-only theories.
 *
 * We can also create interactive packages, which are writable,
 * and may contain interactivly generated proofs.
 *)

include Tactic_type
include Summary
include Proof_edit
include Proof_type

open Opname
open Refiner.Refiner
open Refiner.Refiner.TermType
open Dform_print

open Filter_summary
open Filter_cache

open Tactic_type
open Proof_type

(*
 * Save status of a module.
 *)
type status =
   Unmodified
 | Modified
 | ReadOnly
 | Incomplete

(*
 * This exception is raised when a package is requested,
 * and it has not been loaded.
 *)
exception NotLoaded of string

(*
 * A package is a lot like a FilterCache, but
 * we remove some of the extra options.
 *)
module type PackageSig =
sig
   (*
    * This is the database type.
    *)
   type t

   (*
    * This is the type of a package.
    *)
   type package

   (*
    * Proofs are abstract.
    *)
   type proof

   (*
    * Create a database.  The argument is the search path.
    *)
   val create : string list -> t

   (*
    * Filesystem interface.
    * Loaded packages are initially read-only.
    *)
   val create_package : t -> string -> package
   val load : t -> string -> package
   val get : t -> string -> package
   val save : t -> package -> unit

   (*
    * Access.
    *)
   val refiner  : package -> Refine.refiner
   val dforms   : package -> dform_mode_base
   val name     : package -> string
   val filename : t -> package -> string

   (*
    * Navigation.
    *)
   val packages : t -> package list
   val roots : t -> package list
   val parents : t -> package -> package list
   val children : t -> package -> package list

   (*
    * Access to the status.
    *)
   val status  : package -> status
   val set_status : package -> status -> unit
   val touch : package -> unit

   (*
    * Access to the cache.
    *)
   val mk_opname : package -> string list -> opname

   (*
    * Collection of objects in the module.
    *)
   val info : package -> (term, meta_term, proof proof_type, MLast.ctyp, MLast.expr, MLast.str_item) module_info
   val sig_info : package -> (term, meta_term, unit, MLast.ctyp, MLast.expr, MLast.sig_item) module_info
   val find : package -> string -> (term, meta_term, proof proof_type, MLast.ctyp, MLast.expr, MLast.str_item) summary_item
   val set : package -> (term, meta_term, proof proof_type, MLast.ctyp, MLast.expr, MLast.str_item) summary_item -> unit

   (*
    * This is the starting info for new proofs.
    *)
   val argument : package -> tactic_argument
   val new_proof : package -> string -> term list -> term -> proof
   val ped_of_proof : package -> proof -> Proof_edit.t
   val status_of_proof : proof -> Proof.status
end

(*
 * -*-
 * Local Variables:
 * Caml-master: "editor.top"
 * End:
 * -*-
 *)
