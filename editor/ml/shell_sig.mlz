(*
 * This is the generic editing interface.
 *
 * ----------------------------------------------------------------
 *
 * This file is part of MetaPRL, a modular, higher order
 * logical framework that provides a logical programming
 * environment for OCaml and other languages.
 *
 * See the file doc/index.html for information on Nuprl,
 * OCaml, and more information about this system.
 *
 * Copyright (C) 1998 Jason Hickey, Cornell University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Jason Hickey
 * jyh@cs.cornell.edu
 *)

open Refiner.Refiner.Term
open Refiner.Refiner.Refine
open Rformat
open Dform
open Dform_print

open Tactic_type.Tactic

open Proof_edit

(*
 * Create either in text mode,
 * or in window mode.
 *)
type display_mode =
   DisplayText of dform_mode_base * string
 | DisplayGraphical of Mux_channel.session * dform_mode_base

(*
 * Options to the "ls" command.
 *)
type ls_option =
   LsRewrites
 | LsRules
 | LsUnjustified
 | LsAll

(*
 * An editable object.
 *)
type edit_object =
   { (* Display the object to the screen *)
     edit_display : ls_option list -> unit;

     (* Copy the object *)
     edit_copy : unit -> edit_object;

     (* Adjust the contents of the object *)
     edit_set_goal : term -> unit;
     edit_set_redex : term -> unit;
     edit_set_contractum : term -> unit;
     edit_set_assumptions : term list -> unit;
     edit_set_params : term Filter_type.param list -> unit;
     edit_save : unit -> unit;
     edit_check : unit -> term;
     edit_expand : dform_base -> unit;

     (* Navigation if there is a proof *)
     edit_interpret : proof_command -> unit;
     edit_root : unit -> unit;
     edit_up : int -> unit;
     edit_down : int -> unit;
     edit_undo : unit -> unit;
     edit_redo : unit -> unit;
     edit_addr : int list -> unit;
     edit_info : unit -> edit_info;
     edit_refine : string -> MLast.expr -> tactic -> unit;
   }

(*
 * These are the functions provided by the shell.
 *)
module type ShellSig =
sig
   type t

   (*
    * Main loop.
    *)
   val main : unit -> unit

   (*
    * Job control.
    *)
   val get_current_shell : unit -> t
   val fork : t -> string
   val pid : t -> string
   val jobs : t -> string
   val fg : t -> int -> string

   (*
    * This is the interface to the HTTP shell.
    * Not available from the toploop.
    *)
   val eval : int -> string -> unit
   val set_port : Mux_channel.session option -> unit

   (*
    * Navigation and display.
    *)
   val cd : t -> string -> string
   val pwd : t -> string
   val set_window_width : t -> int -> unit

   (*
    * Module commands.
    *)
   val load : t -> string -> unit
   val create_pkg : t -> string -> unit
   val set_writeable : t -> unit
   val save : t -> unit
   val save_all : t -> unit

   (*
    * The possible objects in a package.
    *)
   val create_rw : t -> string -> unit
   val create_axiom : t -> string -> unit
   val create_thm : t -> string -> unit
   val create_tptp : t -> string -> unit
   val create_opname : t -> string -> unit
   val create_condition : t -> string -> unit
   val create_parent : t -> string -> unit
   val create_dform : t -> string -> unit
   val create_prec : t -> string -> unit
   val create_prec_rel : t -> string -> string -> string -> unit
   val create_resource : t -> string -> unit
   val create_infix : t -> string -> unit
   val create_ml : t -> string -> unit

   (*
    * View, close, check object.
    * An object is not installed until it is checked.
    *)
   val view : t -> string -> unit
   val ls : t -> string -> unit

   (*
    * Editing commands.
    *)
   val set_goal : t -> term -> unit
   val set_redex : t -> term -> unit
   val set_contractum : t -> term -> unit
   val set_assumptions : t -> term list -> unit
   val set_params : t -> term Filter_type.param list -> unit
   val check : t -> unit
   val expand : t -> unit

   (*
    * Proof editing.
    *)
   val root : t -> unit
   val up : t -> int -> unit
   val down : t -> int -> unit
   val goal : t -> tactic_arg
   val refine : t -> tactic -> unit
   val undo : t -> unit
   val redo : t -> unit
   val nop : t -> unit
   val unfold : t -> unit
   val copy : t -> string -> unit
   val paste : t -> string -> unit
   val make_assum : t -> unit
   val kreitz : t -> unit
   val sync : t -> unit
   val expand_all : t -> unit

   (*
    * Nuprl5 interface.
    *)
   val edit_list_modules : t -> string list
   val edit_list_module_all : t -> string -> string list
   val edit_list_module : t -> string -> string list * string list * string list * string list
   val edit_list_module_rw : t -> string -> string list
   val edit_list_parents : t -> string -> string list
   val edit_list_dforms : t -> string -> (string * string list * term list * term * term) list
   val edit_list_precs : t -> string -> term list
   val edit_list_prec_rels : t -> string -> (string * term * term) list
   val edit_create_thm : t -> string -> string -> unit
   val edit_create_rw : t -> string -> string -> unit
   val edit_cd_thm : t -> string -> string -> unit
   val edit_save : t -> string -> unit
   val edit_set_goal : t -> string -> string -> term -> unit
   val edit_set_redex : t -> string -> string -> term -> unit
   val edit_set_contractum : t -> string -> string -> term -> unit
   val edit_set_assumptions : t -> string -> string -> term list -> unit
   val edit_set_params : t -> string -> string -> term Filter_type.param list -> unit
   val edit_refine : t -> int list -> string -> msequent * msequent list * msequent list
   val edit_node : t -> int list -> string option * msequent * msequent list * msequent list
   val edit_undo : t -> unit
end

(*
 * HTTP wrapper redefines main function.
 *)
module type ShellHTTPSig =
sig
   val main : unit -> unit
end

(*
 * -*-
 * Local Variables:
 * Caml-master: "refiner"
 * End:
 * -*-
 *)
