doc <:doc<
   @module[Auto_tactic]

   The @tt[Auto_tactic] module defines two of the most useful
   tactics in the @MetaPRL prover.  The @tactic[autoT] tactic attempts
   to prove a goal ``automatically,'' and the @tactic[trivialT] tactic
   proves goals that are ``trivial.''  Their implementations are surprisingly
   simple---all of the work in automatic proving is implemented in
   descendent theories.

   This module describes the @emph{generic} implementation of the
   @hreftactic[autoT] and @hreftactic[trivialT] tactics.  They are implemented
   using a resource
   containing collections of tactics that are added by descendent theories.
   The @Comment!resource[auto] resource builds collections of tactics specified by
   a data structure with the following type:

   @begin[center]
   @begin[verbatim]
   type auto_info =
      { auto_name : string;
        auto_tac : tactic;
        auto_prec : auto_prec;
        auto_type : auto_type;
      }

   and auto_type =
      AutoTrivial
    | AutoNormal
    | AutoComplete
   @end[verbatim]
   @end[center]

   The @tt[auto_name] is the name used to describe the entry (for
   debugging purposes).  The @tt[auto_tac] is the actual tactic to try.
   The entries are divided into precedence levels; tactics with higher precedence
   are applied first.

   Finally, @tt[auto_type] specifies how @hreftactic[autoT] and @hreftactic[trivialT]
   will use each particular entry. @tt[AutoTrivial] entries are the only ones
   used by @hreftactic[trivialT]; @hreftactic[autoT] attempts using them before
   any other entries. @tt[AutoComplete] will be used by @hreftactic[autoT] after
   all @tt[AutoTrivial] and @tt[AutoNormal] entries are exhausted. @hreftactic[autoT]
   will consider an application of an @tt[AutoComplete] entry to be successful
   only if it would be able to completely prove all subgoals generated by it.

   This theory also defines the @tactic[byDefT] tactic. @tt{byDefT }@i[conv]
   (where @i[conv] is usually an @tt[unfold_] conversional) uses @i[conv]
   (through @hrefconv[higherC]) on all the assumptions and on the goal and then
   calls @hreftactic[autoT]. The @tactic[byDefsT] tactic that takes a @tt{conv list}
   is defined similarly.

   The tactic @tt[repeatWithRwsT] @i[convs] @i[tac] tries to apply some conversional from
   the @i[convs] list to the goal and in case of a progress applies the tactic @i[tac],
   then repeats it as far as possible.
   @docoff

   ----------------------------------------------------------------

   @begin[license]

   This file is part of MetaPRL, a modular, higher order
   logical framework that provides a logical programming
   environment for OCaml and other languages.

   See the file doc/htmlman/default.html or visit http://metaprl.org/
   for more information.

   Copyright (C) 1998-2006 MetaPRL Group, Cornell University and
   California Institute of Technology

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   Author: Jason Hickey @email{jyh@cs.caltech.edu}
   Modified by: Aleksey Nogin @email{nogin@cs.cornell.edu}
   @end[license]
>>

doc <:doc<
   @parents
>>
extends Mptop
extends Top_tacticals
extends Top_conversionals
extends Browser_resource
doc docoff

open Lm_debug
open Lm_printf
open Lm_dag_sig
open Lm_imp_dag

open Term_sig
open Rewrite_sig
open Refiner.Refiner
open Refiner.Refiner.RefineError
open Refiner.Refiner.Term
open Refiner.Refiner.TermType
open Refiner.Refiner.TermMan
open Refiner.Refiner.TermMeta
open Refiner.Refiner.TermOp
open Refiner.Refiner.TermShape
open Refiner.Refiner.TermSubst
open Refiner.Refiner.TermAddr
open Refiner.Refiner.Rewrite
open Mp_resource
open Term_match_table
open Simple_print
open Dform

open Tactic_type
open Tactic_type.Sequent
open Tactic_type.Tactic
open Tactic_type.Tacticals
open Tactic_type.Conversionals
open Top_conversionals
open Options_boot
open Browser_resource

(*
 * Debugging.
 *)
let debug_auto =
   create_debug (**)
      { debug_name = "auto";
        debug_description = "Display auto tactic operations";
        debug_value = false
      }

(************************************************************************
 * TYPES                                                                *
 ************************************************************************)

(*
 * The auto tactic just produces a list of tactics to try.
 *)
type auto_prec = unit ImpDag.node

(*
 * The info provided is a name,
 * a precedence, and a function
 * to produce a tactic.  The function
 * is called once per run of the auto tactic.
 *)
type auto_info = {
   auto_name : string;
   auto_prec : auto_prec;
   auto_tac : tactic;
   auto_type : auto_type;
}

and auto_type =
   AutoTrivial
 | AutoNormal
 | AutoComplete

type nth_hyp_entry =
   (* proves "...; i.hyp; ... >- concl" right away *)
   NthImmediate of (int -> tactic)
   (* might prove "...; i.hyp; ... >- concl", or fail *)
 | NthUncertain of (int -> tactic)

   (* turns "...>- concl" into "...>- hyp" *)
 | NthStep of tactic
   (* turns "...>- concl" into "...>- hyp", takes hyp as input *)
 | NthStepTerm of (term -> tactic)

   (* turns "...; i.hyp; ... >- ..." into "...; i.hyp; ...; j.concl; ... >- ..."; the int is negative*)
 | NthForward of (int -> tactic) * int
   (* same as NthForward, but may fail *)
 | NthForwardUncertain of (int -> tactic) * int

type nth_hyp_result = {
   nth_hyp : int -> tactic_arg -> tactic;
   nth_hyp_fun : term -> term -> bool;
   some_nth_hyp : tactic_arg -> tactic;
   match_assums : (term -> tactic) -> int -> tactic_arg -> tactic;
}

(************************************************************************
 * IMPLEMENTATION - nthHypT                                             *
 ************************************************************************)

(*
 * Opname for pairing a hypothesis and a conclusion into a single term
 *)
declare nthhyp_pair{'hyp;'concl}

let mk_nthhyp_pair_term =
   mk_dep0_dep0_term (opname_of_term <<nthhyp_pair{'hyp;'concl}>>)

let wrap_nth_hyp_uncertain tac =
   NthUncertain tac

let wrap_nth_hyp_certain tac =
   NthImmediate tac

let extract_nth_hyp_data =
   let select_immediate = function
      NthImmediate _ -> true
    | NthUncertain _
    | NthForward _
    | NthForwardUncertain _
    | NthStep _
    | NthStepTerm _ -> false
   in
   let select_indep = function
      NthImmediate _
    | NthForward _
    | NthStep _
    | NthStepTerm _ -> true
    | NthForwardUncertain _
    | NthUncertain _ -> false
   in
   let a = mk_var_term (Lm_symbol.add "t") in
   let self_term = mk_nthhyp_pair_term a a in
   let err = RefineError ("extract_nth_hyp_data", StringError "nthHypT tactic doesn't have an entry for this hypothesis/conclusion combination") in
   let err_assum = RefineError ("Auto_tactic.matchAssumsT", StringError "lengths do not match") in
   (fun tbl ->
      let nth_hypT =
         match Term_match_table.lookup tbl select_immediate self_term with
            Some (NthImmediate tac) -> tac
          | Some _ -> raise (Invalid_argument "nthHypT: internal error")
          | None -> (fun _ -> failWithT "nthHypT: no match")
      in
      let rec iterate hyp i (c : nth_hyp_entry lazy_lookup) _ =
         match c () with
            Some (NthImmediate tac, _) -> tac i
          | Some (NthStep tac, _) -> tac thenT nth_hypT i
          | Some (NthStepTerm tac, _) -> tac hyp thenT nth_hypT i
          | Some (NthUncertain tac, cont) -> tac i orelseT funT (iterate hyp i cont)
          | Some (NthForward (tac, j), _) -> tac i thenT nth_hypT j
          | Some (NthForwardUncertain (tac, j), cont) ->
               (tac i thenT nth_hypT j) orelseT funT (iterate hyp i cont)
          | None -> raise err
      in
      let rec somehyp hyps t i =
         if i = 0 then
            raise err
         else
            match SeqHyp.get hyps (i-1) with
               Context _ ->
                  somehyp hyps t (i-1)
             | Hypothesis (_, h) ->
                  let t' = mk_nthhyp_pair_term h t in
                     if alpha_equal h t then
                        nth_hypT i
                     else
                        iterate_some hyps h t i (Term_match_table.lookup_all tbl select_all t')
      and iterate_some hyps hyp t i c =
         match c () with
            Some (NthImmediate tac, _) -> tac i
          | Some (NthStep tac, _) -> tac thenT nth_hypT i
          | Some (NthStepTerm tac, _) -> tac hyp thenT nth_hypT i
          | Some (NthUncertain tac, cont) -> tac i orelseT funT (keep_iterate_some hyps hyp t i cont)
          | Some (NthForward (tac, j), _) -> tac i thenT nth_hypT j
          | Some (NthForwardUncertain (tac, j), cont) ->
               (tac i thenT nth_hypT j) orelseT funT (keep_iterate_some hyps hyp t i cont)
          | None -> somehyp hyps t (i-1)
      and keep_iterate_some hyps hyp t i cont _ =
         iterate_some hyps hyp t i cont
      in {
         nth_hyp = (fun i p ->
            let hyp = Sequent.nth_hyp p i in
            let concl = Sequent.concl p in
               if alpha_equal hyp concl then
                  nth_hypT i
               else
                  let t = mk_nthhyp_pair_term hyp concl in
                     iterate hyp i (Term_match_table.lookup_all tbl select_all t) p);
         nth_hyp_fun = (fun t1 t2 ->
            let t = mk_nthhyp_pair_term t1 t2 in
               match Term_match_table.lookup tbl select_indep t with
                  Some _ -> true
                | None -> false);
         some_nth_hyp = (fun p ->
            let goal = Sequent.explode_sequent_arg p in
               somehyp goal.sequent_hyps goal.sequent_concl (SeqHyp.length goal.sequent_hyps));
         match_assums = (fun cut i p ->
            let assum = TermMan.explode_sequent (Sequent.nth_assum p i) in
            let goal = Sequent.explode_sequent_arg p in
            let len = SeqHyp.length goal.sequent_hyps in
            let () = if len <> SeqHyp.length assum.sequent_hyps then raise err_assum in
            let rec vars subst i =
               if i = len then
                  subst
               else
                  match SeqHyp.get goal.sequent_hyps i, SeqHyp.get assum.sequent_hyps i with
                     Hypothesis (v, _), Hypothesis (v', _) ->
                        vars ((v', mk_var_term v)::subst) (i + 1)
                   | _ ->
                        vars subst (i + 1)
            in
            let assum = apply_subst (vars [] 0) assum.sequent_concl in
            let concl = goal.sequent_concl in
               if alpha_equal assum concl then
                  nthAssumT i
               else
                  let t = mk_nthhyp_pair_term assum concl in
                     match Term_match_table.lookup_bucket tbl select_indep t with
                        Some (NthStep tac :: _)
                      | Some (_ :: NthStep tac :: _)
                      | Some (_ :: _ :: NthStep tac :: _) ->
                           tac thenT nthAssumT i
                      | Some (NthStepTerm tac :: _)
                      | Some (_ :: NthStepTerm tac :: _)
                      | Some (_ :: _ :: NthStepTerm tac :: _) ->
                           tac assum thenT nthAssumT i
                      | Some (NthImmediate tac :: _) ->
                           cut assum thenLT [nthAssumT i; tac (-1)]
                      | Some (NthForward (tac, j) :: _) ->
                           cut assum thenLT [nthAssumT i; tac (-1) thenT nth_hypT j]
                      | Some (NthUncertain _ :: _)
                      | Some (NthForwardUncertain _ :: _)
                      | Some [] ->
                           raise (Invalid_argument "nthHypT: internal error")
                      | None ->
                           raise err);
      })

let add_nth_hyp_data tbl (hyp,concl,tac) =
   add_item tbl (mk_nthhyp_pair_term hyp concl) tac

let resource (term * term * nth_hyp_entry, nth_hyp_result) nth_hyp =
   Functional {
      fp_empty = empty_table;
      fp_add = add_nth_hyp_data;
      fp_retr = extract_nth_hyp_data;
   }

let nthHypT = argfunT (fun i p ->
   (get_resource_arg p get_nth_hyp_resource).nth_hyp i p)

let nth_hyp_mem p =
   (get_resource_arg p get_nth_hyp_resource).nth_hyp_fun

let someNthHypT = funT (fun p ->
   (get_resource_arg p get_nth_hyp_resource).some_nth_hyp p)

let matchAssumT cut = argfunT (fun i p ->
   (get_resource_arg p get_nth_hyp_resource).match_assums cut i p)

let explode t =
   let t = TermMan.explode_sequent t in
      SeqHyp.to_list t.sequent_hyps, t.sequent_concl

let process_nth_hyp_resource_annotation ?labels name args term_args statement loc pre_tactic =
   let assums, goal = unzip_mfunction statement in
      rule_labels_not_allowed loc labels;
      match args.spec_ints, args.spec_addrs, term_args, List.map (fun (_, _, t) -> explode t) assums, explode goal with
         [| _ |], [||], [], [], ([ Context (h, _, _); Hypothesis(v,t1); Context(j, jc, jv) ], t2) ->
            let tac i =
               Tactic_type.Tactic.tactic_of_rule pre_tactic { arg_ints = [| i |]; arg_addrs = [||] } []
            in
            let dependent =
               (is_var_free v t2 && not (
                  is_so_var_term t2 &&
                  match dest_so_var t2 with
                     _, [_; _], [v'] -> is_var_term v' && Lm_symbol.eq v (dest_var v')
                   | _ -> false)) ||
               not(
                  match jc, jv with
                     [h'], [v'] -> Lm_symbol.eq h h' && is_var_term v' && Lm_symbol.eq v (dest_var v')
                   | _ -> false)
            in
               [t1, t2, if dependent then NthUncertain tac else NthImmediate tac]
       | [||], [||], [], [ [Context _], t1 ], ( [Context _], t2) ->
            [t1, t2, NthStep (Tactic_type.Tactic.tactic_of_rule pre_tactic empty_rw_args [])]
       | [||], [||], _, [ [Context _], t1 ], ( [Context _], t2) ->
            let addrs =
               try List.map (fun t -> List.hd (find_subterm t1 (fun t' _ -> alpha_equal t t'))) term_args with
                  _ ->
                     raise (Invalid_argument (sprintf
                        "%s: Auto_tactic.improve_nth_hyp: %s: missing a subterm" (string_of_loc loc) name))
            in
            let tac hyp =
               let terms = List.map (term_subterm hyp) addrs in
                  Tactic_type.Tactic.tactic_of_rule pre_tactic empty_rw_args terms
            in
               [t1, t2, NthStepTerm tac]
       | [| _ |], [||], [],
         [((Context (h , _, _) :: Hypothesis(v, t1 ) :: Context(j , jc, jv) :: rest ), concl)],
          ([Context (h', _, _) ;  Hypothesis(v',t1') ;  Context(j', _ , _ ) ], concl')
          when Lm_symbol.eq h h' && Lm_symbol.eq v v' && alpha_equal t1 t1' && Lm_symbol.eq j j' && alpha_equal concl concl' ->
            let tac i =
               Tactic_type.Tactic.tactic_of_rule pre_tactic { arg_ints = [| i |]; arg_addrs = [||] } []
            in
            let dependent =
               not(
                  match jc, jv with
                     [h'], [v'] -> Lm_symbol.eq h h' && is_var_term v' && Lm_symbol.eq v (dest_var v')
                   | _ -> false)
            in
            let rec collect j = function
               [] -> []
             | Hypothesis(_, t2) :: rest ->
                  let dependent = dependent || is_var_free v t2 in
                  let tac = if dependent then NthForward (tac, j) else NthForwardUncertain (tac, j) in
                     (t1, t2, tac) :: collect (j + 1) rest
             | Context _ :: _ ->
                  raise (Invalid_argument (sprintf
                     "%s: Auto_tactic.improve_nth_hyp: %s: is not an appropriate rule" (string_of_loc loc) name))
            in
               collect (- (List.length rest)) rest
       | [| _ |], [||], [], _ :: _, ([ Context (h, _, _); Hypothesis(v,t1); Context(j, jc, jv) ], t2)
         when not (is_so_var_term t2) ->
            (*
             * XXX: nogin (2006/03/25): Strictly speaking this needs to go into a special section of nthHypT
             * so that autoT would use this only in its "Normal" stage, as it generates subgoals and is not
             * appropriate for the trivialT. But for now, this seems to be a sufficiently minot violation of
             * the trivialT policies.
             *)
            let tac i =
               Tactic_type.Tactic.tactic_of_rule pre_tactic { arg_ints = [| i |]; arg_addrs = [||] } []
            in
               [t1, t2, NthUncertain tac]
       | _ ->
            raise (Invalid_argument (sprintf
               "%s: Auto_tactic.improve_nth_hyp: %s: is not an appropriate rule" (string_of_loc loc) name))

(************************************************************************
 * IMPLEMENTATION - autoT                                               *
 ************************************************************************)

(*
 * We create a DAG to manage ordering in the tree.
 *)
let dag = ImpDag.create ()

(*
 * Sort the nodes in the list.
 *)
let compare node1 node2 =
   Stdlib.compare (ImpDag.node_rel dag node1.auto_prec node2.auto_prec) LessThan

(* unused
let auto_tac tac = tac.auto_tac
 *)

let sort_nodes = List.sort compare

let successT i s = funT (fun p ->
   if !i = 0 then
      eprintf " -> succeded on -------------\n%s%t" s eflush;
   incr i;
   eprintf "-------- and got subgoal %i ---------\n%s\n----------------%t" (!i) (string_of_term (get_mode_base top_bookmark "prl" null_shortener) (Sequent.goal p)) eflush;
   idT)

(*
 * Debugging firstT.
 *)
let debugT auto_tac =
   { auto_tac with
     auto_tac = funT (fun p ->
        let s = string_of_term (get_mode_base top_bookmark "prl" null_shortener) (Sequent.goal p) in
        eprintf "Auto: trying %s%t" auto_tac.auto_name eflush;
        (progressT auto_tac.auto_tac) thenT successT (ref 0) s)
   }

let map_progressT tac =
   { tac with auto_tac = progressT tac.auto_tac }

let trivialP  tac = (tac.auto_type == AutoTrivial)
let normalP   tac = (tac.auto_type == AutoNormal)
let completeP tac = (tac.auto_type == AutoComplete)

(*
 * Build an auto tactic from all of the tactics given.
 * A list of tactics to try is constructed.
 * The earlier tactics should be tried first.
 *)
let make_progressT goals tac tacelse =
   funT (fun p ->
      let goal = Sequent.goal p in
      let shape = shape_of_term goal in
      let shape =
         if shape == sequent_shape then
            shape_of_term (explode_sequent goal).sequent_concl
         else
            shape
      in
         if List.exists (alpha_equal goal) (ShapeMTable.find_all goals shape) then
            tacelse
         else
            tac (ShapeMTable.add goals shape goal))
(*
 * XXX: TODO: this is suboptimal. See http://bugzilla.metaprl.org/show_bug.cgi?id=549
 *)
let ifthenelseT tac1 tac2 tac3 =
   let thenelseT = argfunT (fun t p ->
      if alpha_equal (goal p) t then tac3 else tac2)
   in
      funT (fun p -> tryT tac1 thenT thenelseT (goal p))

let extract tactics =
   let tactics =
      if !debug_auto then List.map debugT tactics
      else List.map map_progressT tactics
   in
   let trivial = sort_nodes (List.filter trivialP tactics) in
   let normal = sort_nodes (List.filter normalP tactics) in
   let complete = sort_nodes (List.filter completeP tactics) in
   if !debug_auto then begin
      let names tacs = String.concat "; " (List.map (fun t -> t.auto_name) tacs) in
      eprintf "Auto tactics:\n\tTrivial: %s\n\tNormal: %s\n\tComplete: %s%t"
         (names trivial) (names normal) (names complete) eflush;
   end;
   let make_progress_first reset next tacloop =
      let rec prog_first tacs goals =
         match tacs with
            [] ->
               next goals
          | tac :: tacs ->
               ifthenelseT tac.auto_tac (make_progressT goals prog_reset tacloop) (prog_first tacs goals)
      and prog_reset goals = prog_first reset goals
      in
         prog_first
   in
   let next_idT _ = idT in
   let next_failT _ = failT in
   let trivT = make_progress_first trivial next_idT idT trivial ShapeMTable.empty in
   let normal_tacs = trivial @ normal in
   let all_tacs = trivial @ normal @ complete in
   let try_complete goals = tryT (make_progress_first all_tacs next_failT failT complete goals) in
   let autoT = make_progress_first normal_tacs try_complete idT normal_tacs ShapeMTable.empty in
   let strongAutoT = make_progress_first all_tacs next_idT idT all_tacs ShapeMTable.empty in
   let caT = make_progress_first all_tacs next_failT failT all_tacs ShapeMTable.empty in
      (trivT, autoT, strongAutoT, caT)

let improve_resource data info = info::data

(*
 * Resource.
 *)
let resource (auto_info, tactic * tactic * tactic * tactic) auto =
   Functional {
      fp_empty = [];
      fp_add = improve_resource;
      fp_retr = extract
   }

(*
 * Create a precedence.
 *)
let create_auto_prec before after =
   let node = ImpDag.insert dag () in
      List.iter (fun p -> ImpDag.add_edge dag p node) before;
      List.iter (fun p -> ImpDag.add_edge dag node p) after;
      node

(*
 * Use the tactic as long as progress is being made.
 *)
(* unused
let rec check_progress goal = function
   goal' :: goals ->
      if alpha_equal goal goal' then
         true
      else
         check_progress goal goals
 | [] ->
      false
 *)

(*
 * Actual tactics.
 *)
let trivialT =
   funT (fun p -> let trivT, _, _, _ = get_resource_arg p get_auto_resource in trivT)

let autoT =
   funT (fun p -> let _, autoT, _, _ = get_resource_arg p get_auto_resource in autoT)

let strongAutoT =
   funT (fun p -> let _, _, sAutoT, _ = get_resource_arg p get_auto_resource in sAutoT)

let completeAutoT =
   funT (fun p -> let _, _, _, tca = get_resource_arg p get_auto_resource in tca)

let tcaT = tryT completeAutoT

let prefix_ttca tac =
   tac thenT tcaT

suffix ttca

let prefix_tatca tac =
   tac thenAT tcaT

suffix tatca

let prefix_twtca tac =
   tac thenWT tcaT

suffix twtca

let prefix_taa tac =
   tac thenAT autoT

suffix taa

let prefix_twa tac =
   tac thenWT autoT

suffix twa

let prefix_ta tac =
   tac thenT autoT

suffix ta

let make_defT =
   let mk_progress t =
      termC (fun t' -> if alpha_equal t t' then failC else idC)
   in
   let progress_reduce conv =
      termC (fun t -> conv thenC tryC (reduceC thenC mk_progress t))
   in
      fun conv -> rwhAllAll (progress_reduce conv)

let byDefT conv = make_defT conv thenT autoT
let byDefsT convs = seqT (List.map make_defT convs) thenT autoT

let repeatWithRwsT convs tac  = repeatT (firstT (List.map (fun conv-> progressT (rwh conv 0) thenT tac ) convs))

(*
 * Trivial is in auto tactic.
 *)
let trivial_prec = create_auto_prec [] []
let nth_hyp_prec = create_auto_prec [trivial_prec] []
let reduce_concl_prec = create_auto_prec [nth_hyp_prec] []
let reduce_hyps_prec = create_auto_prec [reduce_concl_prec] []
let large_prec = create_auto_prec [reduce_hyps_prec] []

(*
 * Some trivial tactics.
 *)
let resource auto += [{
   auto_name = "nthHypT/nthAssumT";
   auto_prec = nth_hyp_prec;
   auto_tac = someNthHypT orelseT onSomeAssumT nthAssumT;
   auto_type = AutoTrivial;
}; {
   auto_name = "simpleReduceT";
   auto_prec = reduce_hyps_prec;
   auto_tac = simpleReduceT;
   auto_type = AutoNormal
}; {
   auto_name = "rw reduceC 0";
   auto_prec = reduce_concl_prec;
   auto_tac = rw reduceC 0;
   auto_type = AutoComplete
}; {
   auto_name = "reduceHypsT";
   auto_prec = reduce_hyps_prec;
   auto_tac = reduceHypsT;
   auto_type = AutoComplete
}]

(*
 * Add autoT to the browser.
 *)
let resource menubar +=
    [<< menuitem["refine", "autoT", "Command('refine autoT')"] >>, refine_is_enabled]

(* This one will get the topval wrapping *)
let tcaT = tcaT

(*
 * -*-
 * Local Variables:
 * End:
 * -*-
 *)
