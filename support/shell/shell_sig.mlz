(*
 * This is the generic editing interface.
 *
 * ----------------------------------------------------------------
 *
 * This file is part of MetaPRL, a modular, higher order
 * logical framework that provides a logical programming
 * environment for OCaml and other languages.
 *
 * See the file doc/index.html for information on Nuprl,
 * OCaml, and more information about this system.
 *
 * Copyright (C) 1998 Jason Hickey, Cornell University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Jason Hickey <jyh@cs.cornell.edu>
 * Modified By: Aleksey Nogin <nogin@cs.caltech.edu>
 *)
open Opname
open Refiner.Refiner.Refine
open Refiner.Refiner
open Dform

open Tactic_type.Tactic
open Mp_resource
open MLast

open Filter_type

open Shell_util

(*
 * These are the values that we recognize in MetaPRL toploop.
 *)
type top_expr =
   (* Base types *)
   UnitExpr of unit
 | BoolExpr of bool
 | IntExpr of int
 | StringExpr of string
 | TermExpr of term
 | TacticExpr of tactic
 | ConvExpr of conv
 | AddressExpr of address

   (* Uptyped tuples and functions *)
 | ListExpr of top_expr list

   (* Common cases are typed *)
 | UnitFunExpr of (unit -> top_expr)
 | BoolFunExpr of (bool -> top_expr)
 | IntFunExpr of (int -> top_expr)
 | StringFunExpr of (string -> top_expr)
 | TermFunExpr of (term -> top_expr)
 | TacticFunExpr of (tactic -> top_expr)
 | IntTacticFunExpr of ((int -> tactic) -> top_expr)
 | ConvFunExpr of (conv -> top_expr)
 | AddressFunExpr of (address -> top_expr)

   (* These functions take lists *)
 | IntListFunExpr of (int list -> top_expr)
 | StringListFunExpr of (string list -> top_expr)
 | TermListFunExpr of (term list -> top_expr)
 | TacticListFunExpr of (tactic list -> top_expr)
 | ConvListFunExpr of (conv list -> top_expr)

   (* Internal use only *)
 | FunExpr of (top_expr -> top_expr)
 | ApplyExpr of (loc * top_expr) * (loc * top_expr)
 | VarExpr of string
 | VarProjExpr of string list * string

(*
 * These are the possible types of the top_expr's.
 *)
type top_type =
   UnitType
 | BoolType
 | IntType
 | StringType
 | TermType
 | TacticType
 | ConvType
 | AddressType
 | ListType of top_type
 | NilType  (* 'a list *)
 | ConsType (* 'a -> 'a list -> 'a list *)
 | FunType of top_type * top_type

type obj_status =
   ObjPrimitive
 | ObjDerived
 | ObjComplete of int*int
 | ObjIncomplete of int*int
 | ObjBad
 | ObjUnknown

type ref_status =
   RefPrimitive
 | RefComplete of int * int * ((Refine_sig.dependency * opname) list)
 | RefUngrounded of int * int * opname
 | RefIncomplete of int * int

type obj_contents = string * obj_status * meta_term * term Filter_type.param list

(*
 * Possible commands.
 *)
type proof_command =
   ProofRefine of string * MLast.expr * tactic
 | ProofUndo
 | ProofRedo
 | ProofNop
 | ProofKreitz
 | ProofUp of int
 | ProofDown of int
 | ProofRoot
 | ProofAddr of int list
 | ProofRotate of int
 | ProofCopy of string
 | ProofPaste of string
 | ProofCp of int list * int list
 | ProofExpand
 | ProofMakeAssum
 | ProofClean
 | ProofSquash

(*
 * Display state
 *)
type display_type =
   DisplayText
 | DisplayTex
 | DisplayBrowser

(*
 * Full display information
 *)
type display_method = {
   df_type : display_type;
   df_base : dform_mode_base;
   df_mode : string;
   df_width : int;
}

type display_fun = unit -> display_method

(*
 * Info for proof-type objects.
 *)
type edit_info =
   { edit_goal : tactic_arg;
     edit_expr : string;
     edit_subgoals : tactic_arg list;
     edit_extras : tactic_arg list
   }

(*
 * An editable object.
 *)
type edit_object =
   { (* Display the object to the screen *)
     edit_display      : LsOptionSet.t -> unit;
     edit_get_contents : unit -> obj_contents;
     edit_get_terms    : unit -> term list;

     (* Copy the object *)
     edit_copy         : unit -> edit_object;

     (* Adjust the contents of the object *)
     edit_set_goal        : term -> unit;
     edit_set_redex       : term -> unit;
     edit_set_contractum  : term -> unit;
     edit_set_assumptions : term list -> unit;
     edit_set_params      : term Filter_type.param list -> unit;
     edit_save            : unit -> unit;
     edit_get_extract     : unit -> Refine.extract;
     edit_check           : unit -> ref_status;

     (* Navigation if there is a proof *)
     edit_interpret : proof_command -> unit;
     edit_undo      : unit -> unit;
     edit_redo      : unit -> unit;
     edit_addr      : string list -> unit; (* This operation must be atomic: if it fails, the address is not modified *)
     edit_int_addr  : int list -> unit; (* This is the same as the operation above, but with integer address *)
     edit_info      : unit -> edit_info;
     edit_refine    : string -> MLast.expr -> tactic -> unit;
     edit_find      : int -> int list; (* find a subgoal; edit_addr is a side-effect *)

     (* Filesystem directory *)
     edit_fs_cwd    : unit -> string
   }

(*
 * Save status of a module.
 *)
type package_status =
   PackUnmodified
 | PackModified
 | PackReadOnly (* XXX: BUG? We only ever check for this, but never actually set it! nogin 2004/06/03 *)
 | PackIncomplete

(*
 * Values needed for parsing.
 *)
type parse_arg = ((string -> MLast.expr) * (MLast.expr -> tactic))

(*
 * This exception is raised when a package is requested,
 * and it has not been loaded.
 *)
exception NotLoaded of string

(*
 * These are the functions provided by the shell.
 *)
module type ShellMainSig =
sig
   val main : unit -> unit
end

(*
 * Nuprl5 editor interface.
 *)
module type ShellEditSig =
sig
   val list_modules     : unit -> string list
   val list_module_all  : string -> string list
   val list_module      : string -> string list * string list * string list * string list
   val list_module_rw   : string -> string list
   val list_parents     : string -> string list
   val list_dforms      : string -> (string * dform_modes * term list * term * term) list
   val list_precs       : string -> term list
   val list_prec_rels   : string -> (string * term * term) list
   val cd_list_contents : string -> obj_contents list (* side-effect: cd's into the specified module *)
   val create_thm       : string -> string -> unit
   val create_rw        : string -> string -> unit
   val cd_thm           : string -> string -> unit
   val save             : string -> unit
   val set_goal         : string -> string -> term -> unit
   val set_redex        : string -> string -> term -> unit
   val set_contractum   : string -> string -> term -> unit
   val set_assumptions  : string -> string -> term list -> unit
   val set_params       : string -> string -> term Filter_type.param list -> unit
   val refine           : int list -> string -> msequent * msequent list * msequent list
   val node             : int list -> string option * msequent * msequent list * msequent list
   val undo             : unit -> unit
end

(*
 * Extra functions for the browser.
 *)
module type ShellTopSig =
sig
   (* Intialize the shell and the display mode *)
   val init : unit -> unit

   (* Navigation *)
   val chdir        : string -> bool
   val refresh      : unit -> unit
   val pwd          : unit -> string
   val filename     : unit -> string option

   (* Backup all files *)
   val backup_all   : unit -> unit

   (* Viewing options for the flush function *)
   val get_ls_options     : unit -> LsOptionSet.t
   val get_view_options   : unit -> string
   val set_view_options   : string -> unit
   val clear_view_options : string -> unit
   val get_shortener      : unit -> Dform.shortener

   (* General display options *)
   val set_dfmode : string -> unit
   val set_dftype : display_type -> unit
   val set_window_width : int -> unit

   (* Evaluate a string in the current shell *)
   val eval         : string -> unit

   (* Resources *)
   val get_resource : unit -> global_resource

   (* Make sure all buffers are flushed *)
   val flush : unit -> unit
end

(*
 * All the interfaces.
 *)
module type ShellAllSig =
sig
   module Main : ShellMainSig
   module Edit : ShellEditSig
   module Top  : ShellTopSig
end

(*
 * -*-
 * Local Variables:
 * Caml-master: "refiner"
 * End:
 * -*-
 *)
