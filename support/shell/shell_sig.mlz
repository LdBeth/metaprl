(*
 * This is the generic editing interface.
 *
 * ----------------------------------------------------------------
 *
 * This file is part of MetaPRL, a modular, higher order
 * logical framework that provides a logical programming
 * environment for OCaml and other languages.
 *
 * See the file doc/index.html for information on Nuprl,
 * OCaml, and more information about this system.
 *
 * Copyright (C) 1998 Jason Hickey, Cornell University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Jason Hickey <jyh@cs.cornell.edu>
 * Modified By: Aleksey Nogin <nogin@cs.caltech.edu>
 *)

open Refiner.Refiner.Term
open Refiner.Refiner.TermType
open Refiner.Refiner.Refine
open Refiner.Refiner
open Rformat
open Dform
open Dform_print

open Tactic_type.Tactic
open Proof_edit
open MLast

(*
 * Create either in text mode,
 * or in window mode.
 *)
type display_mode =
   DisplayText of dform_mode_base * string
 | DisplayTex of dform_mode_base
 | DisplayGraphical of Mux_channel.session * dform_mode_base

(*
 * Options to the "ls" command.
 *)
type ls_option =
   LsRewrites
 | LsRules
 | LsUnjustified
 | LsNoSummaryItems
 | LsFormal
 | LsAll

(*
 * These are the values that we recognize in MetaPRL toploop.
 *)
type top_expr =
   (* Base types *)
   UnitExpr of unit
 | BoolExpr of bool
 | IntExpr of int
 | StringExpr of string
 | TermExpr of term
 | TacticExpr of tactic
 | ConvExpr of conv
 | AddressExpr of address

   (* Uptyped tuples and functions *)
 | ListExpr of top_expr list

   (* Common cases are typed *)
 | UnitFunExpr of (unit -> top_expr)
 | BoolFunExpr of (bool -> top_expr)
 | IntFunExpr of (int -> top_expr)
 | StringFunExpr of (string -> top_expr)
 | TermFunExpr of (term -> top_expr)
 | TacticFunExpr of (tactic -> top_expr)
 | IntTacticFunExpr of ((int -> tactic) -> top_expr)
 | ConvFunExpr of (conv -> top_expr)
 | AddressFunExpr of (address -> top_expr)

   (* These functions take lists *)
 | IntListFunExpr of (int list -> top_expr)
 | StringListFunExpr of (string list -> top_expr)
 | TermListFunExpr of (term list -> top_expr)
 | TacticListFunExpr of (tactic list -> top_expr)
 | ConvListFunExpr of (conv list -> top_expr)

   (* Internal use only *)
 | FunExpr of (top_expr -> top_expr)
 | ApplyExpr of (loc * top_expr) * (loc * top_expr)
 | VarExpr of string
 | VarProjExpr of string list * string

(*
 * These are the possible types of the top_expr's.
 *)
type top_type =
   UnitType | BoolType | IntType | StringType | TermType | TacticType | ConvType | AddressType
 | ListType of top_type
 | NilType  (* 'a list *)
 | ConsType (* 'a -> 'a list -> 'a list *)
 | FunType of top_type * top_type

(*
 * An editable object.
 *)
type edit_object =
   { (* Display the object to the screen *)
     edit_display : ls_option list -> unit;
     edit_get_contents : unit -> obj_contents;
     edit_get_terms : unit -> term list;

     (* Copy the object *)
     edit_copy : unit -> edit_object;

     (* Adjust the contents of the object *)
     edit_set_goal : term -> unit;
     edit_set_redex : term -> unit;
     edit_set_contractum : term -> unit;
     edit_set_assumptions : term list -> unit;
     edit_set_params : term Filter_type.param list -> unit;
     edit_save : unit -> unit;
     edit_expand : dform_base -> unit;
     edit_check : dform_base -> Refine.extract;

     (* Navigation if there is a proof *)
     edit_interpret : proof_command -> unit;
     edit_root : unit -> unit;
     edit_up : int -> unit;
     edit_down : int -> unit;
     edit_undo : unit -> unit;
     edit_redo : unit -> unit;
     edit_addr : int list -> unit;           (* This operation must be atomic: if it fails, the address is not modified *)
     edit_info : unit -> edit_info;
     edit_refine : string -> MLast.expr -> tactic -> unit;
   }

(*
 * These are the functions provided by the shell.
 *)
module type ShellSig =
sig
   type t

   (*
    * Main loop.
    *)
   val main : unit -> unit

   (*
    * Job control.
    *)
   val get_current_shell : unit -> t
   val fork : t -> string
   val pid : t -> string
   val jobs : t -> string
   val fg : t -> int -> string

   (*
    * This is the interface to the HTTP shell.
    * Not available from the toploop.
    *)
   val eval : int -> string -> unit
   val set_port : Mux_channel.session option -> unit

   (*
    * Navigation and display.
    *)
   val cd : t -> string -> string
   val pwd : t -> string
   val set_dfmode : t -> string -> unit
   val set_window_width : t -> int -> unit

   (*
    * Module commands.
    *)
   val create_pkg : t -> string -> unit
   val set_writeable : t -> unit
   val save : t -> unit
   val export : t -> unit

   (*
    * The possible objects in a package.
    *)
   val create_rw : t -> string -> unit
   val create_axiom : t -> string -> unit
   val create_thm : t -> string -> unit
   val create_ax_statement : t -> term -> string -> unit
   val create_opname : t -> string -> unit
   val create_condition : t -> string -> unit
   val create_parent : t -> string -> unit
   val create_dform : t -> string -> unit
   val create_prec : t -> string -> unit
   val create_prec_rel : t -> string -> string -> string -> unit
   val create_resource : t -> string -> unit
   val create_infix : t -> string -> unit
   val create_ml : t -> string -> unit

   (*
    * Editing commands.
    *)
   val set_goal : t -> term -> unit
   val set_redex : t -> term -> unit
   val set_contractum : t -> term -> unit
   val set_assumptions : t -> term list -> unit
   val set_params : t -> term Filter_type.param list -> unit
   val check : t -> unit
   val expand : t -> unit

   (*
    * Proof editing.
    *)
   val goal : t -> tactic_arg
   val refine : t -> tactic -> unit
   val undo : t -> unit
   val redo : t -> unit
   val sync : t -> unit
   val expand_all : t -> unit

   (*
    * Nuprl5 interface.
    *)
   val edit_list_modules : t -> string list
   val edit_list_module_all : t -> string -> string list
   val edit_list_module : t -> string -> string list * string list * string list * string list
   val edit_list_module_rw : t -> string -> string list
   val edit_list_parents : t -> string -> string list
   val edit_list_dforms : t -> string -> (string * Filter_type.dform_modes * term list * term * term) list
   val edit_list_precs : t -> string -> term list
   val edit_list_prec_rels : t -> string -> (string * term * term) list
   val edit_cd_list_contents : t -> string -> obj_contents list (* side-effect: cd's into the specified module *)
   val edit_create_thm : t -> string -> string -> unit
   val edit_create_rw : t -> string -> string -> unit
   val edit_cd_thm : t -> string -> string -> unit
   val edit_save : t -> string -> unit
   val edit_set_goal : t -> string -> string -> term -> unit
   val edit_set_redex : t -> string -> string -> term -> unit
   val edit_set_contractum : t -> string -> string -> term -> unit
   val edit_set_assumptions : t -> string -> string -> term list -> unit
   val edit_set_params : t -> string -> string -> term Filter_type.param list -> unit
   val edit_refine : t -> int list -> string -> msequent * msequent list * msequent list
   val edit_node : t -> int list -> string option * msequent * msequent list * msequent list
   val edit_undo : t -> unit
end

(*
 * HTTP wrapper redefines main function.
 *)
module type ShellHTTPSig =
sig
   val main : unit -> unit
end

(*
 * -*-
 * Local Variables:
 * Caml-master: "refiner"
 * End:
 * -*-
 *)
