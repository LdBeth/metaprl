(*
 * This file contains the primitive syntax and display
 * for ocaml terms.
 *
 * ----------------------------------------------------------------
 *
 * This file is part of MetaPRL, a modular, higher order
 * logical framework that provides a logical programming
 * environment for OCaml and other languages.
 *
 * See the file doc/index.html for information on Nuprl,
 * OCaml, and more information about this system.
 *
 * Copyright (C) 1998 Jason Hickey, Cornell University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Jason Hickey
 * jyh@cs.cornell.edu
 *)

extends Perv

(************************************************************************
 * EXPRESSIONS                                                          *
 ************************************************************************)

declare typeclass Ocaml -> Dform

(*
 * Lists.
 *)
declare "onil" : Ocaml
declare "ocons"{'hd : Ocaml; 'tl : Ocaml} : Ocaml

(*
 * Constants.
 *)
declare "unit" : Ocaml
declare "bool"[f:s] : Ocaml
declare "char"[c:s] : Ocaml
declare "int"[i:n] : Ocaml
declare "string"[s:s] : Ocaml
declare "float"[s:s] : Ocaml
declare "true" : Ocaml
declare "false" : Ocaml

declare "lid"{'v : Ocaml} : Ocaml
declare "lid"[s:s] : Ocaml
declare "uid"{'v : Ocaml} : Ocaml
declare "uid"[s:s] : Ocaml

(*
 * Primitive operations on numbers.
 *)
declare lt_int{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare le_int{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare eq_int{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare ge_int{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare gt_int{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

declare add{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare sub{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare mul{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare div{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare "mod"{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

(*
 * Primitive operations on booleans.
 *)
declare "or"{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare "and"{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare "not"{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

(*
 * Projection.
 *)
declare proj{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

(*
 * Application.
 *)
declare apply{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare inj{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

(*
 * Subscripting.
 *)
declare string_subscript{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare array_subscript{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

declare string_set{'e1 : Ocaml; 'e2 : Ocaml; 'e3 : Ocaml} : Ocaml
declare array_set{'e1 : Ocaml; 'e2 : Ocaml; 'e3 : Ocaml} : Ocaml

(*
 * Sequences.
 *)
declare list{'e1 : Ocaml} : Ocaml
declare array{'e1 : Ocaml} : Ocaml
declare stream{'e1 : Ocaml} : Ocaml
declare record{'e1 : Ocaml;'e2 : Ocaml} : Ocaml

declare tuple{'e : Ocaml} : Ocaml

(*
 * Assignment.
 *)
declare assign{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare record_set{'e1 : Ocaml; 'e2 : Ocaml; 'e3 : Ocaml} : Ocaml

(*
 * Sequencing.
 *)
declare sequence{'e1 : Ocaml} : Ocaml

(*
 * Conditional.
 *)
declare "ifthenelse"{'e1 : Ocaml; 'e2 : Ocaml; 'e3 : Ocaml} : Ocaml

(*
 * Loops.
 *)
declare for_upto{'e1 : Ocaml; 'e2 : Ocaml; x. 'e3 : Ocaml} : Ocaml
declare for_downto{'e1 : Ocaml; 'e2 : Ocaml; x. 'e3 : Ocaml} : Ocaml
declare "while"{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

(*
 * Type casting.
 *)
declare cast{'e : Ocaml; 't : Ocaml} : Ocaml

(*
 * Class coercion.
 *)
declare class_coerce{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

(*
 * New object.
 *)
declare "new"{'e1 : Ocaml} : Ocaml

(*
 * Exceptions.
 *)
declare "try"{'e : Ocaml; 'pwel : Ocaml} : Ocaml
declare "raise"{'e : Ocaml} : Ocaml

(*
 * "Match" forms.
 *)
declare "fun"{'pwel : Ocaml} : Ocaml
declare "match"{'e : Ocaml; 'pwel : Ocaml} : Ocaml

(*
 * "Let" forms.  The real work is performed in the patterns.
 *)
declare "let"{'p : Ocaml; 'e : Ocaml} : Ocaml
declare "fix"{'pel : Ocaml} : Ocaml

(*
 * Pairing.
 *)
declare "ee"{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

(*
 * Options in AST
 *)
declare none : Ocaml
declare some{'e : Ocaml} : Ocaml

(************************************************************************
 * PATTERNS                                                             *
 ************************************************************************)

(*
 * Display forms for patterns are a problem, because the innermost term is the
 * term to be evaluated under all the pattern bindings.
 * We contruct the pattern term and extract the inner expression.
 * Patterns are collected on a stack.
 *
 * Here is how a "let" expression looks:
 *    1. let : (p1, e1), ..., (pn, en), e
 *       let{pl; el}, where
 *       pl = patt_arg{...; patt_end{... patt_in{e}}}
 *       el = cons{e1; cons{e2; ... nil}}
 *
 * Here is how a "match" expression looks:
 *    2. match e, (p1, w1, e1), ..., (pn, wn, en)
 *       match{patt_ifelse{pwe1; patt_ifelse{pwe2; ... patt_if{pwen}}}}
 *       where
 *          pwe = patt_* ... {we}
 *          we  = patt_with{w; e} | patt_body{e}
 *
 * Here is how a "let rec" expression looks:
 * The arguments are _inside_ the pattern.
 *    3. letrec (p1, e1), ..., (pn, en), e
 *       fix{x.let{pl; x}}, where
 *       pl = patt_arg{...; patt_end{... patt_match{e1; ... patt_in{e}}}}
 *
 * BUG!!! nogin: the actual code in filter/base/filter_ocaml does
 * something else, there is no bound variable in the fix term in creates!
 *
 * These three forms are different, but we can combine their
 * display forms somewhat.
 *
 * Display forms have three arguments.
 *    1. key: (patt_format usually)
 *    2. current pattern
 *    3. stack of terms representing the pattern being constructed
 *
 * For the "let" form, we initialize the stack with the list "el".
 *)

(*
 * Constant.
 *)
declare patt_char[c:s] : Ocaml
declare patt_int[i:n] : Ocaml
declare patt_string[s:s] : Ocaml
declare patt_float[f:s] : Ocaml

(*
 * Binding.
 *)
declare patt_var{x. 'p : Ocaml} : Ocaml
declare patt_lid{'p1 : Ocaml; 'p2 : Ocaml} : Ocaml
declare patt_lid[name:s] : Ocaml
declare patt_uid{'p1 : Ocaml; 'p2 : Ocaml} : Ocaml
declare patt_uid[name:s] : Ocaml

(*
 * Typed pattern.
 *)
declare patt_coerce{'p : Ocaml; 't : Ocaml} : Ocaml

(*
 * Projection.
 *)
declare patt_proj{'p : Ocaml} : Ocaml
declare patt_proj_arg{'p : Ocaml} : Ocaml
declare patt_proj_end{'p : Ocaml} : Ocaml

(*
 * Simultaneous match.
 *)
declare patt_as{'p : Ocaml} : Ocaml
declare patt_as_arg{'p : Ocaml} : Ocaml
declare patt_as_end{'p : Ocaml} : Ocaml

(*
 * Wildcard.
 *)
declare patt_wildcard{'p : Ocaml} : Ocaml

(*
 * Application.
 *)
declare patt_apply{'p : Ocaml} : Ocaml
declare patt_apply_arg{'p : Ocaml} : Ocaml
declare patt_apply_end{'p : Ocaml} : Ocaml

(*
 * Alternates.
 *)
declare patt_choice{'p : Ocaml} : Ocaml
declare patt_choice_arg{'p : Ocaml} : Ocaml
declare patt_choice_end{'p : Ocaml} : Ocaml

(*
 * Range of choices.
 *)
declare patt_range{'p : Ocaml} : Ocaml
declare patt_range_arg{'p : Ocaml} : Ocaml
declare patt_range_end{'p : Ocaml} : Ocaml

(*
 * List pattern.
 *)
declare patt_list{'p : Ocaml} : Ocaml
declare patt_list_arg{'p : Ocaml} : Ocaml
declare patt_list_end{'p : Ocaml} : Ocaml

(*
 * Tuple pattern.
 *)
declare patt_tuple{'p : Ocaml} : Ocaml
declare patt_tuple_arg{'p : Ocaml} : Ocaml
declare patt_tuple_end{'p : Ocaml} : Ocaml

(*
 * Record pattern.
 *)
declare patt_record{'p : Ocaml} : Ocaml
declare patt_record_proj{'n : Ocaml; 'p : Ocaml} : Ocaml
declare patt_record_end{'p : Ocaml} : Ocaml

(*
 * "Let" forms.
 * Clauses are delimited by patt_and.
 * The stack contains one of the following:
 *    patt_let: this is the first clause of a let
 *    patt_and: this is the second or greater clause of a let
 *    patt_fix: this is a clause of a fix
 *)
declare patt_and{'p : Ocaml} : Ocaml
declare patt_in{'e : Ocaml} : Ocaml
declare patt_done : Ocaml
declare patt_match{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare patt_fix_and{'p : Ocaml} : Ocaml
declare patt_fix_arg{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

(*
 * "Match" forms.
 *)
declare patt_ifelse{'pwe : Ocaml; 'pwel : Ocaml} : Ocaml
declare patt_if{'pwe : Ocaml} : Ocaml
declare patt_with{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare patt_body{'e1 : Ocaml} : Ocaml

(************************************************************************
 * TYPES                                                                *
 ************************************************************************)

(*
 * Constant types.
 *)
declare type_unit : Ocaml
declare type_bool : Ocaml
declare type_char : Ocaml
declare type_string : Ocaml
declare type_int : Ocaml
declare type_float : Ocaml

(*
 * Projection.
 *)
declare type_proj{'t1 : Ocaml; 't2 : Ocaml} : Ocaml

(*
 * "As" type.
 *)
declare type_as{'t1 : Ocaml; 't2 : Ocaml} : Ocaml

(*
 * Wildcard type.
 *)
declare type_wildcard : Ocaml

(*
 * Application.
 *)
declare type_apply{'t1 : Ocaml; 't2 : Ocaml} : Ocaml

(*
 * Function type.
 *)
declare type_fun{'t1 : Ocaml; 't2 : Ocaml} : Ocaml

(*
 * Class identifier.
 *)
declare type_class_id{'t1 : Ocaml} : Ocaml

(*
 * Identifiers.
 *)
declare type_lid[v:s] : Ocaml
declare type_uid[v:s] : Ocaml
declare type_lid{'v : Ocaml} : Ocaml
declare type_uid{'v : Ocaml} : Ocaml

(*
 * Type parameter.
 *)
declare type_param[s:s] : Ocaml

(*
 * Type equivalence.
 *)
declare type_equal{'t1 : Ocaml; 't2 : Ocaml} : Ocaml

(*
 * Sequence types.
 *)
declare type_list{'t : Ocaml} : Ocaml
declare type_array{'t : Ocaml} : Ocaml

(*
 * Record type.
 * I'm not sure what the boolean is for.
 *)
declare type_record{'sbtl : Ocaml} : Ocaml
declare type_record_elem[s:s, b:s]{'t : Ocaml} : Ocaml
declare type_ref{'t : Ocaml} : Ocaml

(*
 * Product types.
 *)
declare type_prod{'tl : Ocaml} : Ocaml

(*
 * Pairing.
 *)
declare sbt{'s : Ocaml; 'b : Ocaml; 't : Ocaml} : Ocaml
declare stl{'s : Ocaml; 'tl : Ocaml} : Ocaml

(************************************************************************
 * SIGNATURE ITEMS                                                      *
 ************************************************************************)

(*
 * Signatures and structures are treated as records.
 * Their names are strings, not variables, and they do not
 * alpha-vary.  We could have external and internal names
 * like Harper's translucent sums, but we would diverge
 * from the ocaml type theory.
 *)

(*
 * Exception declarations name type constructors.
 *)
declare sig_exception[name:s]{'tl : Ocaml} : Ocaml

(*
 * External function declaration.
 *)
declare sig_external[name:s]{'t : Ocaml; 'sl : Ocaml} : Ocaml

(*
 * Module declaration.
 *)
declare sig_module[name:s]{'mt : Ocaml} : Ocaml

(*
 * Module type declaration.
 *)
declare sig_module_type[name:s]{'mt : Ocaml} : Ocaml

(*
 * Open a module in scope.
 *)
declare sig_open{'sl : Ocaml} : Ocaml

(*
 * Type declaration.
 *)
declare sig_type{'tdl : Ocaml} : Ocaml

(*
 * Value declaration.
 *)
declare sig_value[name:s]{'t : Ocaml} : Ocaml

(************************************************************************
 * STRUCTURE ITEMS                                                      *
 ************************************************************************)

(*
 * Exception declarations name type constructors.
 *)
declare str_exception[name:s]{'tl : Ocaml} : Ocaml

(*
 * External function declaration.
 *)
declare str_external[name:s]{'t : Ocaml; 'sl : Ocaml} : Ocaml

(*
 * Unnamed value.
 *)
declare str_expr{'e : Ocaml} : Ocaml

(*
 * Module definition.
 *)
declare str_module[name:s]{'me : Ocaml} : Ocaml

(*
 * Module type definition.
 *)
declare str_module_type[name:s]{'mt : Ocaml} : Ocaml

(*
 * Open a module in scope.
 *)
declare str_open{'sl : Ocaml} : Ocaml

(*
 * Type definition
 *)
declare str_type{'tdl : Ocaml} : Ocaml

(*
 * Value definition.
 *)
declare str_let{'p : Ocaml; 'e : Ocaml} : Ocaml
declare str_let{'e : Ocaml} : Ocaml
declare str_fix{'p : Ocaml} : Ocaml

(*
 * Type declaration.
 *)
declare tdl{'s : Ocaml; 'sl : Ocaml; 't : Ocaml; 'tc : Ocaml} : Ocaml

(*
 * Type constraint in type declaration
 *)
declare tc{'t1 : Ocaml; 't2 : Ocaml} : Ocaml

(************************************************************************
 * MODULE TYPE                                                          *
 ************************************************************************)

(*
 * Projection.
 *)
declare mt_proj{'mt1 : Ocaml; 'mt2 : Ocaml} : Ocaml

(*
 * Application.
 *)
declare mt_apply{'mt1 : Ocaml; 'mt2 : Ocaml} : Ocaml

(*
 * Functor.
 *)
declare mt_functor[name:s]{'mt1 : Ocaml; 'mt2 : Ocaml} : Ocaml

(*
 * Id.
 *)
declare mt_lid[name:s] : Ocaml
declare mt_lid{'name : Ocaml} : Ocaml
declare mt_uid[name:s] : Ocaml
declare mt_uid{'name : Ocaml} : Ocaml

(*
 * Signature.
 *)
declare mt_sig{'sil : Ocaml} : Ocaml

(*
 * Module type with clause.
 *)
declare mt_with{'mt : Ocaml; 'wcl : Ocaml} : Ocaml

(*
 * With clauses.
 * I'm not sure what these mean.
 *)
declare wc_type{'sl1 : Ocaml; 'sl2 : Ocaml; 't : Ocaml} : Ocaml
declare wc_module{'sl1 : Ocaml; 'mt : Ocaml} : Ocaml

(************************************************************************
 * MODULE EXPRESSION                                                    *
 ************************************************************************)

(*
 * Projection.
 *)
declare me_proj{'me1 : Ocaml; 'me2 : Ocaml} : Ocaml

(*
 * Application.
 *)
declare me_apply{'me1 : Ocaml; 'me2 : Ocaml} : Ocaml

(*
 * Functor.
 *)
declare me_functor[name:s]{'mt : Ocaml; 'me : Ocaml} : Ocaml

(*
 * Structure.
 *)
declare me_struct{'sil : Ocaml} : Ocaml

(*
 * Type cast.
 *)
declare me_cast{'me : Ocaml; 'mt : Ocaml} : Ocaml

(*
 * Variables.
 *)
declare me_lid[name:s] : Ocaml
declare me_uid[name:s] : Ocaml

(*
 * Locations
 *)

declare "apply"[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare "array"[start:n, finish:n]{'e1 : Ocaml} : Ocaml
declare "array_subscript"[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare assign[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare cast[start:n, finish:n]{'e : Ocaml; 't : Ocaml} : Ocaml
declare "char"[start:n, finish:n, c:s] : Ocaml
declare class_coerce[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare "fix"[start:n, finish:n]{'p : Ocaml} : Ocaml
declare "float"[start:n, finish:n, f:s] : Ocaml
declare for_downto[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml; x. 'e3 : Ocaml} : Ocaml
declare for_upto[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml; x. 'e3 : Ocaml} : Ocaml
declare "fun"[start:n, finish:n]{'pwel : Ocaml} : Ocaml
declare ifthenelse[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml; 'e3 : Ocaml} : Ocaml
declare "int"[start:n, finish:n, i:n] : Ocaml
declare "let"[start:n, finish:n]{'p : Ocaml; 'e : Ocaml} : Ocaml
declare "lid"[start:n, finish:n]{'v : Ocaml} : Ocaml
declare "list"[start:n, finish:n]{'e1 : Ocaml} : Ocaml
declare "match"[start:n, finish:n]{'e : Ocaml; 'pwel : Ocaml} : Ocaml
declare mt_apply[start:n, finish:n]{'mt1 : Ocaml; 'mt2 : Ocaml} : Ocaml
declare mt_functor[start:n, finish:n, name:s]{'mt1 : Ocaml; 'mt2 : Ocaml} : Ocaml
declare mt_lid[start:n, finish:n]{'v : Ocaml} : Ocaml
declare mt_proj[start:n, finish:n]{'mt1 : Ocaml; 'mt2 : Ocaml} : Ocaml
declare mt_sig[start:n, finish:n]{'sil : Ocaml} : Ocaml
declare mt_uid[start:n, finish:n]{'v : Ocaml} : Ocaml
declare mt_with[start:n, finish:n]{'mt : Ocaml; 'wcl : Ocaml} : Ocaml
declare patt_and[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_apply_arg[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_apply_end[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_apply[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_as_arg[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_as_end[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_as[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_body[start:n, finish:n]{'e : Ocaml} : Ocaml
declare patt_char[start:n, finish:n, c:s]{'p1 : Ocaml} : Ocaml
declare patt_choice_arg[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_choice_end[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_choice[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_done[start:n, finish:n] : Ocaml
declare patt_fix_and[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_fix_arg[start:n, finish:n]{'e1 : Ocaml; 'p1 : Ocaml} : Ocaml
declare patt_float[start:n, finish:n, x:s]{'p1 : Ocaml} : Ocaml
declare patt_ifelse[start:n, finish:n]{'pwe : Ocaml; 'pwel : Ocaml} : Ocaml
declare patt_if[start:n, finish:n]{'pwe : Ocaml} : Ocaml
declare patt_in[start:n, finish:n]{'e1 : Ocaml} : Ocaml
declare patt_int[start:n, finish:n, i:n]{'p1 : Ocaml} : Ocaml
declare patt_lid[start:n, finish:n]{'p1 : Ocaml; 'p2 : Ocaml} : Ocaml
declare patt_list_arg[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_list_end[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_list[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_proj_arg[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_proj_end[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_proj[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_range_arg[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_range_end[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_range[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_record_end[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_record_proj[start:n, finish:n]{'e1 : Ocaml; 'p1 : Ocaml} : Ocaml
declare patt_record[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_string[start:n, finish:n, s:s]{'p1 : Ocaml} : Ocaml
declare patt_tuple_arg[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_tuple_end[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_tuple[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_uid[start:n, finish:n]{'p1 : Ocaml; 'p2 : Ocaml} : Ocaml
declare patt_var[start:n, finish:n]{x. 'p1 : Ocaml} : Ocaml
declare patt_wildcard[start:n, finish:n]{'p1 : Ocaml} : Ocaml
declare patt_with[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare "proj"[start:n, finish:n]{'A : Ocaml; 'B : Ocaml} : Ocaml
declare "record"[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare "sequence"[start:n, finish:n]{'e1 : Ocaml} : Ocaml
declare sig_exception[start:n, finish:n, name:s]{'tl : Ocaml} : Ocaml
declare sig_external[start:n, finish:n, name:s]{'t : Ocaml; 'sl : Ocaml} : Ocaml
declare sig_module[start:n, finish:n, name:s]{'mt : Ocaml} : Ocaml
declare sig_module_type[start:n, finish:n, name:s]{'mt : Ocaml} : Ocaml
declare sig_open[start:n, finish:n]{'sl : Ocaml} : Ocaml
declare sig_type[start:n, finish:n]{'tdl : Ocaml} : Ocaml
declare sig_value[start:n, finish:n, name:s]{'t : Ocaml} : Ocaml
declare "stream"[start:n, finish:n]{'e1 : Ocaml} : Ocaml
declare str_exception[start:n, finish:n, name:s]{'tl : Ocaml} : Ocaml
declare str_expr[start:n, finish:n]{'e : Ocaml} : Ocaml
declare str_external[start:n, finish:n, name:s]{'t : Ocaml; 'sl : Ocaml} : Ocaml
declare str_fix[start:n, finish:n]{'p : Ocaml} : Ocaml
declare "string"[start:n, finish:n, s:s] : Ocaml
declare "string_subscript"[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml
declare str_let[start:n, finish:n]{'p : Ocaml; 'e : Ocaml} : Ocaml
declare str_let[start:n, finish:n]{'e : Ocaml} : Ocaml
declare str_module[name:s, start:n, finish:n]{'me : Ocaml} : Ocaml
declare str_module_type[start:n, finish:n, name:s]{'mt : Ocaml} : Ocaml
declare str_open[start:n, finish:n]{'sl : Ocaml} : Ocaml
declare str_type[start:n, finish:n]{'tdl : Ocaml} : Ocaml
declare "try"[start:n, finish:n]{'e : Ocaml; 'pwel : Ocaml} : Ocaml
declare "tuple"[start:n, finish:n]{'e1 : Ocaml} : Ocaml
declare type_apply[start:n, finish:n]{'t1 : Ocaml; 't2 : Ocaml} : Ocaml
declare type_as[start:n, finish:n]{'t1 : Ocaml; 't2 : Ocaml} : Ocaml
declare type_class_id[start:n, finish:n]{'t1 : Ocaml} : Ocaml
declare type_equal[start:n, finish:n]{'t1 : Ocaml; 't2 : Ocaml} : Ocaml
declare type_fun[start:n, finish:n]{'t1 : Ocaml; 't2 : Ocaml} : Ocaml
declare type_lid[start:n, finish:n]{'v : Ocaml} : Ocaml
declare type_list[start:n, finish:n]{'stl : Ocaml} : Ocaml
declare type_param[start:n, finish:n, s:s] : Ocaml
declare type_prod[start:n, finish:n]{'tl : Ocaml} : Ocaml
declare type_proj[start:n, finish:n]{'t1 : Ocaml; 't2 : Ocaml} : Ocaml
declare type_record[start:n, finish:n]{'t : Ocaml} : Ocaml
declare type_uid[start:n, finish:n]{'v : Ocaml} : Ocaml
declare type_wildcard[start:n, finish:n] : Ocaml
declare "uid"[start:n, finish:n]{'v : Ocaml} : Ocaml
declare "while"[start:n, finish:n]{'e1 : Ocaml; 'e2 : Ocaml} : Ocaml

(*
 * -*-
 * Local Variables:
 * Caml-master: "refiner"
 * End:
 * -*-
 *)
