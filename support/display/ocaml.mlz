(*
 * This file contains the primitive syntax and display
 * for ocaml terms.
 *
 * ----------------------------------------------------------------
 *
 * This file is part of MetaPRL, a modular, higher order
 * logical framework that provides a logical programming
 * environment for OCaml and other languages.
 *
 * See the file doc/index.html for information on Nuprl,
 * OCaml, and more information about this system.
 *
 * Copyright (C) 1998 Jason Hickey, Cornell University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Jason Hickey
 * jyh@cs.cornell.edu
 *)

extends Perv

(************************************************************************
 * EXPRESSIONS                                                          *
 ************************************************************************)

(*
 * Lists.
 *)
declare "onil"
declare "ocons"{'hd; 'tl}

(*
 * Constants.
 *)
declare "unit"
declare "bool"[f:s]
declare "char"[c:s]
declare "int"[i:n]
declare "string"[s:s]
declare "float"[s:s]
declare "true"
declare "false"

declare "lid"{'v}
declare "lid"[s:s]
declare "uid"{'v}
declare "uid"[s:s]

(*
 * Primitive operations on numbers.
 *)
declare lt_int{'e1; 'e2}
declare le_int{'e1; 'e2}
declare eq_int{'e1; 'e2}
declare ge_int{'e1; 'e2}
declare gt_int{'e1; 'e2}

declare add{'e1; 'e2}
declare sub{'e1; 'e2}
declare mul{'e1; 'e2}
declare div{'e1; 'e2}
declare "mod"{'e1; 'e2}

(*
 * Primitive operations on booleans.
 *)
declare "or"{'e1; 'e2}
declare "and"{'e1; 'e2}
declare "not"{'e1; 'e2}

(*
 * Projection.
 *)
declare proj{'e1; 'e2}

(*
 * Application.
 *)
declare apply{'e1; 'e2}
declare inj{'e1; 'e2}

(*
 * Subscripting.
 *)
declare string_subscript{'e1; 'e2}
declare array_subscript{'e1; 'e2}

declare string_set{'e1; 'e2; 'e3}
declare array_set{'e1; 'e2; 'e3}

(*
 * Sequences.
 *)
declare list{'e1}
declare array{'e1}
declare stream{'e1}
declare record{'e1;'e2}

declare tuple{'e}

(*
 * Assignment.
 *)
declare assign{'e1; 'e2}
declare record_set{'e1; 'e2; 'e3}

(*
 * Sequencing.
 *)
declare sequence{'e1}

(*
 * Conditional.
 *)
declare "ifthenelse"{'e1; 'e2; 'e3}

(*
 * Loops.
 *)
declare for_upto{'e1; 'e2; x. 'e3}
declare for_downto{'e1; 'e2; x. 'e3}
declare "while"{'e1; 'e2}

(*
 * Type casting.
 *)
declare cast{'e; 't}

(*
 * Class coercion.
 *)
declare class_coerce{'e1; 'e2}

(*
 * New object.
 *)
declare "new"{'e1}

(*
 * Exceptions.
 *)
declare "try"{'e; 'pwel}
declare "raise"{'e}

(*
 * "Match" forms.
 *)
declare "fun"{'pwel}
declare "match"{'e; 'pwel}

(*
 * "Let" forms.  The real work is performed in the patterns.
 *)
declare "let"{'p; 'e}
declare "fix"{'pel}

(*
 * Pairing.
 *)
declare "ee"{'e1; 'e2}

(*
 * Options in AST
 *)
declare none
declare some{'e}

(************************************************************************
 * PATTERNS                                                             *
 ************************************************************************)

(*
 * Display forms for patterns are a problem, because the innermost term is the
 * term to be evaluated under all the pattern bindings.
 * We contruct the pattern term and extract the inner expression.
 * Patterns are collected on a stack.
 *
 * Here is how a "let" expression looks:
 *    1. let : (p1, e1), ..., (pn, en), e
 *       let{pl; el}, where
 *       pl = patt_arg{...; patt_end{... patt_in{e}}}
 *       el = cons{e1; cons{e2; ... nil}}
 *
 * Here is how a "match" expression looks:
 *    2. match e, (p1, w1, e1), ..., (pn, wn, en)
 *       match{patt_ifelse{pwe1; patt_ifelse{pwe2; ... patt_if{pwen}}}}
 *       where
 *          pwe = patt_* ... {we}
 *          we  = patt_with{w; e} | patt_body{e}
 *
 * Here is how a "let rec" expression looks:
 * The arguments are _inside_ the pattern.
 *    3. letrec (p1, e1), ..., (pn, en), e
 *       fix{x.let{pl; x}}, where
 *       pl = patt_arg{...; patt_end{... patt_match{e1; ... patt_in{e}}}}
 *
 * BUG!!! nogin: the actual code in filter/base/filter_ocaml does
 * something else, there is no bound variable in the fix term in creates!
 *
 * These three forms are different, but we can combine their
 * display forms somewhat.
 *
 * Display forms have three arguments.
 *    1. key: (patt_format usually)
 *    2. current pattern
 *    3. stack of terms representing the pattern being constructed
 *
 * For the "let" form, we initialize the stack with the list "el".
 *)

(*
 * Constant.
 *)
declare patt_char[c:s]
declare patt_int[i:n]
declare patt_string[s:s]
declare patt_float[f:s]

(*
 * Binding.
 *)
declare patt_var{x. 'p}
declare patt_lid{'p1; 'p2}
declare patt_lid[name:s]
declare patt_uid{'p1; 'p2}
declare patt_uid[name:s]

(*
 * Typed pattern.
 *)
declare patt_coerce{'p; 't}

(*
 * Projection.
 *)
declare patt_proj{'p}
declare patt_proj_arg{'p}
declare patt_proj_end{'p}

(*
 * Simultaneous match.
 *)
declare patt_as{'p}
declare patt_as_arg{'p}
declare patt_as_end{'p}

(*
 * Wildcard.
 *)
declare patt_wildcard{'p}

(*
 * Application.
 *)
declare patt_apply{'p}
declare patt_apply_arg{'p}
declare patt_apply_end{'p}

(*
 * Alternates.
 *)
declare patt_choice{'p}
declare patt_choice_arg{'p}
declare patt_choice_end{'p}

(*
 * Range of choices.
 *)
declare patt_range{'p}
declare patt_range_arg{'p}
declare patt_range_end{'p}

(*
 * List pattern.
 *)
declare patt_list{'p}
declare patt_list_arg{'p}
declare patt_list_end{'p}

(*
 * Tuple pattern.
 *)
declare patt_tuple{'p}
declare patt_tuple_arg{'p}
declare patt_tuple_end{'p}

(*
 * Record pattern.
 *)
declare patt_record{'p}
declare patt_record_proj{'n; 'p}
declare patt_record_end{'p}

(*
 * "Let" forms.
 * Clauses are delimited by patt_and.
 * The stack contains one of the following:
 *    patt_let: this is the first clause of a let
 *    patt_and: this is the second or greater clause of a let
 *    patt_fix: this is a clause of a fix
 *)
declare patt_and{'p}
declare patt_in{'e}
declare patt_done
declare patt_match{'e1; 'e2}
declare patt_fix_and{'p}
declare patt_fix_arg{'e1; 'e2}

(*
 * "Match" forms.
 *)
declare patt_ifelse{'pwe; 'pwel}
declare patt_if{'pwe}
declare patt_with{'e1; 'e2}
declare patt_body{'e1}

(************************************************************************
 * TYPES                                                                *
 ************************************************************************)

(*
 * Constant types.
 *)
declare type_unit
declare type_bool
declare type_char
declare type_string
declare type_int
declare type_float

(*
 * Projection.
 *)
declare type_proj{'t1; 't2}

(*
 * "As" type.
 *)
declare type_as{'t1; 't2}

(*
 * Wildcard type.
 *)
declare type_wildcard

(*
 * Application.
 *)
declare type_apply{'t1; 't2}

(*
 * Function type.
 *)
declare type_fun{'t1; 't2}

(*
 * Class identifier.
 *)
declare type_class_id{'t1}

(*
 * Identifiers.
 *)
declare type_lid[v:s]
declare type_uid[v:s]
declare type_lid{'v}
declare type_uid{'v}

(*
 * Type parameter.
 *)
declare type_param[s:s]

(*
 * Type equivalence.
 *)
declare type_equal{'t1; 't2}

(*
 * Sequence types.
 *)
declare type_list{'t}
declare type_array{'t}

(*
 * Record type.
 * I'm not sure what the boolean is for.
 *)
declare type_record{'sbtl}
declare type_record_elem[s:s, b:s]{'t}
declare type_ref{'t}

(*
 * Product types.
 *)
declare type_prod{'tl}

(*
 * Pairing.
 *)
declare sbt{'s; 'b; 't}
declare stl{'s; 'tl}

(************************************************************************
 * SIGNATURE ITEMS                                                      *
 ************************************************************************)

(*
 * Signatures and structures are treated as records.
 * Their names are strings, not variables, and they do not
 * alpha-vary.  We could have external and internal names
 * like Harper's translucent sums, but we would diverge
 * from the ocaml type theory.
 *)

(*
 * Exception declarations name type constructors.
 *)
declare sig_exception[name:s]{'tl}

(*
 * External function declaration.
 *)
declare sig_external[name:s]{'t; 'sl}

(*
 * Module declaration.
 *)
declare sig_module[name:s]{'mt}

(*
 * Module type declaration.
 *)
declare sig_module_type[name:s]{'mt}

(*
 * Open a module in scope.
 *)
declare sig_open{'sl}

(*
 * Type declaration.
 *)
declare sig_type{'tdl}

(*
 * Value declaration.
 *)
declare sig_value[name:s]{'t}

(************************************************************************
 * STRUCTURE ITEMS                                                      *
 ************************************************************************)

(*
 * Exception declarations name type constructors.
 *)
declare str_exception[name:s]{'tl}

(*
 * External function declaration.
 *)
declare str_external[name:s]{'t; 'sl}

(*
 * Unnamed value.
 *)
declare str_expr{'e}

(*
 * Module definition.
 *)
declare str_module[name:s]{'me}

(*
 * Module type definition.
 *)
declare str_module_type[name:s]{'mt}

(*
 * Open a module in scope.
 *)
declare str_open{'sl}

(*
 * Type definition
 *)
declare str_type{'tdl}

(*
 * Value definition.
 *)
declare str_let{'p; 'e}
declare str_let{'e}
declare str_fix{'p}

(*
 * Type declaration.
 *)
declare tdl{'s; 'sl; 't; 'tc}

(*
 * Type constraint in type declaration
 *)
declare tc{'t1; 't2}

(************************************************************************
 * MODULE TYPE                                                          *
 ************************************************************************)

(*
 * Projection.
 *)
declare mt_proj{'mt1; 'mt2}

(*
 * Application.
 *)
declare mt_apply{'mt1; 'mt2}

(*
 * Functor.
 *)
declare mt_functor[name:s]{'mt1; 'mt2}

(*
 * Id.
 *)
declare mt_lid[name:s]
declare mt_lid{'name}
declare mt_uid[name:s]
declare mt_uid{'name}

(*
 * Signature.
 *)
declare mt_sig{'sil}

(*
 * Module type with clause.
 *)
declare mt_with{'mt; 'wcl}

(*
 * With clauses.
 * I'm not sure what these mean.
 *)
declare wc_type{'sl1; 'sl2; 't}
declare wc_module{'sl1; 'mt}

(************************************************************************
 * MODULE EXPRESSION                                                    *
 ************************************************************************)

(*
 * Projection.
 *)
declare me_proj{'me1; 'me2}

(*
 * Application.
 *)
declare me_apply{'me1; 'me2}

(*
 * Functor.
 *)
declare me_functor[name:s]{'mt; 'me}

(*
 * Structure.
 *)
declare me_struct{'sil}

(*
 * Type cast.
 *)
declare me_cast{'me; 'mt}

(*
 * Variables.
 *)
declare me_lid[name:s]
declare me_uid[name:s]

(*
 * Locations
 *)

declare "apply"[start:n, finish:n]{'e1; 'e2}
declare "array"[start:n, finish:n]{'e1}
declare "array_subscript"[start:n, finish:n]{'e1; 'e2}
declare assign[start:n, finish:n]{'e1; 'e2}
declare cast[start:n, finish:n]{'e; 't}
declare "char"[start:n, finish:n, c:s]
declare class_coerce[start:n, finish:n]{'e1; 'e2}
declare "fix"[start:n, finish:n]{'p}
declare "float"[start:n, finish:n, f:s]
declare for_downto[start:n, finish:n]{'e1; 'e2; x. 'e3}
declare for_upto[start:n, finish:n]{'e1; 'e2; x. 'e3}
declare "fun"[start:n, finish:n]{'pwel}
declare ifthenelse[start:n, finish:n]{'e1; 'e2; 'e3}
declare "int"[start:n, finish:n, i:n]
declare "let"[start:n, finish:n]{'p; 'e}
declare "lid"[start:n, finish:n]{'v}
declare "list"[start:n, finish:n]{'e1}
declare "match"[start:n, finish:n]{'e; 'pwel}
declare mt_apply[start:n, finish:n]{'mt1; 'mt2}
declare mt_functor[start:n, finish:n, name:s]{'mt1; 'mt2}
declare mt_lid[start:n, finish:n]{'v}
declare mt_proj[start:n, finish:n]{'mt1; 'mt2}
declare mt_sig[start:n, finish:n]{'sil}
declare mt_uid[start:n, finish:n]{'v}
declare mt_with[start:n, finish:n]{'mt; 'wcl}
declare patt_and[start:n, finish:n]{'p1}
declare patt_apply_arg[start:n, finish:n]{'p1}
declare patt_apply_end[start:n, finish:n]{'p1}
declare patt_apply[start:n, finish:n]{'p1}
declare patt_as_arg[start:n, finish:n]{'p1}
declare patt_as_end[start:n, finish:n]{'p1}
declare patt_as[start:n, finish:n]{'p1}
declare patt_body[start:n, finish:n]{'e}
declare patt_char[start:n, finish:n, c:s]{'p1}
declare patt_choice_arg[start:n, finish:n]{'p1}
declare patt_choice_end[start:n, finish:n]{'p1}
declare patt_choice[start:n, finish:n]{'p1}
declare patt_done[start:n, finish:n]
declare patt_fix_and[start:n, finish:n]{'p1}
declare patt_fix_arg[start:n, finish:n]{'e1; 'p1}
declare patt_float[start:n, finish:n, x:s]{'p1}
declare patt_ifelse[start:n, finish:n]{'pwe; 'pwel}
declare patt_if[start:n, finish:n]{'pwe}
declare patt_in[start:n, finish:n]{'e1}
declare patt_int[start:n, finish:n, i:n]{'p1}
declare patt_lid[start:n, finish:n]{'p1; 'p2}
declare patt_list_arg[start:n, finish:n]{'p1}
declare patt_list_end[start:n, finish:n]{'p1}
declare patt_list[start:n, finish:n]{'p1}
declare patt_proj_arg[start:n, finish:n]{'p1}
declare patt_proj_end[start:n, finish:n]{'p1}
declare patt_proj[start:n, finish:n]{'p1}
declare patt_range_arg[start:n, finish:n]{'p1}
declare patt_range_end[start:n, finish:n]{'p1}
declare patt_range[start:n, finish:n]{'p1}
declare patt_record_end[start:n, finish:n]{'p1}
declare patt_record_proj[start:n, finish:n]{'e1; 'p1}
declare patt_record[start:n, finish:n]{'p1}
declare patt_string[start:n, finish:n, s:s]{'p1}
declare patt_tuple_arg[start:n, finish:n]{'p1}
declare patt_tuple_end[start:n, finish:n]{'p1}
declare patt_tuple[start:n, finish:n]{'p1}
declare patt_uid[start:n, finish:n]{'p1; 'p2}
declare patt_var[start:n, finish:n]{x. 'p1}
declare patt_wildcard[start:n, finish:n]{'p1}
declare patt_with[start:n, finish:n]{'e1; 'e2}
declare "proj"[start:n, finish:n]{'A; 'B}
declare "record"[start:n, finish:n]{'e1; 'e2}
declare "sequence"[start:n, finish:n]{'e1}
declare sig_exception[start:n, finish:n, name:s]{'tl}
declare sig_external[start:n, finish:n, name:s]{'t; 'sl}
declare sig_module[start:n, finish:n, name:s]{'mt}
declare sig_module_type[start:n, finish:n, name:s]{'mt}
declare sig_open[start:n, finish:n]{'sl}
declare sig_type[start:n, finish:n]{'tdl}
declare sig_value[start:n, finish:n, name:s]{'t}
declare "stream"[start:n, finish:n]{'e1}
declare str_exception[start:n, finish:n, name:s]{'tl}
declare str_expr[start:n, finish:n]{'e}
declare str_external[start:n, finish:n, name:s]{'t; 'sl}
declare str_fix[start:n, finish:n]{'p}
declare "string"[start:n, finish:n, s:s]
declare "string_subscript"[start:n, finish:n]{'e1; 'e2}
declare str_let[start:n, finish:n]{'p; 'e}
declare str_let[start:n, finish:n]{'e}
declare str_module[name:s, start:n, finish:n]{'me}
declare str_module_type[start:n, finish:n, name:s]{'mt}
declare str_open[start:n, finish:n]{'sl}
declare str_type[start:n, finish:n]{'tdl}
declare "try"[start:n, finish:n]{'e; 'pwel}
declare "tuple"[start:n, finish:n]{'e1}
declare type_apply[start:n, finish:n]{'t1; 't2}
declare type_as[start:n, finish:n]{'t1; 't2}
declare type_class_id[start:n, finish:n]{'t1}
declare type_equal[start:n, finish:n]{'t1; 't2}
declare type_fun[start:n, finish:n]{'t1; 't2}
declare type_lid[start:n, finish:n]{'v}
declare type_list[start:n, finish:n]{'stl}
declare type_param[start:n, finish:n, s:s]
declare type_prod[start:n, finish:n]{'tl}
declare type_proj[start:n, finish:n]{'t1; 't2}
declare type_record[start:n, finish:n]{'t}
declare type_uid[start:n, finish:n]{'v}
declare type_wildcard[start:n, finish:n]
declare "uid"[start:n, finish:n]{'v}
declare "while"[start:n, finish:n]{'e1; 'e2}

(*
 * -*-
 * Local Variables:
 * Caml-master: "refiner"
 * End:
 * -*-
 *)
