Note - some non-critical bugs may be documented as TODO items.
(You need to have MetaPRL CVS account to be able to access the TODO file.)

Note - some files have small bugs documented in their comments, these can be found
by rgrep'ing for string "BUG".

DOCUMENTATION:

1.1) Documentation suggests to use mp and x.mp
while mpopt and mptop should be used instead.
Use Guide and Tutorial should mention the difference,
and suggest using mptop or mpopt. After that all examples should use mpopt.
1.1.1) In the mptop/mpopt vs mp discussion, the documentation should also mention readline
and give some pointers (info+man pages or readline homepage) to more information on customizing it.

1.2) Make system is not documented (see TODO 7.02 for more information).

1.3) (Created on 1999.11.11 by nogin)
Resources and resource annotations are not documented
1.3.1) The dT tactic section (doc/htmlman/system/mp-d-tactic.html) is not written.

1.4) (Created on 1999.11.11 by nogin)
MetaPRL Tutorial is very outdated.

EDITOR

2.1-2.3 are fixed

2.4) (Confirmed on 1999.09.02 by jyh and nogin)
There is no way to override display forms right now.
Could be that term_match_table listing needs to be reversed.

2.5) Display form mode generality is not working.

2.6) (Added 2000.02.21 by nogin)
When a list of subgoals is too big, displaying used to take a while. The current
workaround is to only display subgoals when there are <20 of them. We need to
find a better solution - in particular we should take into account subgoal sizes, not only
the number of subgoals.

It may be a good idea to implement a generic display-form mechanism to allow limiting
the number of lines a certain term would occupy. On the other hand, such an approach
would only save the time to output the display form, but not the time to produce it.

2.7) Native code just exits with segmentation fault on stack overflow. This is really bad
since it does not give user a chance to save work.
We may try to do our own "depth counting" in scheduler and catch too deep recursion
before it has a chance to overflow the stack.

2.8) When ls is used with non-empty flags (e.g. ls "u"), it should not use the word
     "Implementation" in the listing header (or it should at least tell what exactly
     it is listing).

REWRITER

3.1) If a variable is bound in a context, rewriter may handle it incorrectly.

3.2) If the same variable is bound several times in redex or contractum specification, rewriter
may handle it incorrectly. We can not prohibit repeated bound variable in redeces
specification because of two-way rewrites.

3.3) If the same variable is bound several times in the matched term, rewriter may handle
it incorrectly.

Example:
test{x.test{y.'C['x; 'y]}} <--> 'C[1; 2]
rewrites <<test{x.test{x.'x}}>> to 1 instead of 2.

(3.4-3.5 - fixed)

3.6) Rewriter does not prevent capturing. It should, at least in the "strict" mode.

3.7) Currently rewriter does not enforce building contractum to be against the same redex
the contractum was compiled against. Hopefully we never do this wrong, but we still
should enforce it.

3.8) SO contexts that are not a part of a sequent are currently never used and as a result
the corresponding rewriter code is undebugged.

3.9) (Added in 1999.11.05 by nogin, unverified)
If we have a redex where all the arguments of some SO variable are bound variables
and some variable appears more than once, rewriter may handle it incorrectly.
Example: <<lambda{x.lambda{y.'S['x;'x] +@ 'S['x;'y]}}>> should match
<<lambda{x.lambda{y.'x *@ 'x +@ 'x *@ 'y}}>>

3.10) (nogin) When the same variable appears twice in the same bvars list
(e.g., spread{p; x,x.x}), Nuprl upderstands it as y,x.x and MetaPRL - as x,y.x.
Nuprl's way is more natural and we should convert. I already wrote the new type
inference (only for spread) with Nuprl's understanding in mind.

REFINER

4.1) (Confirmed 1999.10.08 by nogin)
There is no clear semantics for the hidden hypothesis. As a result,
many rules deal with hidden hypothesis incorrectly. Currently, one
can prove 0=1 using those unsound rules.

In Nuprl the semantics of hidden hypothesis is that the variable introduced
by a hidden hypothesis may not appear in the extract. In MetaPRL we want to be
able to use derived rules before we have proven them which means that we want to
be able to use them before we know their extracts.

See also TODO #6.02

4.2) Repeated bound variables (when the same variable is bound more than once) is
handled incorrectly. For example, thinning rule does not check if the variable
is bound only once (which may be used to prove incorrect results). This is probably the
same bug as 3.3

4.3) rwh does not do matching correctly - for example, it allows to use reduceEta
on <<lambda{x.('x 'x)}>>. This may be already fixed by the "strict" rewriter mode.

4.4) "Understanding" of extracts seems broken. When refiner passes extracts to rewriter,
it "forgets to mention" that they are in the scope of hypothesis variables.

One of the side-effects of this problem is that we have to pass unnecessary arguments
to some of the rules (such as Itt_struct.hypothesis and srecElimination;
note: Itt_struct.hypothesis is mentioned in doc/htmlman/user-guide/mp-axiom.html).

We may try to fix it using meta-variables - see TODO #1.05.1

4.5) Since unification is only used in proof search, but not proof checking, it should be OK
that we do not have any unification in term_std, but this may create problems,
so we may need to create some unification for term_std.

4.6) (Discovered 2000.04 by kopylov, confirmed by nogin)
Until by-context free variable restriction is implemented and its usage is enforced
when necessary (see doc/sequents.tex for more information), the rule chaining is not
necessarily valid (e.g. even when S1 --> S2 and S2 --> S3 are valid rules, S1 --> S3 is not
necessarily valid). See also TODO #6.01

4.7) (nogin)
In Ocaml, string is a mutable data structure. In MetaPRL, we use strings everywhere (variable
names, opnames, etc) as if they were immutable. We need to
a) Make sure that nobody can cheat the system by starting to mute strings.
b) Let the compiler and GC know that we are not going to mute strings (which should allow
them to be more efficient).

4.8) (2000.06.09 nogin)
When autoT is ran on <<sequent [squash] { >- "type"{'O} } >> (with no assumtions),
MetaPRL seems to go into an infinite loop and because of the BUG 2.7, mpopt would crash
with segmentation fault!

PARSER & FILTER

5.1) Rules and rewrites should be added to toploop.
(updated 2000.04.24 by nogin) I believe this is fixed, but I am not sure.

5.2) When rule is added, the appropriate tactic should be added automatically
(assuming sequent calculus).

  --jyh: the tactic _is_ defined, but not (yet) added to Mptop toploop.

5.3) Some times parser requires too many brackets.

5.4) Parsing or printing bug that can be seen using ASCII files:
     sometimes string arguments in params gets unquoted too many times.
     Reproduce this bug by loading an old ASCII file, then saving it
     and seeing that some parameters have been unquoted.

5.5) Toploop_resource seems to be added into .p4 file even if
   base_theory is not included.

5.6) (2000.05.30) Resource annotations on axioms (rules that have neither parameters nor
assumptions) are currently silently ignored.

RULES & REWRITES

6.1) reduceEta is too strong
     should be moved to a new module not included in Itt_theory.

6.2) (Confirmed on 1999.09.27 by kopylov and nogin)
The rule interactive bunionElimination in the theory itt_bunion is not correct.
(This is a result of non-understanding hidden hypothesis)

6.3) (Formulated by krupski and confirmed by nogin - 2000.05.12)
After the membership rule is postulated, the corresponding ext rule can often
be proven using Itt_struct.introduction rule. There is no need to postulate
the ext rule and it should be actually proven only when it's useful.

Example: After <<'H >- univ[i:l] in int>> is postulated, there is no need
to postulate <<'H >- univ[i:l]>> with <<int>> extract since it can always
be proven in the unlikely event that it is actually needed.

P.S. Unfortunatelly, there seems to be no mechanism to do similar trick
for rules with assumptions. May be it would be a good idea to create one.

6.4) Dependent product type is currently defined as a very dependent function type.
Unfortunatelly, we were not (yet) able to prove productElimination. We should
think whether it's true and if not, then define dprod differently.

BUILD SYSTEM

7.1) Dependencies between .prla, .prlb, .cmiz, .cmoz, etc., are all messed up
   Solution: have MetaPRL maintain a file in each directory
     with the list of valid files.  Have only one of .prla, .prlb, or .cmoz file
     present at any time.  These files should not be in CVS.
   Better solution: keep only one .prl file, can contain either binary or
     ASCII.  Make CVS check that file is in ASCII before a commit.

7.2) Make sure saving .prl* files is done safely (not in place).
