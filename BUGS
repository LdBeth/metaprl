DOCUMENTATION:

*) Documentation suggests to use mp and x.mp
while mpopt and mptop should be used instead

*) Make system is not documented

EDITOR

*) Shell.cd function tries to expand proofs, it should not

*) Currently there is no way to change the statement of a theorem once
you started proving it. We need to be able to do it without 
erasing the proof. 

*) 
# load "itt_int";;
() : unit
# cd "itt_int";;
/itt_int : string
# ls ();;
uncaught exception: Invalid_argument("Term.shape_of_term")

*) MetaPRL toploop does not produce any meaningful parsing errors. Compare

# <<q>>;;
chars 42-43: Pcaml.Qerror("", 0, _)
# chars 45-47: Stream.Error("illegal begin of toplevel phrase")

in mpopt with

# <<q>>;;
# While expanding quotation "term":
Failure: undeclared name: q

in mp.

*) Loading two theories that both include the same theory produces unexpected results.
For example,

        MetaPRL 0.5.2:
                build [Sun May 16 16:50:01 EDT 1999]
                on tulare.cs.cornell.edu

        Camlp4 Parsing version 2.02

# #use "x.ml";;
# load "itt_dfun";;
- : unit = ()
# cd "itt_dfun";;
- : string = "/itt_dfun"
# <<'a->'b>>;;
- : Refiner.Refiner.Term.term = a но b
# load "itt_list";;
- : unit = ()
# cd "/itt_list";;
- : string = "/itt_list"
# <<'a->'b>>;;
# While expanding quotation "term":
Failure: undeclared name: fun

(Running this example in mpopt produces similar result).

This error also raised when we cd <theory>, and then load <theory>:
> # cd "dec_eq";;
> /dec_eq : string
> # load "dec_eq";;
> () : unit
> # <<it>>;;
> chars 32-34: Pcaml.Qerror("", 0, _)
> # chars 36-38: Stream.Error("illegal begin of toplevel phrase")
> #
> # MetaPRL exiting
>
> [kopylov@tulare ml]$ ./mpopt
> MetaPRL 0.5.2:
>   build [Fri May 21 19:06:08 EDT 1999]
>   on tulare.cs.cornell.edu
>   Uses VERBOSE Refiner_ds
> # load "dec_eq";;
> () : unit
> # cd "dec_eq";;
> /dec_eq : string
> # <<it>>;;


REFINER

*) There is no clear semantics for the hidden hypothesis. As a result,
many rules deal with hidden hypothesis incorrectly. Currently, one
can prove 0=1 using those unsound rules.

*) Repeated bound variables (when the same variable is bound more than once) is
handled incorrectly. For example, thinning rule does not check if the variable
is bound only once (which may be used to prove incorrect results).

*) rwh does not do matching correctly - for example, it allows to use reduceEta
on <<lambda{x.('x 'x)}>>

PARSER

*) Rules and rewrites should be added to toploop. 

*) When rule is added, the appropriate tactic should be added automatically
(assuming sequent calculus).

*) Some times parser requires too many brackets.

*) The rules without parameters should not require : :, a single colon
should be sufficient (it means that we should remove an alternative rule
syntax of
interactive name: A1 A2 ... : An)

*) Parser should check display forms for correctness. Currently it accepts
many incorrect display forms and later we get (in mp):

# ls();;
subst: L () (r; l)
Uncaught exception: Invalid_argument("List.combine")
# << rfun{'L; r,l.'L}>>;;
subst: L () (r; l)
- : Refiner.Refiner.Term.term =
<printer Shell_p4.print_term raised an exception>

without even explaining which display form caused an error message.

*) We no longer need @ for meta-parameters.
