(*
 * Define a common tactic type.
 *
 * We build tactics as a layer over the refiner,
 * and the tactics are summarized using Tactic_cache.extract.
 *
 * Eventually, it would be desirable to have tactics just
 * manipulate the Tactic_cache.extract, and perform all
 * search outside the refiner.  Then once the search is
 * complete, the extract would be generated by the refiner.
 *
 * For now, this is too hard.  We use the refiner to guide the
 * search, and we keep the extract up-to-date with the
 * current refinement.  This allows is to use chaining while
 * retaining the traditional search mechanisms.
 *
 * A tactic has two parts:
 *    1. It contains a Refine.tactic
 *
 * ----------------------------------------------------------------
 *
 * This file is part of MetaPRL, a modular, higher order
 * logical framework that provides a logical programming
 * environment for OCaml and other languages.
 *
 * See the file doc/htmlman/default.html or visit http://metaprl.org/
 * for more information.
 *
 * Copyright (C) 1998 Jason Hickey, Cornell University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Jason Hickey
 * jyh@cs.cornell.edu
 *)
open Lm_debug
open Lm_printf
open Lm_rformat

open Dform

open Opname
open Refiner.Refiner
open Refiner.Refiner.Term
open Refiner.Refiner.TermMan
open Refiner.Refiner.TermSubst
open Refiner.Refiner.RefineError
open Refiner.Refiner.Refine

open Tactic_boot_sig
open Rewrite_sig
open Option_sig
open Theory

(*
 * Show that the file is loading.
 *)
let _ =
   show_loading "Loading Tactic_type%t"

let debug_tactic =
   create_debug (**)
      { debug_name = "tactic";
        debug_description = "display primitive tactic operations";
        debug_value = false
      }

let debug_refine = load_debug "refine"

let eq = (==)
let equal = (=)

let option_name = "option"

(*
 * This module implements:
 *   TacticType
 *   Tactic
 *   TacticInternal
 *)
module Tactic =
struct
   (************************************************************************
    * TYPES                                                                *
    ************************************************************************)

   module ThreadRefinerTacticals = Thread_refiner.ThreadRefinerTacticals
   module ThreadRefiner = Thread_refiner.ThreadRefiner

   type prim_tactic = Refiner.Refiner.Refine.prim_tactic
   type prim_rewrite = Refiner.Refiner.Refine.prim_rewrite

   (*
    * Functions needed for the table.
    *)
   let union () () = ()

   let append l1 l2 = l1 @ l2

   (*
    * The attribute calculations are delayed to minimize communication
    * cost.  The tactic_arg uses keys to distribute the attributes.
    * The values are stored in keys.
    *)

   type sentinal = Refine.sentinal ThreadRefiner.key

   and raw_attribute_info =
      RawTerm of term
    | RawTermList of term list
    | RawType of term
    | RawBool of bool
    | RawAddr of address
    | RawInt of int
    | RawString of string
    | RawSentinal of sentinal

   and raw_attribute = string * raw_attribute_info

   and raw_attributes = raw_attribute list

   (*
    * Attributes are user-defined arguments that are
    * threaded through the proof tree.
    *)
   and attribute_info =
      { attr_terms      : (string * term) list;
        attr_term_lists : (string * term list) list;
        attr_types      : (string * term) list;
        attr_ints       : (string * int) list;
        attr_bools      : (string * bool) list;
        attr_strings    : (string * string) list;
        attr_options    : option_table;
        attr_keys       : (string * sentinal) list
      }

   (*
    * A tactic argument includes the msequent goal,
    * as well as the attributes.
    *)
   and tactic_arg =
      { ref_goal : msequent;
        ref_label : string;
        ref_attributes : attribute_info;
        ref_bookmark : Mp_resource.global_resource;
        ref_sentinal : sentinal
      }

   and tactic_value = (tactic_arg, arglist, extract) ThreadRefiner.t

   and tactic = tactic_arg -> tactic_value

   and pre_tactic = (tactic_arg -> Refiner.Refiner.Refine.msequent list -> tactic_arg list) * prim_tactic

   (*
    * An extract has these kinds:
    *   + A goal term without any justification
    *   + A step that is unjustified
    *   + A raw refine extract, saving the number of subgoals
    *   + A composition of extracts
    *   + An annotated extract
    *   + A rule box, which is a combined annotation/composition
    *)
   and extract =
      Goal of tactic_arg
    | Unjustified of tactic_arg * tactic_arg list
    | Extract of tactic_arg * tactic_arg list * Refine.extract
    | Wrapped of arglist * extract
    | Compose of compose_info
    | RuleBox of rule_info
    | Pending of pending_extract
    | Locked of extract
    | Identity of tactic_arg
    | Annotate of tactic_arg * tactic_arg

   and pending_extract = unit -> extract

   and compose_info =
      { mutable comp_status : lazy_status;
        comp_goal : extract;
        comp_subgoals : extract list;
        mutable comp_leaves : lazy_leaves;
        comp_extras : extract list
      }

   and rule_info =
      { mutable rule_status : lazy_status;
        rule_string : string;
        rule_expr : (unit -> MLast.expr);
        rule_tactic : (unit -> tactic);
        mutable rule_extract_normalized : bool;
        mutable rule_extract : extract;
        rule_subgoals : extract list;
        mutable rule_leaves : lazy_leaves;
        rule_extras : extract list
      }

   and lazy_status =
      LazyStatusDelayed
    | LazyStatusBad
    | LazyStatusIncomplete
    | LazyStatusPartial
    | LazyStatusComplete

   and lazy_leaves =
      LazyLeavesDelayed
    | LazyLeaves of tactic_arg list

   (*
    * Conversions are used by the rewrite module.
    *)
   and env = tactic_arg * int * address

   and conv =
      RewriteConv of rw
    | CondRewriteConv of cond_rewrite
    | ComposeConv of conv Flist.t
    | ChooseConv of conv Flist.t
    | AddressConv of address * conv
    | FoldConv of term * conv
    | CutConv of term
    | FunConv of (env -> conv)
    | HigherConv of conv
    | ThenTC of conv * tactic
    | IdentityConv
    | TacticConv of (address -> tactic)
    | ForceConv of string * conv

   (*
    * Resources.
    *
    * Split the annotation processor types into named versions
    * so that we can force choice of optional arguments.
    *)
   type 'input named_annotation_processor =
      rewrite_args_spec -> (* Names of the context vars parameters *)
      term list ->         (* Term parameters *)
      meta_term ->         (* Rule statement *)
      MLast.loc ->         (* Location of the rule *)
      pre_tactic ->
      'input list

   type 'input annotation_processor =
      string ->            (* Name of the new rule *)
      'input named_annotation_processor

   type 'input named_rw_annotation_processor =
      term ->              (* Redex *)
      term ->              (* Contractum *)
      term list ->         (* Assumptions *)
      rewrite_args_spec -> (* Names of the context vars parameters *)
      term list ->         (* Term arguments *)
      MLast.loc ->         (* Location of the rewrite *)
      prim_rewrite ->
      'input list

   type 'input rw_annotation_processor =
      string ->            (* Name of the new rewrite *)
      'input named_rw_annotation_processor

   (************************************************************************
    * IMPLEMENTATION                                                       *
    ************************************************************************)

   (*
    * Server is created at file execution time.
    *)
   let print_tactic_arg out arg =
      debug_print out (TermMan.concl (msequent_goal arg.ref_goal))

   (*
    * Composition function on extracts.
    *)
   let compose ext extl =
      Compose { comp_status = LazyStatusDelayed;
                comp_goal = ext;
                comp_subgoals = extl;
                comp_leaves = LazyLeavesDelayed;
                comp_extras = []
      }

   let wrap arglist ext =
      Wrapped (arglist, ext)

   let args = ThreadRefiner.args

   let remote_server = ThreadRefiner.create print_tactic_arg compose wrap

   let get_remote_server () = remote_server

   let empty_attribute =
      { attr_terms      = [];
        attr_term_lists = [];
        attr_types      = [];
        attr_ints       = [];
        attr_bools      = [];
        attr_strings    = [];
        attr_options    = [];
        attr_keys       = []
      }

   (*
    * Create an initial tactic_arg for a proof.
    * Cache is initially out-of-date.  It will be
    * set to the current goal when requested.
    *)
   let attribute_info_of_raw_attributes attributes =
      { attr_terms      = Lm_list_util.some_map (function (name, RawTerm t)     -> Some (name, t) | _ -> None) attributes;
        attr_term_lists = Lm_list_util.some_map (function (name, RawTermList t) -> Some (name, t) | _ -> None) attributes;
        attr_types      = Lm_list_util.some_map (function (name, RawType t)     -> Some (name, t) | _ -> None) attributes;
        attr_ints       = Lm_list_util.some_map (function (name, RawInt i)      -> Some (name, i) | _ -> None) attributes;
        attr_bools      = Lm_list_util.some_map (function (name, RawBool b)     -> Some (name, b) | _ -> None) attributes;
        attr_strings    = Lm_list_util.some_map (function (name, RawString s)   -> Some (name, s) | _ -> None) attributes;
        attr_keys       = Lm_list_util.some_map (function (name, RawSentinal k) -> Some (name, k) | _ -> None) attributes;
        attr_options    =
           Lm_list_util.some_map (fun attr ->
                 match attr with
                    (opt, RawTerm t) when is_option_string opt ->
                       Some (opname_of_term t, option_of_string opt)
                  | _ ->
                       None) attributes
      }

   let squash_attributes attrs =
      { attrs with attr_keys = [] }

   let update_attributes attrs raws =
      { attrs with attr_keys = Lm_list_util.some_map (function (name, RawSentinal k) -> Some (name, k) | _ -> None) raws }

   let main_loop () =
      ThreadRefiner.main_loop (get_remote_server ())

   let create sentinal goal bookmark =
      { ref_goal = goal;
        ref_label = "main";
        ref_attributes = empty_attribute;
        ref_bookmark = bookmark;
        ref_sentinal = sentinal
      }

   (*
    * Access to the sequent.
    *)
   let msequent arg = arg.ref_goal

   let goal arg =
      msequent_goal arg.ref_goal

   let nth_hyp arg i = TermMan.nth_hyp (msequent_goal arg.ref_goal) i
   let nth_binding arg i = TermMan.nth_binding (msequent_goal arg.ref_goal) i

   let concl arg =
      TermMan.concl (msequent_goal arg.ref_goal)

   let num_assums arg =
      msequent_num_assums arg.ref_goal

   let all_assums arg =
      msequent_all_assums arg.ref_goal

   let nth_assum arg i =
      if i == 0 then
         goal arg
      else
         msequent_nth_assum arg.ref_goal i

   let label arg = arg.ref_label

   (*
    * Modify the argument.
    *)
   let set_goal arg goal =
      { arg with ref_goal = mk_msequent goal (snd (dest_msequent arg.ref_goal)) }

   let set_concl arg concl =
      let goal, hyps = dest_msequent arg.ref_goal in
         { arg with ref_goal = mk_msequent (replace_concl goal concl) hyps }

   let set_label arg label =
      { arg with ref_label = label }

   (************************************************************************
    * SENTINAL                                                             *
    ************************************************************************)

   (*
    * Sentinal function is lazy.
    *)
   let get_theory name =
      let rec search = function
         thy :: t ->
            if thy.thy_name = name then
               thy
            else
               search t
       | [] ->
            raise (RefineError ("get_theory", StringStringError ("theory is not found", name)))
      in
         search (get_theories ())

   let null_sentinal =
      let xlazy () =
         Refine.null_sentinal
      in
         ThreadRefiner.share (get_remote_server ()) "sentinal" xlazy

   let any_sentinal =
      let xlazy () =
         Refine.any_sentinal
      in
         ThreadRefiner.share (get_remote_server ()) "sentinal" xlazy

   let sentinal_of_refiner mod_name =
      let xlazy () =
         let refiner = (get_theory mod_name).thy_refiner in
            Refine.sentinal_of_refiner refiner
      in
         ThreadRefiner.share (get_remote_server ()) "sentinal" xlazy

   let sentinal_of_refiner_object mod_name name =
      let xlazy () =
         let refiner = (get_theory mod_name).thy_refiner in
         let opname = make_opname [name; mod_name] in
            try Refine.find_sentinal refiner opname with
               Not_found ->
                  eprintf "Warning: using default refiner for %s%t" name eflush;
                  Refine.sentinal_of_refiner refiner
      in
         ThreadRefiner.share (get_remote_server ()) "sentinal_object" xlazy

   let get_sentinal key =
      ThreadRefiner.arg_of_key (get_remote_server ()) key

   let identity arg =
      Refine.identity (get_sentinal arg.ref_sentinal) arg.ref_goal

   (************************************************************************
    * ATTRIBUTES                                                           *
    ************************************************************************)

   (*
    * Arglists.
    * This compression/decompression is inefficient (perhaps the
    * OCaml compiler can do pattern optimization?)  But this code
    * is only used in proof conversion.
    *)
   let compress_arglist = function
      [StringArg a1] ->
         NoneArgList a1
    | [StringArg a1; IntArg a2] ->
         IntArgList (a1, a2)
    | [StringArg a1; BoolArg a2] ->
         BoolArgList (a1, a2)
    | [StringArg a1; StringArg a2] ->
         StringArgList (a1, a2)
    | [StringArg a1; TermArg a2] ->
         TermArgList (a1, a2)
    | [StringArg a1; IntArg a2; IntArg a3] ->
         IntIntArgList (a1, a2, a3)
    | [StringArg a1; IntArg a2; BoolArg a3] ->
         IntBoolArgList (a1, a2, a3)
    | [StringArg a1; IntArg a2; StringArg a3] ->
         IntStringArgList (a1, a2, a3)
    | [StringArg a1; IntArg a2; TermArg a3] ->
         IntTermArgList (a1, a2, a3)
    | [StringArg a1; BoolArg a2; IntArg a3] ->
         BoolIntArgList (a1, a2, a3)
    | [StringArg a1; BoolArg a2; BoolArg a3] ->
         BoolBoolArgList (a1, a2, a3)
    | [StringArg a1; BoolArg a2; StringArg a3] ->
         BoolStringArgList (a1, a2, a3)
    | [StringArg a1; BoolArg a2; TermArg a3] ->
         BoolTermArgList (a1, a2, a3)
    | [StringArg a1; StringArg a2; IntArg a3] ->
         StringIntArgList (a1, a2, a3)
    | [StringArg a1; StringArg a2; BoolArg a3] ->
         StringBoolArgList (a1, a2, a3)
    | [StringArg a1; StringArg a2; StringArg a3] ->
         StringStringArgList (a1, a2, a3)
    | [StringArg a1; StringArg a2; TermArg a3] ->
         StringTermArgList (a1, a2, a3)
    | [StringArg a1; TermArg a2; IntArg a3] ->
         TermIntArgList (a1, a2, a3)
    | [StringArg a1; TermArg a2; BoolArg a3] ->
         TermBoolArgList (a1, a2, a3)
    | [StringArg a1; TermArg a2; StringArg a3] ->
         TermStringArgList (a1, a2, a3)
    | [StringArg a1; TermArg a2; TermArg a3] ->
         TermTermArgList (a1, a2, a3)
    | args ->
         GeneralArgList (Array.of_list args)

   let expand_arglist = function
      NoneArgList a1 ->
         [StringArg a1]
    | IntArgList (a1, a2) ->
         [StringArg a1; IntArg a2]
    | BoolArgList (a1, a2) ->
         [StringArg a1; BoolArg a2]
    | StringArgList (a1, a2) ->
         [StringArg a1; StringArg a2]
    | TermArgList (a1, a2) ->
         [StringArg a1; TermArg a2]
    | IntIntArgList (a1, a2, a3) ->
         [StringArg a1; IntArg a2; IntArg a3]
    | IntBoolArgList (a1, a2, a3) ->
         [StringArg a1; IntArg a2; BoolArg a3]
    | IntStringArgList (a1, a2, a3) ->
         [StringArg a1; IntArg a2; StringArg a3]
    | IntTermArgList (a1, a2, a3) ->
         [StringArg a1; IntArg a2; TermArg a3]
    | BoolIntArgList (a1, a2, a3) ->
         [StringArg a1; BoolArg a2; IntArg a3]
    | BoolBoolArgList (a1, a2, a3) ->
         [StringArg a1; BoolArg a2; BoolArg a3]
    | BoolStringArgList (a1, a2, a3) ->
         [StringArg a1; BoolArg a2; StringArg a3]
    | BoolTermArgList (a1, a2, a3) ->
         [StringArg a1; BoolArg a2; TermArg a3]
    | StringIntArgList (a1, a2, a3) ->
         [StringArg a1; StringArg a2; IntArg a3]
    | StringBoolArgList (a1, a2, a3) ->
         [StringArg a1; StringArg a2; BoolArg a3]
    | StringStringArgList (a1, a2, a3) ->
         [StringArg a1; StringArg a2; StringArg a3]
    | StringTermArgList (a1, a2, a3) ->
         [StringArg a1; StringArg a2; TermArg a3]
    | TermIntArgList (a1, a2, a3) ->
         [StringArg a1; TermArg a2; IntArg a3]
    | TermBoolArgList (a1, a2, a3) ->
         [StringArg a1; TermArg a2; BoolArg a3]
    | TermStringArgList (a1, a2, a3) ->
         [StringArg a1; TermArg a2; StringArg a3]
    | TermTermArgList (a1, a2, a3) ->
         [StringArg a1; TermArg a2; TermArg a3]
    | GeneralArgList args ->
         Array.to_list args

   (*
    * List all the normal attributes.
    *)
   let attributes { ref_attributes = { attr_terms = terms;
                                       attr_term_lists = term_lists;
                                       attr_types = types;
                                       attr_ints = ints;
                                       attr_bools = bools;
                                       attr_strings = strings;
                                       attr_options = options
                                     } } =
      (List.map (fun (name, t) -> name, TermArg t) terms)
      @ (List.map (fun (name, t) -> name, TermListArg t) term_lists)
      @ (List.map (fun (name, t) -> name, TypeArg t) types)
      @ (List.map (fun (name, i) -> name, IntArg i) ints)
      @ (List.map (fun (name, b) -> name, BoolArg b) bools)
      @ (List.map (fun (name, s) -> name, StringArg s) strings)
      @ (List.map (fun (op, kind) -> string_of_option kind, TermArg (mk_term (mk_op op []) []))) options

   let raw_attributes { ref_attributes = { attr_terms = terms;
                                           attr_term_lists = term_lists;
                                           attr_types = types;
                                           attr_ints = ints;
                                           attr_bools = bools;
                                           attr_strings = strings;
                                           attr_keys = keys;
                                           attr_options = options
                                     } } =
      (List.map (fun (name, t) -> name, RawTerm t) terms)
      @ (List.map (fun (name, t) -> name, RawTermList t) term_lists)
      @ (List.map (fun (name, t) -> name, RawType t) types)
      @ (List.map (fun (name, i) -> name, RawInt i) ints)
      @ (List.map (fun (name, b) -> name, RawBool b) bools)
      @ (List.map (fun (name, s) -> name, RawString s) strings)
      @ (List.map (fun (name, t) -> name, RawSentinal t) keys)
      @ (List.map (fun (op, kind) -> string_of_option kind, RawTerm (mk_term (mk_op op []) []))) options

   (************************************************************************
    * PROOF PRINTING                                                       *
    ************************************************************************)

   let format_alist1 buf ffunc (s,data) =
      format_string buf ";";
      format_space buf;
      format_string buf (s ^ "->");
      ffunc buf data

   let format_alist name buf ffunc = function
      [] ->
         ()
    | [s,data] ->
         format_space buf;
         format_pushm buf 2;
         format_string buf (name ^ " =");
         format_space buf;
         format_string buf ("[ " ^ s ^"->");
         ffunc buf data;
         format_string buf " ];";
         format_popm buf
    | (s,data)::rest ->
         format_space buf;
         format_pushm buf 2;
         format_string buf (name ^ " =");
         format_space buf;
         format_pushm buf 2;
         format_string buf ("[ " ^ s ^"->");
         ffunc buf data;
         List.iter (format_alist1 buf ffunc) rest;
         format_popm buf;
         format_space buf;
         format_string buf "];";
         format_popm buf

   let format_term1 db buf t =
      format_string buf ";";
      format_space buf;
      format_term db buf t

   let format_tlist db buf = function
      [] -> format_string buf "[]"
    | [t] ->
         format_string buf "[ ";
         format_term db buf t;
         format_string buf " ]"
    | t::rest ->
         format_pushm buf 2;
         format_string buf "[ ";
         format_term db buf t;
         List.iter (format_term1 db buf) rest;
         format_popm buf;
         format_space buf;
         format_string buf "]"

   let format_bool buf b =
      let s = if b then "tt" else "ff" in
      format_string buf s

   let format_attrs db buf attrs =
      format_pushm buf 2;
      format_string buf "<";
      format_alist "terms" buf (format_term db) attrs.attr_terms;
      format_alist "term_lists" buf (format_tlist db) attrs.attr_term_lists;
      format_alist "types" buf (format_term db) attrs.attr_types;
      format_alist "ints" buf format_int attrs.attr_ints;
      format_alist "bools" buf format_bool attrs.attr_bools;
      format_alist "strings" buf format_string attrs.attr_strings;
      format_popm buf;
      format_space buf;
      format_string buf ">"

   (*
    * format an extract.
    *)
   let rec format_extract db buf = function
      Goal arg ->
         format_pushm buf 2;
         format_string buf "Goal:";
         format_hspace buf;
         format_arg db buf arg;
         format_popm buf

    | Identity arg ->
         format_pushm buf 2;
         format_string buf "Identity:";
         format_hspace buf;
         format_arg db buf arg;
         format_popm buf

    | Annotate (arg1, arg2) ->
         format_pushm buf 2;
         format_string buf "Annotate:";
         format_hspace buf;
         format_arg db buf arg1;
         format_hspace buf;
         format_arg db buf arg2;
         format_popm buf

    | Unjustified (goal, subgoals) ->
         format_step buf db "Unjustified" goal subgoals
    | Extract (goal, subgoals, _) ->
         format_step buf db "Extract" goal subgoals

    | Wrapped (label, ext) ->
         format_pushm buf 2;
         format_string buf "Wrapped";
         begin match expand_arglist label with
            StringArg s :: _ ->
               format_hspace buf;
               format_string buf ("["^s^"...]");
               format_hspace buf;
          | _ -> ()
         end;
         format_string buf ":";
         format_hspace buf;
         format_extract db buf ext;
         format_popm buf

    | Compose { comp_status = status;
                comp_goal = goal;
                comp_subgoals = subgoals;
                comp_leaves = leaves;
                comp_extras = extras
      } ->
         format_pushm buf 2;
         format_string buf "Compose:";
         format_hspace buf;
         format_goal_subgoals db buf goal subgoals extras;
         format_popm buf

    | RuleBox { rule_status = status;
                rule_string = text;
                rule_extract = goal;
                rule_subgoals = subgoals;
                rule_extras = extras
      } ->
         format_pushm buf 2;
         format_string buf "Rule: ";
         format_string buf text;
         format_hspace buf;
         format_goal_subgoals db buf goal subgoals extras;
         format_popm buf

    | Pending _ ->
         format_string buf "Pending"

    | Locked ext ->
         format_pushm buf 2;
         format_string buf "Locked:";
         format_hspace buf;
         format_extract db buf ext;
         format_popm buf

   and format_step buf db name goal subgoals =
         format_pushm buf 2;
         format_string buf (name ^":");
         format_hspace buf;
         format_arg db buf goal;
         format_hspace buf;
         format_string buf "->";
         if subgoals==[] then
            format_string buf " []"
         else begin
            format_pushm buf 3;
            let f_sg sg =
               format_hspace buf;
               format_arg db buf sg;
               format_string buf ";";
           in List.iter f_sg subgoals;
               format_popm buf
         end;
         format_popm buf

   and format_goal_subgoals db buf goal subgoals extras =
      format_pushm buf 3;
      format_string buf "0. ";
      format_extract db buf goal;
      format_popm buf;
      let count =
         if subgoals = [] then
            1
         else
            format_subgoals db buf 1 subgoals
      in
         format_subgoals db buf count extras

   and format_subgoals db buf index = function
      subgoal :: subgoals ->
         format_hspace buf;
         format_pushm buf 3;
         format_int buf index;
         format_string buf ". ";
         format_extract db buf subgoal;
         format_popm buf;
         format_subgoals db buf (succ index) subgoals

    | [] ->
         index

   and format_arg db buf { ref_goal = goal; ref_attributes = attrs } =
      let goal, _ = Refine.dest_msequent goal in
         format_pushm buf 2;
         format_term db buf goal;
         format_space buf;
         format_string buf "with attrs";
         format_space buf;
         format_attrs db buf attrs;
         format_popm buf

   (*
    * Lazy attribute generation for keys.
    *)
   let term_attribute name t =
      name, RawTerm t

   let term_list_attribute name tl =
      name, RawTermList tl

   let type_attribute name t =
      name, RawType t

   let int_attribute name i =
      name, RawInt i

   let addr_attribute name a =
      name, RawAddr a

   let bool_attribute name flag =
      name, RawBool flag

   let string_attribute name s =
      name, RawString s

   (*
    * Fetch the attributes.
    *)
   let rec assoc name = function
      (name', h) :: _ when name = name' -> h
    | _ :: t -> assoc name t
    | [] -> raise (RefineError ("get_attribute", StringStringError ("attribute not found", name)))

   let rec assoc_option name = function
      (name', h) :: _ when name = name' -> Some h
    | _ :: t -> assoc_option name t
    | [] -> None

   let assoc_list name l =
      List.fold_left (fun vals (name', h) ->
            if name' = name then
               h :: vals
            else
               vals) [] l

   let get_term arg name =
      assoc name arg.ref_attributes.attr_terms

   let get_term_list arg name =
      assoc name arg.ref_attributes.attr_term_lists

   let get_type arg name =
      assoc name arg.ref_attributes.attr_types

   let get_int arg name =
      assoc_option name arg.ref_attributes.attr_ints

   let get_bool arg name =
      assoc_option name arg.ref_attributes.attr_bools

   let get_string arg name =
      assoc_option name arg.ref_attributes.attr_strings

   let get_strings arg name =
      assoc_list name arg.ref_attributes.attr_strings

   let get_resource arg get_res =
      get_res arg.ref_bookmark

   let mem_string arg name s =
      List.mem (name, s) arg.ref_attributes.attr_strings

   let get_options arg =
      arg.ref_attributes.attr_options

   let set_options arg options =
      let attr = { arg.ref_attributes with attr_options = options } in
         { arg with ref_attributes = attr }

   (*
    * Compare all the relevant parts of the attribute lists.
    *)
   let alpha_equal_term_list tl1 tl2 =
      List.length tl1 = List.length tl2 && List.for_all2 alpha_equal tl1 tl2

   let assoc_equal (l1 : (string * 'a) list) (l2 : (string * 'a) list) (f : 'a -> 'a -> bool) =
      (List.length l1 = List.length l2) && List.for_all2 (fun (s1, t1) (s2, t2) ->
            s1 = s2 && f t1 t2) l1 l2

   let opname_assoc_equal (l1 : (opname * 'a) list) (l2 : (opname * 'a) list) (f : 'a -> 'a -> bool) =
      (List.length l1 = List.length l2) && List.for_all2 (fun (s1, t1) (s2, t2) ->
            Opname.eq s1 s2 && f t1 t2) l1 l2

   let attributes_alpha_equal arg1 arg2 =
      let { attr_terms      = terms1;
            attr_term_lists = term_lists1;
            attr_types      = types1;
            attr_ints       = ints1;
            attr_bools      = bools1;
            attr_strings    = strings1;
            attr_options    = options1
          } = arg1
      in
      let { attr_terms      = terms2;
            attr_term_lists = term_lists2;
            attr_types      = types2;
            attr_ints       = ints2;
            attr_bools      = bools2;
            attr_strings    = strings2;
            attr_options    = options2
          } = arg2
      in
         assoc_equal terms1 terms2 alpha_equal
         && assoc_equal term_lists1 term_lists1 alpha_equal_term_list
         && assoc_equal types1 types2 alpha_equal
         && assoc_equal ints1 ints2 eq
         && assoc_equal bools1 bools2 eq
         && assoc_equal strings1 strings2 equal
         && opname_assoc_equal options1 options2 eq

   (*
    * Two args are equal if their goals are equal.
    * Other arguments are ignored.
    *)
   let tactic_arg_alpha_equal arg1 arg2 =
      msequent_alpha_equal arg1.ref_goal arg2.ref_goal

   (*
    * Also compare the assumptions.
    *)
   let tactic_arg_alpha_equal_with_attributes arg1 arg2 =
      let { ref_goal = goal1;
            ref_attributes = attr1
          } = arg1
      in
      let { ref_goal = goal2;
            ref_attributes = attr2
          } = arg2
      in
         msequent_alpha_equal goal1 goal2 && attributes_alpha_equal attr1 attr2

   (*
    * Match only the goals.
    *)
   let tactic_arg_alpha_equal_concl arg1 arg2 =
      let goal1 = msequent_goal arg1.ref_goal in
      let goal2 = msequent_goal arg2.ref_goal in
      let goal1 =
         if TermMan.is_sequent_term goal1 then
            TermMan.concl goal1
         else
            goal1
      in
      let goal2 =
         if TermMan.is_sequent_term goal2 then
            TermMan.concl goal2
         else
            goal2
      in
         alpha_equal goal1 goal2

   (************************************************************************
    * REFINEMENT                                                           *
    ************************************************************************)

   (*
    * The refiner just applies the tactic to the arg.
    * We keep a list of values
    *)
   let refine_final_list = ref []

   let add_final_hook f =
      refine_final_list := f :: !refine_final_list

   let refine tac arg =
      refine_final_list := [];
      let x = ThreadRefiner.eval (get_remote_server ()) (tac arg) in
         Lm_list_util.rev_iter (fun f -> f ()) !refine_final_list;
         refine_final_list := [];
         x

   (*
    * Utility for reconstructing the subgoals
    * in a tactic application.
    *)
   let make_labeled_subgoals labels arg goals =
      let rec collect labels goals =
         match labels, goals with
            label :: lt, goal :: gt ->
               let label =
                  match label with
                     Some label ->
                        label
                   | None ->
                        arg.ref_label
               in
               let goal =
                  { arg with ref_goal = goal;
                             ref_label = label;
                  }
               in
                  goal :: collect lt gt
          | [], [] ->
               []
          | _ ->
               raise (RefineError ("make_subgoals", StringError ("length mismatch between labels and goals")))
      in
         collect labels goals

   let make_subgoals arg goals =
      let rec collect = function
         goal :: t ->
            let goal = {
                  arg with
                  ref_goal = goal;
               }
            in
               goal :: collect t
       | [] ->
            []
      in
         collect goals

   (*
    * Eventually, we may want to look at the rule and do something
    * special here.
    *)
   let compile_rule refiner labels tac =
      (make_labeled_subgoals labels, tac)

   let compile_ml_rule refiner tac =
      (make_subgoals, tac)

   (*
    * Construct polymorphic tactic.
    *)
   let tactic_of_rule (make_subgoals, rl) addrs_names params arg =
      let rl = rl addrs_names params in
      let subgoals, ext = Refine.refine (get_sentinal arg.ref_sentinal) rl arg.ref_goal in
      let subgoals = make_subgoals arg subgoals in
         ThreadRefinerTacticals.create_value subgoals (Extract (arg, subgoals, ext))

   (*
    * Construct polymorphic tactic.
    *)
   let tactic_of_refine_tactic labels rl arg =
      let _ =
         if !debug_tactic then
            eprintf "Starting refinement%t" eflush
      in
      let { ref_goal = goal; ref_sentinal = sentinal } = arg in
      let subgoals, ext = Refine.refine (get_sentinal sentinal) rl goal in
      let subgoals = make_labeled_subgoals labels arg subgoals in
         if !debug_tactic then
            eprintf "tactic_of_rule done%t" eflush;
         subgoals, Extract (arg, subgoals, ext)

   (*
    * Convert a rewrite into a tactic.
    *)
   let tactic_of_rewrite_exn1 = RefineError ("tactic_of_rewrite", StringError "rewrite did not produce a goal")
   let tactic_of_rewrite_exn2 = RefineError ("tactic_of_rewrite", StringError "rewrite produced too many goals")

   let tactic_of_rewrite i rw arg =
      let rl = rwtactic i rw in
         match Refine.refine (get_sentinal arg.ref_sentinal) rl arg.ref_goal with
            [subgoal], ext ->
               let subgoal =
                  { arg with ref_goal = subgoal }
               in
                  ThreadRefinerTacticals.create_value [subgoal] (Extract (arg, [subgoal], ext))
          | [], _ ->
               raise tactic_of_rewrite_exn1
          | _ ->
               raise tactic_of_rewrite_exn2

   (*
    * Convert a conditional rewrite to a tactic.
    *)
   let tactic_of_cond_rewrite i crw arg =
      let rl = crwtactic i crw in
      let subgoals, ext = Refine.refine (get_sentinal arg.ref_sentinal) rl arg.ref_goal in
      let make_subgoal label goal =
         { arg with ref_label = label;
                    ref_goal = goal;
         }
      in
      let subgoals =
         match subgoals with
            subgoal :: subgoals ->
               make_subgoal arg.ref_label subgoal :: List.map (make_subgoal "assertion") subgoals
          | [] ->
               raise (Invalid_argument "tactic_of_cond_rewrite: produced no subgoals")
      in
         ThreadRefinerTacticals.create_value subgoals (Extract (arg, subgoals, ext))

   (************************************************************************
    * TACTICALS                                                            *
    ************************************************************************)

   (*
    * Assumption tactic from the refiner.
    * Assumptions are numbered from 1, but
    * refiner numbers them from 0.
    *)
   let nthAssumT i p =
      let i = pred i in
         if !debug_refine then
            begin
               let { ref_goal = seq } = p in
               let goal, hyps = dest_msequent seq in
                  eprintf "Tactic_type.nthAssumT:\nHyp: %d%t" i eflush;
                  List.iter (fun hyp ->
                        print_term stderr hyp;
                        eflush stderr) hyps;
                  eprintf "\nGoal: ";
                  print_term stderr goal;
                  eflush stderr
            end;
         let subgoals, ext = tactic_of_refine_tactic [] (Refine.nth_hyp i) p in
            ThreadRefinerTacticals.create_value subgoals ext

   (* funT is just an application *)
   let funT tac p = tac p p
   let argfunT tac arg p = tac arg p p
   let argfun2T tac arg1 arg2 p = tac arg1 arg2 p p

   (*
    * Identity doesn't do anything.
    *)
   let idT p =
      ThreadRefinerTacticals.create_value [p] (Identity p)

   (*
    * Cut rule.
    *)
   let cutT t p =
      let subgoals, ext = tactic_of_refine_tactic [Some "assertion"; Some "main"] (Refine.cut t) p in
         ThreadRefinerTacticals.create_value subgoals ext

   (*
    * Add a checker.
    *)
   let subgoalsCheckT =
      ThreadRefinerTacticals.check_terms

   (*
    * Sequencing tactics.
    *)
   let prefix_thenT tac1 tac2 =
      if tac1 == idT then
         tac2
      else if tac2 == idT then
         tac1
      else
         ThreadRefinerTacticals.compose1 tac1 tac2

   let prefix_thenLocalLabelT =
      let emptyLabel = "" in
      let prefer_label l p =
         if p.ref_label = emptyLabel then
            { p with ref_label = l }
         else
            p
      in
      let prefix_emptyLabel_thenT tac1 tac2 p =
         let p =
            if p.ref_label = emptyLabel then
               p
            else
               { p with ref_label = emptyLabel }
         in
            prefix_thenT tac1 tac2 p
      in
      fun tac1 tac2 p ->
         let label = p.ref_label in
            ThreadRefinerTacticals.wrap_terms (**)
               (prefer_label label)
               (prefix_emptyLabel_thenT tac1 tac2)
               p

   let prefix_thenLT tac1 tacl =
      if tac1 == idT then
         match tacl with
            [tac] ->
               tac
          | _ ->
               raise (RefineError("thenLT", StringError "tactic list length is wrong"))
      else
         ThreadRefinerTacticals.compose2 tac1 tacl

   let firstT =
      let non_id tac = (tac != idT) in
         fun tacl ->
            match Lm_list_util.filter non_id tacl with
               [tac] -> tac
             | tacl -> ThreadRefinerTacticals.first tacl

   let wrapT = ThreadRefinerTacticals.wrap

   let forceT = ThreadRefinerTacticals.force

   let prefix_orelseT tac1 tac2 =
      if tac1 == idT then
         idT
      else
         ThreadRefinerTacticals.first [tac1; tac2]

   let prefix_thenFLT =
      let rec join tacs args =
         match (tacs, args) with
            t::tacs, a::args ->
               (t a) :: (join tacs args)
          | [], [] ->
               []
          | _ ->
               raise (RefineError("thenFLT", StringError "list length mismatch"))
      in let wrap tacf args =
         let tacs = tacf args in
            join tacs args
      in fun tac tacf ->
         if tac == idT then
            fun p ->
               match tacf [p] with
                  [tac] -> tac p
                | _ -> raise (RefineError("thenFLT", StringError "list length mismatch"))
         else
            ThreadRefinerTacticals.composef tac (wrap tacf)

   (*
    * Modify the label.
    *)
   let setLabelT name p =
      idT { p with ref_label = name }

   (*
    * Add a permanent argument.
    *)
   let addT f p1 =
      let p2 = { p1 with ref_attributes = f p1.ref_attributes } in
         ThreadRefinerTacticals.create_value [p2] (Annotate (p1, p2))

   let addTermT name t =
      addT (fun attr -> { attr with attr_terms = (name, t) :: attr.attr_terms })

   let addTermListT name arg =
      addT (fun attr -> { attr with attr_term_lists = (name, arg) :: attr.attr_term_lists })

   let addTypeT name t =
      addT (fun attr -> { attr with attr_types = (name, t) :: attr.attr_types })

   let addIntT name i =
      addT (fun attr -> { attr with attr_ints = (name, i) :: attr.attr_ints })

   let addBoolT name flag =
      addT (fun attr -> { attr with attr_bools = (name, flag) :: attr.attr_bools })

   let addStringT name s =
      addT (fun attr -> { attr with attr_strings = (name, s) :: attr.attr_strings })

   let addOptionT name code =
      addT (fun attr -> { attr with attr_options = (name, code) :: attr.attr_options  })

   (*
    * Add a temporary argument.
    *)
   let withT f tac p =
      let attributes = p.ref_attributes in
      let attributes' = f attributes in
      let make_goal p =
         let p' = { p with ref_attributes = attributes' } in
            ThreadRefinerTacticals.create_value [p'] (Identity p)
      in
      let make_subgoal p =
         idT { p with ref_attributes = attributes }
      in
         (prefix_thenT make_goal (prefix_thenT tac make_subgoal)) p

   let withTermT name t =
      withT (fun attr -> { attr with attr_terms = (name, t) :: attr.attr_terms })

   let withTermListT name arg =
      withT (fun attr -> { attr with attr_term_lists = (name, arg) :: attr.attr_term_lists })

   let withTypeT name t =
      withT (fun attr -> { attr with attr_types = (name, t) :: attr.attr_types })

   let withIntT name i =
      withT (fun attr -> { attr with attr_ints = (name, i) :: attr.attr_ints })

   let withBoolT name flag =
      withT (fun attr -> { attr with attr_bools = (name, flag) :: attr.attr_bools })

   let withStringT name s =
      withT (fun attr -> { attr with attr_strings = (name, s) :: attr.attr_strings })

   let withOptionT name s =
      withT (fun attr -> { attr with attr_options = (name, s) :: attr.attr_options })

   (*
    * Remove an argument permanently.
    *)
   let removeT = addT

   let removeTermT name =
      removeT (fun attr -> { attr with attr_terms = List.remove_assoc name attr.attr_terms })

   let removeTermListT name =
      removeT (fun attr -> { attr with attr_term_lists = List.remove_assoc name attr.attr_term_lists })

   let removeTypeT name =
      removeT (fun attr -> { attr with attr_types = List.remove_assoc name attr.attr_types })

   let removeIntT name =
      removeT (fun attr -> { attr with attr_ints = List.remove_assoc name attr.attr_ints })

   let removeBoolT name =
      removeT (fun attr -> { attr with attr_bools = List.remove_assoc name attr.attr_bools })

   let removeStringT name =
      removeT (fun attr -> { attr with attr_strings = List.remove_assoc name attr.attr_strings })

   let removeStringValT name s =
      removeT (fun attr -> { attr with attr_strings = Lm_list_util.remove (name, s) attr.attr_strings })

   let removeOptionT name =
      removeT (fun attr -> { attr with attr_options = List.remove_assoc name attr.attr_options })

   (*
    * Remove an argument permanently.
    *)
   let withoutT = withT

   let withoutTermT name =
      withoutT (fun attr -> { attr with attr_terms = List.remove_assoc name attr.attr_terms })

   let withoutTermListT name =
      withoutT (fun attr -> { attr with attr_term_lists = List.remove_assoc name attr.attr_term_lists })

   let withoutTypeT name =
      withoutT (fun attr -> { attr with attr_types = List.remove_assoc name attr.attr_types })

   let withoutIntT name =
      withoutT (fun attr -> { attr with attr_ints = List.remove_assoc name attr.attr_ints })

   let withoutBoolT name =
      withoutT (fun attr -> { attr with attr_bools = List.remove_assoc name attr.attr_bools })

   let withoutStringT name =
      withoutT (fun attr -> { attr with attr_strings = List.remove_assoc name attr.attr_strings })

   let withoutStringValT name s =
      withoutT (fun attr -> { attr with attr_strings = Lm_list_util.remove (name, s) attr.attr_strings })

   let withoutOptionT name =
      withoutT (fun attr -> { attr with attr_options = List.remove_assoc name attr.attr_options })

   (*
    * Time the tactic.
    * This shows the time between now and the end of refinement.
    *)
   let finalT f p =
      add_final_hook f;
      idT p

   let timingT tac p =
      let start = Unix.times () in
      let start_time = Unix.gettimeofday () in
      let finalize () =
         let finish = Unix.times () in
         let finish_time = Unix.gettimeofday () in
            eprintf "User time %f; System time %f; Real time %f%t" (**)
               ((finish.Unix.tms_utime +. finish.Unix.tms_cutime)
                -. (start.Unix.tms_utime +. start.Unix.tms_cstime))
               ((finish.Unix.tms_stime +. finish.Unix.tms_cstime)
                -. (start.Unix.tms_stime +. finish.Unix.tms_cstime))
               (finish_time -. start_time)
               eflush
      in
         add_final_hook finalize;
         tac p

   (*
    * Create a dummy arg for debugging.
    *)
   let debug_arg bookmark t =
      { ref_goal = mk_msequent t [];
        ref_label = "main";
        ref_attributes = empty_attribute;
        ref_bookmark = bookmark;
        ref_sentinal = any_sentinal
      }
end

(*
 * Type definitions.
 *)
module TacticInternalType = Tactic

(*
 * Internal functions.
 *)
module TacticInternal = Tactic

(*
 * -*-
 * Local Variables:
 * Caml-master: "refiner"
 * End:
 * -*-
 *)
