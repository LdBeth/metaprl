<HTML>
<HEAD>
  <META NAME="GENERATOR" CONTENT="Adobe PageMill 3.0 Win">
  <TITLE>Nuprl-Light Computational Rewriting</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">

<H1>Nuprl-Light Computational Rewriting</H1>

<P>Nuprl-Light defines two kinds of logical inferences: <I>computational
rewriting</I> and <I>inference rules</I>. This page describes
computational rewriting. <A HREF="nl-axiom.html">Inference rules</A>
are described on the next page.</P>

<H4>Declarations</H4>

<P>Rewrites are declared with the following form:</P>

<BLOCKQUOTE>
  <P><B><TT>rewrite </TT></B><I>name<TT> </TT></I><TT>[</TT><I>params</I><TT>]
  : [</TT><I>conditions</I><TT>] </TT><I>redex</I><TT> &lt;--&gt;
  </TT><I>contractum</I></P>
</BLOCKQUOTE>

<P>A <I>simple</I> rewrite is defined as an equivalence between
terms. For instance, the rewrite for beta-reduction is defined
in the <TT>Itt_rfun</TT> module as follows:</P>

<BLOCKQUOTE>
  <PRE><B>rewrite</B> reduceBeta : (lambda{v. 'b['v]} 'a) &lt;--&gt; 'b['a]</PRE>
</BLOCKQUOTE>

<P>This rewrite pattern defines the <I>beta</I> redex, and its
contractum. The contractum is formed by <I>substituion</I>. When
the rewrite is applied to a beta-redex, the term matched by <TT>'a</TT>
is substituted for the variable matched by <TT>'v</TT> in the
body <TT>'b</TT>.</P>

<P>Rewrites can also be <I>conditional:</I> they may depend on
conditions provable in the context. Conditional rewrites are only
defined for sequent calculi. Conditions are specified with the
meta-implication <TT>--&gt;</TT>. The following rewrite is an
example of conditional rewriting in the <TT>Itt_int</TT> module:</P>

<BLOCKQUOTE>
  <P><B><TT>rewrite</TT></B><TT> unit : ('i != 0 in int) --&gt;
  ((i /@ i) &lt;--&gt; 1)</TT></P>
</BLOCKQUOTE>

<P><I>Parameters</I> provide extra variables and terms that are
needed for rewriting. For example, a rewrite for reversing the
beta reduction requires a term specifying the abstracted body
(since it is not unique), a variable representing the bound variable,
and also the argument of the application.</P>

<BLOCKQUOTE>
  <PRE><B><TT>rewrite</TT></B><TT> inverseBeta lambda{v. 'b['v]} 'a :</TT>
<TT>   'b['a] &lt;--&gt; (lambda{v. 'b['v]} 'a)</TT></PRE>
</BLOCKQUOTE>

<H4>Implementations</H4>

<P>Rewrites are <I>implemented</I> with two forms: rewrites that
are primitive to a logic use the <TT>primrw</TT> form:</P>

<BLOCKQUOTE>
  <P><B><TT>primrw </TT></B><I>name </I><TT>[</TT><I>params</I><TT>]
  : [</TT><I>conditiona</I><TT>] </TT><I>redex<TT> </TT></I><TT>&lt;--&gt;
  </TT><I>contractum</I></P>
</BLOCKQUOTE>

<P>If a declaration is given for the rewrite, the form in the
<TT>primrw</TT> must be the same (with possible renamining in
the bound variables).</P>

<P>Rewrites that are derived from previous rules in the logic
are implemented with the <TT>interactiverw</TT> form. The definition
has the same form as the <TT>primrw</TT>:</P>

<BLOCKQUOTE>
  <P><B><TT>interactiverw</TT></B><TT> </TT><I>name</I><TT> [</TT><I>params</I><TT>]
  : [</TT><I>conditions</I><TT>] </TT><I>redex</I><TT> &lt;--&gt;
  </TT><I>contractum</I></P>
</BLOCKQUOTE>

<P>The <TT>interactiverw</TT> form establishes a proof obligation,
which may be fulfilled with the proof editor. The rewrite may
be used whether it has been verified or not. When a logical theory
is finished, the editor can be used to check for unsatisfied subproofs.
Primitive rewrites never require a proof obligation, unstaisfied
interactive rewrites generate an error during proof checking.

</BODY>
</HTML>
