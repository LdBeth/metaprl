<HTML>
<HEAD>
  <META NAME="GENERATOR" CONTENT="Adobe PageMill 3.0 Win">
  <TITLE>Nuprl-Light Distributed Tactics</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">

<H1>Nuprl-Light Distributed Tactics</H1>

<P><IMG SRC="proof-tree.gif" WIDTH="212" HEIGHT="132" ALIGN="RIGHT"
BORDER="0" NATURALSIZEFLAG="3">The process of proving generates
<I>proof trees</I>. Each node in a proof is refined to a list
of subgoals. Each branch in the tree may be <I>and-branching</I>,
meaining that <I>all</I> subgoals are required for a successful
proof; or a branch may <I>or-branching</I>, where <I>any</I> of
the subgoals are sufficient to form a proof. A typical proof tree
fragment is shown at the right. The root node produces an and-branch
with two subgoals. The right subchild is an or-node, and either
of the subgoals is sufficient to prove the goal.</P>

<H4>Tactics</H4>

<P>The <I>tactic</I> mechanism is used to generate proof trees.
Each rule in a logic produces a primitive tactic. Primitive tactics
are always and-branching. The following digram is an example of
a tactic defined in <TT>Itt_logic</TT>.</P>

<BLOCKQUOTE>
  <P><IMG SRC="proof-node.gif" WIDTH="348" HEIGHT="51" ALIGN="BOTTOM"
  BORDER="0" NATURALSIZEFLAG="3"></P>
</BLOCKQUOTE>

<P>The ML value defined by this rule has the following type: <B><TT>val</TT></B><TT>
imp_intro : string -&gt; tactic</TT>. Tactics are implemented
as functions that take a proof goal, and produce a list of subgoals,
and an <I>extract</I> that summarizes the proof step. The tactic
module defines the following set of operations for proving with
tactics.</P>

<BLOCKQUOTE>
  <PRE><B>module type</B> Refiner =
<B>sig</B>
    <B>type</B> term
    <B>type</B> extract
    <B>type</B> tactic = term -&gt; term list * extract
    <B>val</B> compose : extract -&gt; extract list -&gt; extract
    <B>val</B> andthen1 : tactic -&gt; tactic -&gt; tactic
    <B>val</B> andthen2 : tactic -&gt; tactic list -&gt; tactic
    <B>val</B> choose : tactic list -&gt; tactic
<B>end</B></PRE>
</BLOCKQUOTE>

<P>Each <TT>extract</TT> defines a partial proof tree; the <TT>compose</TT>
function builds larger fragments from pieces. A tactic either
suceeds, by returning a list of subgoals, or it <I>fails</I> by
raising an exception.</P>

<P>There are three <I>tacticals:</I> the <TT>andthen1</TT> tactical
is defined informally as follows: the tactic (<TT>andthen1 tac1
tac2</TT>) applies <TT>tac1</TT> to a goal <I>t</I>, producing
subgoals <I>t1, ..., tn</I>. The second tactic <TT>tac2</TT> is
applied to each of these subgoals, and the subgoals it produces
are concatenated to form the final result.</P>

<P><CENTER><IMG SRC="andthen1.gif" WIDTH="291" HEIGHT="151" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></CENTER></P>

<P>The <TT>andthen2</TT> tactic is similar to the <TT>anthen1</TT>
tactic, but it allows different tactics to be applied to the subgoals.
The tactic <TT>(andthen2 tac [tac1; tac2; ...; tacn])</TT> tactic
requires that the <TT>tac</TT> tactic produce exactly <TT>n</TT>
subgoals, and <TT>tac<I>i</I></TT> is applied to subgoal <I><TT>i</TT></I>.</P>

<P><CENTER><IMG SRC="andthen2.gif" WIDTH="298" HEIGHT="176" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></CENTER></P>

<P>The <CODE><TT>choose</TT></CODE> tactical allows searching
with tactics. The tactic <TT>(choose [tac1; tac2; ...; tacn])</TT>
applies each tactic <TT>tac1</TT>, <TT>tac2</TT>, <TT>...</TT>
in turn until the first one succeeds.</P>

<P><CENTER><IMG SRC="choose.gif" WIDTH="285" HEIGHT="118" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></CENTER></P>

<H4>Scheduler</H4>

<P><IMG SRC="sched2.gif" WIDTH="281" HEIGHT="345" ALIGN="RIGHT"
BORDER="0" NATURALSIZEFLAG="3">There is a great deal of parallelism
in tactic-tree proofs: the branches of the proof considered independently.
The branching factor is typically bounded by a constant, but the
depth of the tree can grow to be quite large. for performance
reasons, it is not desireable to completely thread the proof because
the contention between threads would be quite large.</P>

<P>In the Nuprl-Light architecture, the <I>base</I> of the proof
saved by a <I>scheduler</I>, which produces subjobs for independent
threads. A diagram of the general architecure is shown in the
figure at the right. A <I>client</I> (in this case, the Nuprl-Light
proof editor) submits a job to the scheduler containing a proof
<I>goal</I>, and the <I>tactic</I> to be applied to it.</P>

<P>The scheduler does not perform and active computation on the
proof goal, but it has subthreads to do computation for it. There
are seven operations that the scheduler performs:</P>

<OL>
  <LI>issue a new job to a subthread (<I>produce</I>),
  <LI>ask a subthread for an unfinished job (<I>consume</I>),
  <LI>receive a result from a finished subjob (<I>return</I>),
  <LI>cancel a running thread (<I>cancel</I>),
  <LI>accept a job from a client (<I>submit</I>),
  <LI>return a result to a client (<I>client-return</I>),
  <LI>accept a cancelation from a client (<I>client-cancel</I>).
</OL>

<P>The <B>produce</B> operation produces a new job that can be
assigned to a new thread. The <B>consume</B> operation does the
opposite: it asks a running thread to return a portion of its
proof tree to the scheduler.</P>

<P><CENTER><IMG SRC="consume.gif" WIDTH="187" HEIGHT="154" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"><IMG SRC="produce.gif" WIDTH="198"
HEIGHT="154" ALIGN="TOP" BORDER="0" NATURALSIZEFLAG="3"></CENTER></P>

<P>The scheduler is implemented in the module <TT>Thread_refiner_ens</TT>.
The scheduler maintains a constant sized pool of threads that
can be assignmed to subjobs. The scheduler maintains several job
queues: the <I>running</I> queue list the currently running threads,
and their locations in the proof tree; the <I>pending</I> queue
lists nodes of the proof tree that haven't been assigned; and
the <I>waiting</I> queue is a list of running threads that have
been signalled. When a new job is submitted by a client, the scheduler
places the job in the <I>pending</I> job pool, and enters the
scheduler loop:</P>

<BLOCKQUOTE>
  <UL>
    <LI>If there is an idle thread, and a pending job, assign the
    thread to the job, and move the new node to the <I>running</I>
    queue.
    <LI>If there are running jobs, and no entries in the pending
    queue, <I>signal</I> all threads to return a portion of their
    proof tree to the scheduler.
    <LI>When a thread completes, <I>prune</I> the scheduler tree
    with the new result, and move the thread to the <I>idle</I> queue.
    <LI>If the scheduler proof tree is complete, return the result
    to the client.
    <LI>If the client cancels the job, <I>kill</I> all threads, and
    delete the proof tree.
  </UL>
</BLOCKQUOTE>

<H4>Proof tree pruning</H4>

<P>The most complex operation in the scheduler is tree pruning.
There are eight cases for inserting a result into the proof tree.

</BODY>
</HTML>
