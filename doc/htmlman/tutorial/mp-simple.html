<HTML>
<HEAD>
  <META NAME="GENERATOR" CONTENT="Adobe PageMill 3.0 Win">
  <TITLE>MetaPRL: Implication</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>MetaPRL Tutorial: Implication</H2>

<P>After you have defined the term <TT>true</TT> and <TT>false</TT>,
the next step is to define the simple logical operators <TT>not</TT>,
<TT>and</TT>, <TT>or</TT>, and <TT>implies</TT>. In this page,
we go through the process of implementing the <TT>implies</TT>
module; the process is similar for the other operators, and the
files may be found in the distribution.</P>

<H3><TT>Implies</TT> interface</H3>

<P>The interface for implies follows the standard format. We <TT>include</TT>
the <TT>Fol_type</TT> module to define well-formedness of the
term, and we declare a new binary operator for implies. We also
define proof terms <TT>lambda</TT> and <TT>apply</TT>, and display
form precedences for each of the new terms.</P>

<BLOCKQUOTE>
  <P>1. <I>Define the </I><TT>implies</TT> <I>interface by adding
  the following lines to the file </I><TT>fol_implies.mli</TT>:</P>
  <BLOCKQUOTE>
    <PRE><B>include</B> Fol_type

<B>prec</B> prec_implies
<B>prec</B> prec_lambda
<B>prec</B> prec_apply

<B>declare</B> implies
<B>declare</B> lambda{x. 'b['x]}
<B>declare</B> apply{'f; 'a}</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<H3><TT>Implies</TT> implementation</H3>

<H4>Syntax declarations:</H4>

<P>The implementation for the <TT>implies</TT> term includes the
declarations of the interface, and it also defines a display form,
and the introduction and elimination rules for implication.</P>

<BLOCKQUOTE>
  <P>2. <I>Declare the syntax for the </I><TT>implies</TT><I> operator
  by adding the following lines to the file </I><TT>fol_implies.ml</TT>:</P>
  <BLOCKQUOTE>
    <PRE><B>include</B> Fol_type

<B>declare</B> implies
<B>declare</B> lambda{x. 'b['x]}
<B>declare</B> apply{'f; 'a}</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<H4>Display</H4>

<P>The next step is to provide display forms that print these
terms using standard terminology. The display forms for these
terms require parenthesization for non-ambiguous parsing, so we
introduce several precedence declarations.</P>

<BLOCKQUOTE>
  <P>3.<I> Provide precedence delcarations for pretty-printing,
  by adding the following lines to the </I><TT>fol_implies.ml</TT><I>
  file:</I></P>
  <BLOCKQUOTE>
    <PRE><B>prec</B> prec_implies
<B>prec</B> prec_lambda
<B>prec</B> prec_apply

<B>prec</B> prec_lambda &lt; prec_apply
<B>prec</B> prec_lambda &lt; prec_implies
<B>prec</B> prec_implies &lt; prec_apply</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>These precedence declarations impose a mimimum requirement
on the order for the precedences <TT>prec_lambda &lt; prec_implies
&lt; prec_apply</TT>.</P>

<P>The display form are added with <TT>dform</TT> declarations.</P>

<BLOCKQUOTE>
  <P>4. <I>Add display forms for each of the terms in </I><TT>Fol_implies</TT><I>:</I></P>
  <BLOCKQUOTE>
    <PRE><B>dform</B> implies_df : parens :: &quot;prec&quot;[&quot;prec_implies&quot;] :: implies{'A; 'B} =
   szone pushm[0] slot{'A} hspace Rightarrow `&quot; &quot; slot{'B} popm ezone
<B>dform</B> lambda_df : parens :: &quot;prec&quot;[&quot;prec_lambda&quot;] :: lambda{x. 'b} =
   szone pushm[3] Nuprl_font!lambda slot{'x} `&quot;.&quot; slot{'b} popm ezone
<B>dform</B> apply_df : parens :: &quot;prec&quot;[&quot;prec_apply&quot;] :: apply{'f; 'a} =
   slot{'f} hspace slot{'a}</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<H4>Computation Rules</H4>

<P>The <TT>Fol_implies</TT> module defines computation over the
proof terms <TT>lambda</TT> and <TT>apply</TT>. Computation uses
the standard beta-reduction form.</P>

<BLOCKQUOTE>
  <P>5.<I> Define computation over proof terms with the following
  rewrite rule:</I></P>
  <BLOCKQUOTE>
    <PRE><B>primrw</B> beta : (lambda{x. 'b['x]} 'a) &lt;--&gt; 'b['a]</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<H4>Inference Rules</H4>

<P>The implication has introduction and elimination rules corresponding
to natural deduction rules for implication: in order to prove
<TT>(A =&gt; B)</TT>, assume <TT>A</TT> and prove B; if <TT>A</TT>
is provable with assumption <TT>(A =&gt; B)</TT>, then <TT>B</TT>
is also a valid assumption. We add the inference rules as follows.</P>

<BLOCKQUOTE>
  <P>6. <I>Add the inference rules for implication:</I></P>
  <BLOCKQUOTE>
    <PRE><B>prim</B> implies_type 'H :
   <B>sequent</B> ['ext] { 'H &gt;- &quot;type&quot;{'A} } --&gt;
   <B>sequent</B> ['ext] { 'H &gt;- &quot;type&quot;{'B} } --&gt;
   <B>sequent</B> ['ext] { 'H &gt;- &quot;type&quot;{implies{'A; 'B}} } = trivial

<B>prim</B> implies_intro 'H 'x :
   <B>sequent</B> ['ext] { 'H &gt;- &quot;type&quot;{'A} } --&gt;
   ('b['x] : <B>sequent</B> ['ext] { 'H; x: 'A &gt;- 'B }) --&gt;
   <B>sequent</B> ['ext] { 'H &gt;- 'A =&gt; 'B } = lambda{x. 'b['x]}

<B>prim</B> implies_elim 'H 'J 'b :
   ('a : <B>sequent</B> ['ext] { 'H; f: 'A =&gt; 'B; 'J['f] &gt;- 'A }) --&gt;
   ('x['b] : <B>sequent</B> ['ext] { 'H; f: 'A =&gt; 'B; 'J['f]; b: 'B &gt;- 'C['f] }) --&gt;
   <B>sequent</B> ['ext] { 'H; f: 'A =&gt; 'B; 'J['f] &gt;- 'C['f] } = 'x['f 'a]</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>The proof terms for the rules use <I>second-order</I> binding.
For instance, the proof term for the <TT>implies_intro</TT> rule
uses the second-order binding <TT>'b['x]</TT> to form the body
of the <TT>lambda</TT>.</P>

<H4>Automation</H4>

<P>The basic proof automation is accomplished by adding the rules
for implication to the <TT>dT</TT> tactic. Just as for the <TT>Fol_false</TT>
module, we need a rule for well-formedness.</P>

<BLOCKQUOTE>
  <P>7. <I>Add the well-formedness rule to the </I><TT>dT</TT>
  <I>tactic as follows:</I></P>
  <BLOCKQUOTE>
    <PRE><B>let</B> d_implies_type i p =
   <B>if</B> i = 0 then
      implies_type (Sequent.hyp_count_addr p) p
   <B>else</B>
      <B>raise</B> (RefineError (&quot;d_implies_type&quot;, StringError &quot;no elimination form&quot;))

<B>let</B> implies_type_term = &lt;&lt; &quot;type&quot;{implies{'A; 'B}} &gt;&gt;

<B>let</B> d_resource = Mp_resource.resource_improve d_resource
                    (implies_type_term, d_implies_type)</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>The introduction and elimination forms are added as a single
addition.</P>

<BLOCKQUOTE>
  <P>8. <I>Add the introduction and elimination forms to the </I><TT>dT</TT><I>
  tactic:</I></P>
  <BLOCKQUOTE>
    <PRE><B>let</B> d_implies i p =
   <B>if</B> i = 0 then
      <B>let</B> v = Var.maybe_new_vars1 p &quot;v&quot; in
         implies_intro (Sequent.hyp_count_addr p) v p
   <B>else</B>
      <B>let</B> v = Var.maybe_new_vars1 p &quot;v&quot; in
      <B>let</B> j, k = Sequent.hyp_indices p i in
         implies_elim j k v p

<B>let</B> implies_term = &lt;&lt; &quot;implies&quot;{'A; 'B} &gt;&gt;

<B>let</B> d_resource = Mp_resource.resource_improve d_resource
                    (implies_term, d_implies)</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>Both forms make use of the <TT>Var.maybe_new_vars1</TT> function
to compute a &quot;new&quot; variable name not occurreng elsewhere
in the goal.</P>

<H3>View the theory</H3>

<P>Before going on, we can view the theory in the editor. After
compiling the FOL theory, and compiling the editor, this is the
edited display.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_implies1.gif" WIDTH="670" HEIGHT="776"
ALIGN="BOTTOM" BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>The module summary contains an item for each of the parts of
the theory. The ML functions are included, but the function bodies
have been elided.

</BODY>
</HTML>
