<HTML>
<HEAD>
  <META NAME="GENERATOR" CONTENT="Adobe PageMill 3.0 Win">
  <TITLE>MetaPRL Tutorial: Quantifiers</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#000099" VLINK="#009900" ALINK="#ff0000">

<H2>MetaPRL Tutorial: Quantifiers</H2>

<H3>Introduction</H3>

<P>The declaration of the quantifiers <TT>exists</TT> and <TT>all</TT>
require the introduction of a <I>universe</I> of formulas to quantify
over. At this point, the issue of <I>predicativity</I> comes into
play:</P>

<UL>
  <LI>Does the universe of formulas contain all well-formed formulas,
  including the quantified formulas (an <I>impredicative</I> definition),
  <LI>or is the universe stratified to prevent self-quantification
  (a <I>predicative</I> definition)?
</UL>

<P>The Nuprl type theory adopts the <I>predicative</I> definition,
and formulas are stratified into type universes so that no non-trivial
type is a member of itself. For this logic, we adopt an <I>impredicative</I>
theory, which restricts the models of the logic, but increases
its expressiveness. To start, we need to define the universe of
formulas in the <TT>Fol_univ</TT> module.</P>

<H3>The <TT>Fol_univ</TT> interface</H3>

<P>The interface for the <TT>Fol_univ</TT> module defines the
formula <I>universe</I> term.</P>

<BLOCKQUOTE>
  <P>1.<I> Define the universe of formulas in the file</I> <TT>fol_univ.mli</TT><I>
  as follows:</I></P>
  <BLOCKQUOTE>
    <PRE><B>include</B> Fol_type
<B>declare</B> univ</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<H3>The <TT>Fol_univ</TT> implementation</H3>

<P>The implementation contains the usual definitions for the syntax
and display forms.</P>

<BLOCKQUOTE>
  <P>2.<I> Define the universe syntax in the file </I><TT>fol_univ.ml:</TT></P>
  <BLOCKQUOTE>
    <PRE><B><TT>include</TT></B><TT> Fol_type</TT>

<B><TT>declare</TT></B><TT> univ</TT>

<B><TT>dform</TT></B><TT> univ_df : univ = `&quot;Univ&quot;</TT></PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>Any element of the universe of formulas is a well-defined formula.
We can express this in the following rule:</P>

<BLOCKQUOTE>
  <P>3.<I> Define well-formedness of quantified formulas:</I></P>
  <BLOCKQUOTE>
    <PRE><B><TT>prim</TT></B><TT> univ_type 'H 'J : :
   <B>sequent</B> ['ext] { 'H; x: univ; 'J['x] &gt;- &quot;type&quot;{'x} } = trivial</TT></PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>This rule is a little different that the previous rules: it
requires a particular terms in both the hypothesis and the conclusion.
The application of this rule is <I>context-sensitive</I>, so it
is not a good candidate for automation with the <TT>dT</TT> tactic.
Instead, we provide a custom tactic to perform universal reasoning.</P>

<BLOCKQUOTE>
  <P>4. <I>Define a tactic for reasoning about universal quantification:</I></P>
  <BLOCKQUOTE>
    <PRE><B><TT>let</TT></B><TT> nthUnivT i p =
   <B>let</B> j, k = Sequent.hyp_indices p i in
      univ_type j k p</TT></PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>This tactic applies the <TT>univ_type</TT> rule to a specific
hypothesis. We can automate the application of this tactic, not
through the <TT>dT</TT> tactic, but through the <TT>trivialT</TT>
tactic. The <TT>trivialT</TT> tactic is defined in the module
<TT>Base_auto_tactic</TT>, and it performs &quot;trivial&quot;
reasoning, such as proof by assumption, as is the case here. The
code to add <TT>univ_type</TT> to the trivial tactic has the same
general format as adding to the <TT>dT</TT> tactic: we improve
the <TT>trivial_resource</TT>.</P>

<BLOCKQUOTE>
  <P>5. <I>Automate universal reasoning with the </I><TT>trivialT</TT><I>
  resource:</I></P>
  <BLOCKQUOTE>
    <PRE><B>let</B> trivial_resource =
   Mp_resource.resource_improve trivial_resource (**)
      { auto_name = &quot;nthUnivT&quot;;
        auto_prec = trivial_prec;
        auto_tac = onSomeHypT nthUnivT
      }</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>The <TT>auto_name</TT> is the name of the addition (used for
debugging). The <TT>trivial_prec</TT> is the <I>precedence</I>
of the entry. The <TT>trivialT</TT> resource contains several
tactics, and tactics with <I>lower</I> precedence are tried first.
The precedences are declared with the standard <TT>prec</TT> form.
The final value, <TT>auto_tac</TT>, is the tactic to apply for
trivial reasoning. The <TT>onSomeHypT</TT> tactic tries to apply
the <TT>nthUnivT</TT> to <I>one</I> of the hypotheses in the sequent.</P>

<H3>The <TT>Fol_all</TT> interface</H3>

<P>The definition of the universal quantifier uses the same proof
terms as the <TT>Fol_implies</TT> theory, and so the interface
establishes a dependency between the theories, as well as the
<TT>Fol_univ</TT> theory.</P>

<BLOCKQUOTE>
  <P>6. <I>Declare the logical dependencies and syntax of the universal
  quantifier in the file </I><TT>fol_all.mli:</TT></P>
  <BLOCKQUOTE>
    <PRE><B>include</B> Fol_implies
<B>include</B> Fol_univ

<B>declare</B> &quot;all&quot;{x. 'B['x]}

<B>prec</B> prec_all</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<H3>The <TT>Fol_all</TT> implementation</H3>

<P>The syntax and display forms for the <TT>all</TT> term have
the standard form.</P>

<BLOCKQUOTE>
  <P>7. <I>Declare the syntax and display for the </I><TT>all</TT><I>
  term in the </I><TT>fol_all.ml</TT><I> file:</I></P>
  <BLOCKQUOTE>
    <PRE><B>include</B> Fol_implies
<B>include</B> Fol_univ

<B>declare</B> &quot;all&quot;{x. 'B['x]}

<B>prec</B> prec_all

<B>dform</B> all_df : parens :: &quot;prec&quot;[&quot;prec_all&quot;] :: &quot;all&quot;{x. 'B} =
   szone pushm[3] forall slot{'x} `&quot;.&quot; hspace slot{'B} popm ezone</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>The rules for the <TT>all</TT> term introduce the quantification
over the universe term <TT>univ</TT>.</P>

<BLOCKQUOTE>
  <P>8.<I> Define the typehood, introduction, and elimination forms
  in the </I><TT>fol_all.ml</TT><I> file:</I></P>
  <BLOCKQUOTE>
    <PRE><B>prim</B> all_type 'H 'x :
   sequent ['ext] { 'H; x: univ &gt;- &quot;type&quot;{'B['x]} } --&gt;
   sequent ['ext] { 'H &gt;- &quot;type&quot;{.&quot;all&quot;{y. 'B['y]}} } = trivial

<B>prim</B> all_intro 'H 'x :
   ('b['x] : sequent ['ext] { 'H; x: univ &gt;- 'B['x] }) --&gt;
   sequent ['ext] { 'H &gt;- &quot;all&quot;{y. 'B['y]} } =
   lambda{y. 'b['y]}

<B>prim</B> all_elim 'H 'J 'x 'z 'a :
   sequent ['ext] { 'H; x: &quot;all&quot;{y. 'B['y]}; 'J['x] &gt;- &quot;type&quot;{'a} } --&gt;
   ('b['x; 'z] : sequent ['ext] { 'H; x: &quot;all&quot;{y. 'B['y]}; 'J['x]; z: 'B['a] &gt;- 'C['x] }) --&gt;
   sequent ['ext] { 'H; x: &quot;all&quot;{y. 'B['y]}; 'J['x] &gt;- 'C['x] } =
   'b['x; 'x 'a]</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>The rule for <TT>all_elim</TT> can take some explanation. The
rule states that if the formula <TT>all{y. 'B['y]}</TT> is true
<I>by assumption</I>, then it is true on <I>any</I> formula <TT>'a</TT>.</P>

<P>The automation for the universal quantifier takes care to restrict
the introduction of new variables. Before defining the tactics
for automation, we first define operations on the <I>terms</I>
used to define universal quantification. The term functions are
defined in the <TT>Refiner.Refiner.Term</TT> and <TT>Refiner.Refiner.TermOp</TT>
modules.</P>

<BLOCKQUOTE>
  <P>9.<I> Define term functions for the universal quantifier.</I></P>
  <BLOCKQUOTE>
    <PRE><B>let</B> all_term = &lt;&lt; &quot;all&quot;{y. 'B['y]} &gt;&gt;
<B>let</B> all_opname = opname_of_term all_term
<B>let</B> is_all_term = is_dep1_term all_opname
<B>let</B> dest_all = dest_dep1_term all_opname</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>The <TT>opname_of_term</TT> function returns the operator name
of the quantifier, which is used to define two terms: the <TT>is_all_term</TT>
function tests if a term is a universal quantifier, and the <TT>dest_all</TT>
function returns the bound variable and body of a universal quantifier
(or raise a <TT>RefineError</TT> exception if the term does not
have the right form).</P>

<P>We use these functions to define the tactic for well-formedness
of a universal quantification.</P>

<BLOCKQUOTE>
  <P>10.<I> Define the tactic for proving well-formedness of the
  universal quantifier:</I></P>
  <BLOCKQUOTE>
    <PRE><B>let</B> d_all_type i p =
   <B>if</B> i = 0 then
      <B>let</B> t = dest_type (Sequent.concl p) <B>in</B>
      <B>let</B> v, _ = dest_all t <B>in</B>
      <B>let</B> v = Var.maybe_new_vars1 p v <B>in</B>
         all_type (Sequent.hyp_count_addr p) v p
   <B>else</B>
      <B>raise</B> (RefineError (&quot;d_all_type&quot;, StringError &quot;no elimination form&quot;))
<B>let</B> all_type_term = &lt;&lt; &quot;type&quot;{.&quot;all&quot;{x. 'B['x]}} &gt;&gt;
<B>let</B> d_resource = Mp_resource.resource_improve d_resource (all_type_term, d_all_type)</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>This function computes the new variable <TT>'x</TT> by producing
a new variable from the quantified universal variable.</P>

<P>The tactic for applying introduction and elimination reasoning
has a similar definition.</P>

<BLOCKQUOTE>
  <P>11.<I> Define the tactic for introduction and elimination
  reasoning:</I></P>
  <BLOCKQUOTE>
    <PRE><B>let</B> d_all i p =
   <B>if</B> i = 0 <B>then</B>
      <B>let</B> goal = Sequent.concl p <B>in</B>
      <B>let</B> v, _ = dest_all goal <B>in</B>
      <B>let</B> v = Var.maybe_new_vars1 p v <B>in</B>
         all_intro (Sequent.hyp_count_addr p) v p
   <B>else</B>
      <B>let</B> x, a = Sequent.nth_hyp p i <B>in</B>
      <B>let </B>v, _ = dest_all a <B>in</B>
      <B>let</B> v = Var.maybe_new_vars1 p v <B>in</B>
      <B>let</B> y = get_with_arg p <B>in</B>
      <B>let</B> j, k = Sequent.hyp_indices p i <B>in</B>
         all_elim j k x v y p

<B>let</B> d_resource = Mp_resource.resource_improve d_resource (all_term, d_all)</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>The introduction and eliminations computations both produce
a new variable from the existing quantified variable. The elimination
form also uses the <TT>get_with_arg</TT> function to get the &quot;optional&quot;
argument provided by the user for instantiation. When the <TT>dT</TT>
tactic is used for universal elimination, the user must provide
this argument using the <TT>withT</TT> tactical, like the following:</P>

<BLOCKQUOTE>
  <P><B><TT>refine </TT></B><TT>withT &lt;&lt; &quot;true &gt;&gt;
  (dT 2)</TT></BLOCKQUOTE>

</BODY>
</HTML>
