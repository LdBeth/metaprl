<HTML>
<HEAD>
  <META NAME="GENERATOR" CONTENT="Adobe PageMill 3.0 Win">
  <TITLE>MetaPRL Tutorial: The derived module for negation</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>MetaPRL Tutorial: The derived module for negation</H2>

<H3>Introduction</H3>

<P>Negation is often defined in FOL in terms of <I>implication</I>
and <I>false</I>, with the definition <TT>not{'t} = 't =&gt; false</TT>.
It is possible to define the implication and introduction rules
for negation directly, but it is better to derive the rules from
the rules for negation and falsehood, rather than defining them
as primitive.</P>

<H3><TT>Not</TT> interface</H3>

<P>The interface for negation declares the syntax as usual, but
it establishes a dependency between the <TT>Fol_not</TT> module
and the <TT>Fol_false</TT> and <TT>Fol_implies</TT> modules, and
it declares the negation definition.</P>

<BLOCKQUOTE>
  <P>1. <I>Declare the interface for negation by adding these lines
  to the file </I><TT>fol_not.mli:</TT></P>
  <BLOCKQUOTE>
    <PRE><B><TT>include</TT></B><TT> Fol_false</TT>
<B><TT>include</TT></B><TT> Fol_implies</TT>

<B><TT>declare</TT></B><TT> &quot;not&quot;{'A}</TT>

<B><TT>rewrite</TT></B><TT> unfold_not : &quot;not&quot;{'A} &lt;--&gt; implies{'A; .&quot;false&quot;}</TT>

<B><TT>prec</TT></B><TT> prec_not</TT></PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>The <TT>include</TT> directives establish the logical module
dependencies. The <TT>declare</TT> directive produces the new
syntax, and the <TT>rewrite</TT> term establishes the definition
of <TT>not</TT> using computational rewriting.</P>

<H3><TT>Not</TT> implementation</H3>

<H4>Syntax declarations</H4>

<P>The syntax for negation is established just as in the interface.</P>

<BLOCKQUOTE>
  <P>2.<I> Define the logical dependencing and syntax for negation
  in the </I><TT>fol_not.ml</TT><I> file:</I></P>
  <BLOCKQUOTE>
    <PRE><B>include</B> Fol_false
<B>include</B> Fol_implies

<B>declare</B> &quot;not&quot;{'A}</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<H4>Display</H4>

<P>The display form for negation has the standard format. We include
a precedence declaration for parenthesization.</P>

<BLOCKQUOTE>
  <P>3.<I> Define the display properties of negation:</I></P>
  <BLOCKQUOTE>
    <PRE><B>prec</B> prec_not

<B>dform</B> not_df : parens :: &quot;prec&quot;[&quot;prec_not&quot;] :: &quot;not&quot;{'A} =
   tneg slot{'A}</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<H4>Definition of negation</H4>

<P>Negation is defined as in the interface, as an implication
of falsehood.</P>

<BLOCKQUOTE>
  <P>4. <I>Provide the definition of negation as implication of
  falsehood:</I></P>
  <BLOCKQUOTE>
    <PRE><B>prim_rw</B> unfold_not : &quot;not&quot;{'A} &lt;--&gt; implies{'A; .&quot;false&quot;}</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P>Note that this declaration in the implementation states that
the definition is <I>primitive</I>, where the interface simply
declared the rewrite with the <TT>rewrite</TT> directive.</P>

<H4>Derived Inference Rules</H4>

<P>The <I>rules</I> for negation include the standard properties
of well-formedness and introduction and elimination rules, butthese
rules can be derived from the rules for <I>false</I> and <I>implies</I>.
In the <TT>fol_not.ml</TT> file, we declare the rules as <TT>interactive</TT>,
which states that the rules are presumed valid <I>with a proof
obligation</I> showing that they can be derived. Here is is listing
of the rules.</P>

<BLOCKQUOTE>
  <P>5. <I>Define the derived inference rules for negation:</I></P>
  <BLOCKQUOTE>
    <PRE><B>interactive</B> not_type 'H :
   sequent ['ext] { 'H &gt;- &quot;type&quot;{'A} } --&gt;
   sequent ['ext] { 'H &gt;- &quot;type&quot;{.&quot;not&quot;{'A}} }

<B>interactive</B> not_intro 'H 'x :
   sequent ['ext] { 'H; x: 'A &gt;- &quot;false&quot; } --&gt;
   sequent ['ext] { 'H; x: 'A &gt;- &quot;not&quot;{'A} }

<B>interactive</B> not_elim 'H 'J :
   sequent ['ext] { 'H; x: &quot;not&quot;{'A}; 'J['x] &gt;- 'A } --&gt;
   sequent ['ext] { 'H; x: &quot;not&quot;{'A}; 'J['x] &gt;- 'C['x] }</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<H4>Proving the inference rules</H4>

<P>The next step is to <I>prove</I> these inference rules, which
involves the use of the interactive proof editor. During this
proof, we will be making use of the <TT>dT</TT> tactic to apply
the introduction and elimination rules for <I>false</I> and <I>implies</I>.
To start the proof, compile the FOL module, compile the proof
editor, and start the editor in the module <TT>fol_not</TT> as
follows.</P>

<BLOCKQUOTE>
  <P>6.<I> Start the proof of the rule for </I><TT>not:</TT></P>
  <P><IMG SRC="mp_fol_not1.gif" WIDTH="670" HEIGHT="476" ALIGN="BOTTOM"
  BORDER="0" NATURALSIZEFLAG="3"></P>
</BLOCKQUOTE>

<P>This listing shows that there are three incomplete proof obligations:
the axioms for <TT>not_type</TT>, <TT>not_intro</TT>, and <TT>not_elim</TT>.</P>

<H4>Proving <TT>not_type</TT></H4>

<P>To prove <TT>not_type</TT>, cd to the <TT>not_type</TT> proof:</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not2.gif" WIDTH="670" HEIGHT="284" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>To prove this goal, we first unfold the negation. This requires
<I>opening</I> the <TT>Fol_not</TT> module to get acces to the
definition of negation (<TT>unfold_not</TT>), and then applying
the <TT>unfold_not</TT> rewrite. The <TT>rwh</TT> function converts
the rewrite to a tactic, and applies it to the <I>outermost</I>
occurrence of a <TT>not</TT> term.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not3.gif" WIDTH="670" HEIGHT="284" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>Now that the negation is unfolded to its definition, we can
descend into the first subgoal using the <TT>down</TT> function,
then apply the <TT>dT</TT> tactic to apply the <TT>implies_type</TT>
rule.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not4.gif" WIDTH="670" HEIGHT="404" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>This proof step produces two subgoals: one to prove that <TT>'A</TT>
is a type, and another to prove that <TT>false</TT> is a type.
For the first goal, we use the typehood assumption, using that
tactic <TT>nthAssumT</TT>.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not5.gif" WIDTH="670" HEIGHT="404" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>Note that the application of the <TT>nthAssumT</TT> tactic
produced a <TT>*</TT> on the status line, meaning that this branch
of the proof is complete. To knock off the second subgoal, we
navigate to it with the <TT>up</TT> and <TT>down</TT> functions,
and we apply the <TT>dT</TT> tactic to invoke the <TT>false_type</TT>
rule.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not6.gif" WIDTH="670" HEIGHT="560" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>At this point, all proof obligations have been satisfied, and
the proof is complete.</P>

<P>This was a pretty simple proof, invloving only the use of the
<TT>dT</TT> tactic, and the <TT>nthAssumT</TT> tactic. The <TT>autoT</TT>
tactic performs &quot;automated&quot; proving based on repeated
application of several &quot;basic&quot; tactics including <TT>dT</TT>
and <TT>nthAssumT</TT>. We can navigate back up the proof tree,
and prove the goal in one step.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not7.gif" WIDTH="670" HEIGHT="440" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>The <TT>autoT</TT> tactic proves the goal, and it preserved
the previous subtrees (the roots are listed under the <TT>BY autoT</TT>
line).</P>

<H4>Proving <TT>not_intro</TT></H4>

<P>Using the <TT>autoT</TT> tactic, the rule for <TT>not_intro</TT>
can be proved in one step. We use the <TT>thenT</TT> tactical
to perform <I>sequencing</I>. First, we unfold the negation, then
we apply the <TT>autoT</TT> tactic.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not8.gif" WIDTH="670" HEIGHT="464" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<H4>Proving <TT>not_elim</TT></H4>

<P>The <TT>not_elim</TT> rule is the final peice of reasoning
that we have to perform. The <TT>autoT</TT> tactic does not completely
prove this goal because of <I>folding</I> constraints. The root
of the proof tree can be expanded using the <TT>autoT</TT> tactic.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not9.gif" WIDTH="670" HEIGHT="464" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>The second goal has a trivial proof.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not10.gif" WIDTH="670" HEIGHT="380" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>The first goal is more difficult. The goal uses the hypothesis
<TT>'A =&gt; false</TT>, and the assumption uses the hypothesis
<TT>not{'A}</TT>. MetaPRL does not allow operations on the <I>assumptions</I>,
so we need to <I>fold</I> the implication in the goal back to
a negation. We can do this with the <TT>foldC</TT> conversion.,
which takes the term that is the <I>result </I>of the fold, and
an unfolding conversion, and performs the reverse rewrite.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not11.gif" WIDTH="670" HEIGHT="728" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>This completes the derivation. As a final step, we can change
back to the module directory and check that all obligations have
been satisfied.</P>

<BLOCKQUOTE>
  <PRE><IMG SRC="mp_fol_not12.gif" WIDTH="670" HEIGHT="476" ALIGN="BOTTOM"
BORDER="0" NATURALSIZEFLAG="3"></PRE>
</BLOCKQUOTE>

<P>Finally, we save the theory with the <TT>save</TT> command.</P>

<BLOCKQUOTE>
  <PRE># save ();;
- : unit = ()</PRE>
</BLOCKQUOTE>

<H4>Automation</H4>

<P>We still need to provide the automation for the <TT>dT</TT>
tactic. The following code implements the automation.</P>

<BLOCKQUOTE>
  <P>6. <I>Add the following code to implement <TT>dT</TT></I>
  <I>automation:</I></P>
  <BLOCKQUOTE>
    <PRE><B>let</B> d_not_type i p =
   if i = 0 then
      not_type (Sequent.hyp_count_addr p) p
   else
      raise (RefineError (&quot;d_not_type&quot;, StringError &quot;no elimination form&quot;))
let not_type_term = &lt;&lt; &quot;type&quot;{.&quot;not&quot;{'A}} &gt;&gt;
let d_resource = Mp_resource.resource_improve d_resource (not_type_term, d_not_type)
let d_not i p =
   if i = 0 then
      let x = Var.maybe_new_vars1 p &quot;x&quot; in
         not_intro (Sequent.hyp_count_addr p) x p
   else
      let j, k = Sequent.hyp_indices p i in
         not_elim j k p
let not_term = &lt;&lt; &quot;not&quot;{'A} &gt;&gt;
let d_resource = Mp_resource.resource_improve d_resource (not_term, d_not)</PRE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

</BODY>
</HTML>
