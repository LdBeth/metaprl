########################################################################
# Theory building
#

#
# Unset NATIVE_ENABLED if we are in the mixed compilation mode.
#
NATIVE_ENABLED = $(mem $(COMPILATION_MODE), native both)

#
# When using native code profiling, no need to build theories to bytecode.
#
if $(NATIVE_PROFILING_ENABLED)
   BYTE_ENABLED = false
   export

#
# Commands to compile theory files
#
CAMLP4N = $(file $(LIB)/camlp4n$(EXE))
CAMLP4O = $(file $(LIB)/camlp4o$(EXE))
CONVERT = $(file $(BIN)/convert$(EXE))
PRLCN   = $(file $(BIN)/prlcn$(EXE))
PRLCO   = $(file $(BIN)/prlco$(EXE))
MPTIME =
CAMLP4FLAGS[] =

#
# Other helper files
#
declare THEORYDESCR THEORYNAME

include $(MK)/prlcomp

# Dependency analysis uses -prl flag by default
OCAMLDEPFLAGS += -prl

#
# Make sure we do not try falling back to an OCaml rule for an .ml without an .mli
# See also:
#   http://bugzilla.metaprl.org/show_bug.cgi?id=90
#   http://bugzilla.metaprl.org/show_bug.cgi?id=420
#
%.cmx %.o: %.ml
   @echo $(quote *** Error: MetaPRL file $(in $(ROOT), $(file $<)) $'does not have
***        a corresponding' $(in $(ROOT), $(file $*.mli)))
   exit 1

#
# Reflected theories
#
reflect_%.ppo reflect_%.cmoz: %.cmoz reflect_%.cmiz $(PRLCN) :optional: %.prla :effects: %.prlb :scanner: $(NOSCANNER)
   $(WrapC $(PRLCN)) --reflect -o $*.ppo $<

reflect_%.cmi reflect_%.cmiz: %.cmiz $(PRLCN) :scanner: $(NOSCANNER)
   $(ReflectC $(OCAMLC)) $(OCAMLFLAGS) $(OCAMLCFLAGS) $(OCAMLPPFLAGS) $(PREFIXED_OCAMLINCLUDES) -c -intf $<

reflect_%.cmo: reflect_%.ppo :scanner: $(NOSCANNER)
   $(OCAMLC) $(OCAMLFLAGS) $(OCAMLCFLAGS) $(PREFIXED_OCAMLINCLUDES) -c -impl $<

reflect_%.cmx reflect_%$(EXT_OBJ): reflect_%.ppo :scanner: $(NOSCANNER)
   $(OCAMLOPT) $(OCAMLFLAGS) $(OCAMLOPTFLAGS) $(PREFIXED_OCAMLINCLUDES) -c -impl $<

reflect_%.p4i: %.cmiz $(PRLCO) :value: $(prlc-deps)
   $(WrapC $(PRLCO)) --reflect $(CAMLP4FLAGS) $< > $@

reflect_%.p4: %.cmoz reflect_%.cmiz $(PRLCO) :value: $(prlc-deps)
   $(WrapC $(PRLCO)) --reflect $(CAMLP4FLAGS) $< > $@

#
# For theory files, generate intermediate .ppo files
#
%.ppo %.cmoz: %.ml %.cmiz :optional: %.prla :effects: %.prlb :scanner: scan-ocaml-%.ml :value: $(prlc-deps)
   $(WrapC $(CAMLP4N)) $(CAMLP4FLAGS) -o $*.ppo $*.ml

%.cmi %.cmiz: %.mli :scanner: scan-ocaml-%.mli
   $(PrlC $(OCAMLC)) $(OCAMLFLAGS) $(OCAMLCFLAGS) $(OCAMLPPFLAGS) $(PREFIXED_OCAMLINCLUDES) -c $<

%.cmo: %.ppo %.ml :scanner: scan-ocaml-%.ml
   $(OCAMLC) $(OCAMLFLAGS) $(OCAMLCFLAGS) $(PREFIXED_OCAMLINCLUDES) -c -impl $<

%.cmx %$(EXT_OBJ): %.ppo %.ml :scanner: scan-ocaml-%.ml
   $(OCAMLOPT) $(OCAMLFLAGS) $(OCAMLOPTFLAGS) $(PREFIXED_OCAMLINCLUDES) -c -impl $<

#
# Dependency management
#
if $(SLOPPY_DEPENDENCIES)
   %.cmi %.cmiz:  :squash: $(CAMLP4N)
   %.ppo %.cmoz:  :squash: $(CAMLP4N)

else
   %.cmi %.cmiz: $(CAMLP4N)
   %.ppo %.cmoz: $(CAMLP4N)

%.p4i: %.mli $(CAMLP4O) :value: $(prlc-deps)
   $(WrapC $(CAMLP4O)) $(CAMLP4FLAGS) $*.mli > $@

%.p4: %.ml $(CAMLP4O) :value: $(prlc-deps)
   $(WrapC $(CAMLP4O)) $(CAMLP4FLAGS) $*.ml > $@

if $(mem spell, $(split :, $(MP_DEBUG)))
    LIBWORDS = $(file $(LIB)/words)
    %.ppo: $(LIBWORDS)
    %.p4: $(LIBWORDS)
    export

#
# Add the extra dependencies.  If sloppy dependencies
# is set, squash the dependency chain by using an
# intermediate file.
#
if $(SLOPPY_DEPENDENCIES)
   MPFILTER = $(file .sloppy)
   $(MPFILTER): $(CAMLP4N)
      echo "Sloppy filter dependencies" > $@

   %.cmi %.cmiz: $(MPFILTER)
   %.ppo %.cmoz: $(MPFILTER)

   export
else
   %.cmi %.cmiz: $(CAMLP4N)
   %.ppo %.cmoz: $(CAMLP4N)
   export

########################################################################
# LaTeX documentation
#

#
# Add the inputs directory to the search path.
#
INPUTSDIR = $(dir doc/latex/inputs)
TEXINPUTS += $(INPUTSDIR)

#
# Directory that store the .ps and .pdf files
#
DOCDIR = $(dir doc/ps/theories)

#
# Assume these files are always dependencies.
#
TEXDEPS += $(file $(INPUTSDIR)/rc.bib $(INPUTSDIR)/metaprl.tex)

#
# MetaPRL command
#
MP_SCRIPT = $(file $(EDITOR)/mp$(if $(equal $(OSTYPE), Win32), .bat))
MP_BIN = $(file $(EDITOR)/mp.$(if $(NATIVE_ENABLED), opt, top))

MP_DIRECT_SCRIPTS[] =

if $(NATIVE_ENABLED) 
    MP_DIRECT_SCRIPTS[] += 
        mpopt
    export

if $(BYTE_ENABLED)
    MP_DIRECT_SCRIPTS[] +=
        mptop
    if $(MPRUN_ENABLED)
        MP_DIRECT_SCRIPTS[] +=
            mprun
        export
    export

if $(equal $(OSTYPE), Win32)
    MP_DIRECT_SCRIPTS = $(addsuffix .bat, $(MP_DIRECT_SCRIPTS))
    export

else
    MP_DIRECT_SCRIPTS[] +=
        mpxterm
        mpxterm-large
        mpkonsole
        mpkonsole-large
        mpshell
    if $(not $(equal $(ENSROOT), undefined))
        MP_DIRECT_SCRIPTS[] +=
            mpserver
            mpgossip
        export
    if $(BYTE_ENABLED)
        MP_DIRECT_SCRIPTS[] +=
            mpdebug-top
        if $(MPRUN_ENABLED)
            MP_DIRECT_SCRIPTS[] +=
                mpdebug
            export
        export
    export

MP_DIRECT_SCRIPTS[] = $(file $(addprefix $(EDITOR)/, $(MP_DIRECT_SCRIPTS)))

MP_PREREQS[] =
    $(MP_SCRIPT)
    $(MP_BIN)
    $(file $(EDITOR)/mpconfig)
    $(MP_DIRECT_SCRIPTS)
    $(THEORIES_PATH)
    $(MLDEBUG_PATH)

#
# Build a theory document locally.
# The main goal is to get MetaPRL to generate the TeX files.
#
TheoryDocument(docname, theories) =
    CMOZFILES = $(file $(addsuffix .cmoz, $(theories)))
    THEORIES = $(basename $(theories))

    CMDLINE = $"""set_tex_file "$(absname $(docname).tex)";;
$(concat $(nl), $(add-wrapper $'print_theory "', $'";;', $(THEORIES)))"""
    #
    # Contents of the print.ml file
    #
    $(docname)_print.ml:
        echo $(quote $(CMDLINE)) > $@

    #
    # Get MetaPRL to generate the .tex files
    #
    $(docname).tex $(docname)-body.tex: $(MP_PREREQS) $(CMOZFILES) $(docname)_print.ml
        $(MP_SCRIPT) -batch $(absname $(docname)_print.ml)

#
# Format the document and copy it to the DOCDIR directory.
#
TheoryDocumentInstall(name, theories) =
    TheoryDocument(theory, $(theories))
    LaTeXDocumentInstall(tex, $(DOCDIR), $(name), theory, theory-body)

#
# Also clean up the TeX files in the subdirectories
#
CLEAN += $`(file *.log *.aux *.idx *.ilg *.ind *.pdf *.ps *.dvi *.blg *.bbl *.out *.toc *.fls)

########################################################################
# Subdirectories to build
#

THEORY_DIR = $(dir theories)

#
# the theories will install themselves.
#
InstallTheoryFiles(files) =
    DIR = theories/$(string $(in $(THEORY_DIR), $(CWD)))

    ExportInstallDir($(DIR))
    ExportSubInstall($(DIR), $(filter-targets $(addsuffixes .cmi .cmiz .cmoz .mli, $(files))))

    if $(NATIVE_ENABLED)
        ExportSubInstall($(DIR), theory.cmxa theory$(EXT_LIB))

    if $(BYTE_ENABLED)
        ExportSubInstall($(DIR), theory.cma)

    $(EXPORT)/$(DIR)/MetaprlInfo: MetaprlInfo $(EXPORT)/$(DIR)
        cat $< > $@
        echo "READONLY = true" >> $@

    $(MPINSTALL): $(EXPORT)/$(DIR)/MetaprlInfo

#
# These directories use prlc
#
THEORIES[] = $(split ' ', $(THEORIES))
THEORIES[] = $(if $(mem all, $(THEORIES)), $(THEORIES_ALL) $(filter-out all, $(THEORIES)), $(THEORIES))

THEORY_DEPS[] =

#
# Find a theory in the theory path
# XXX: JYH: we should probably build this kind of search into
# omake.
#
find-theory(name) =
    THEORYNAME = false
    foreach(d, $(THEORYPATH))
        if $(and $(not $(THEORYNAME)), $(file-exists $(d)/$(name)/MetaprlInfo))
            THEORYNAME = $(d)/$(name)
            export
        export
    if $(not $(THEORYNAME))
        if $(not $(defined thydir))
           thydir = unknown
           export
        if $(not $(defined source))
           source = unknown
           export
        eprintln($"!!! ERROR: $(name) ($(in $(ROOT)/theories, $(thydir))) (referenced by the $(source)):")
        eprintln($"!!!        theory directory $(in $(ROOT), $(thydir)) does not exist")
        eprintln($"!!! The current search path is the following:")
        eprintvln($(THEORYPATH))
        exit (1)
    return $(dir $(THEORYNAME))

#
# XXX: JYH: even more, this is very inefficient.
#
find-theories(names) =
    dirs =
        foreach(name, $(names))
            find-theory($(name))
    return $(dirs)


#
# XXX HACK!!!
#
# The .cmoz/.cmx/.o for reflected theories depend on the same things as the one for the original ones.
# Also, all the reflected theories depend on itt_hoas_theory

#
# JYH: comment out, because it is too specific.
# Not all files called reflect_* depend on HOAS (we want
# to allow for hardcoding something else).  In particular,
# this fails on Reflect_base_theory.
#
# REFLECTION_BASE[] =
#     $(file $(find-theory itt/reflection/experimental)/itt_hoas_theory)
# 
# reflect_%.cmi reflect_%.cmiz: %.cmi $(addsuffixes .cmi .cmiz, $(REFLECTION_BASE))
# reflect_%.cmo: %.cmo $(addsuffix .cmi, $(REFLECTION_BASE))
# reflect_%.cmx reflect_%$(EXT_OBJ): %.cmx %$(EXT_OBJ) $(addsuffixes .cmi .cmx, $(REFLECTION_BASE))
# reflect_%.ppo: $(addsuffix .cmiz, $(REFLECTION_BASE))

#
# Compile an entire theory.
#
Theory(files) =
    # XXX: the bool expression is more complex than it has to be because of the Issue 545.
    # if $(not $(and $(THEORYNAME), $(THEORYDESCR)))
    if $(or $(not $(THEORYNAME)), $(not $(THEORYDESCR)))
        eprintln($"!!! ERROR: in $(in $(ROOT), $(CWD)) :")
        if $(not $(THEORYNAME))
            eprintln($"!!!        The THEORYNAME variable is not defined")
        if $(not $(THEORYDESCR))
            eprintln($"!!!        The THEORYDESCR variable is not defined")
        exit(1)

    OCAMLINCLUDES[] += $(find-theories $(THEORY_DEPS))
    OCamlLibrary(theory, $(files))

    .DEFAULT: $(addsuffix .cmoz, $(files))

    $(THEORIES_PATH): $(CWD)

    InstallTheoryFiles($(files))

    export

#
# Search the set of theories that are desired
#
section
    # Default theory for those directories that do not override it
    # Set to empty to force each theory to define its own values.
    THEORYNAME = misc
    THEORYDESCR = Miscellaneous Theories

    OCAMLINCLUDES[] += $(LIB)

    # Theories that we need, including recursive theory dependencies.
    COLLECTED_THEORIES[] =

    PENDING_THEORIES[] =

    # Always use -linkall on Theory libraries
    OCAML_LIB_FLAGS += -linkall

    # Collect the theories that need to be built, paying attention
    # to the value of the THEORY_DEPS variable in each theory.
    TheorySubDir(theories, source) =
        foreach(thy, $(theories))
            thydir = $(find-theory $(thy))
            if $(not $(mem $(thydir), $(COLLECTED_THEORIES)))
                if $(not $(file-exists $(thydir)/MetaprlInfo))
                    eprintln($"!!! ERROR: $(in $(ROOT)/theories, $(thydir)) (referenced by the $(source)):")
                    eprintln($"!!!        theory does not have a MetaprlInfo")
                    exit (1)
                public.VirtualTheory(subdirs) =
                    VIRTUAL_THEORY = true
                    THEORY_DEPS = $(addprefix $(thy)/, $(subdirs))
                    export

                # Every theory depends on the base theory
                THEORY_DEPS[] = meta/base
                VIRTUAL_THEORY = false

                # Actually include the theory.
                READONLY = false
                MLZFILES[] =
                PENDING_THEORIES[] += $(thydir)
                .SUBDIRS: $(thydir)
                    include MetaprlInfo
                    if $(READONLY)
                        # Do not include this directory in the build, but sitll include in the search path
                        $(THEORIES_PATH): $(CWD)
                        remove-project-directories(.)
                        export
                    elseif $(file-exists OMakefile)
                        include OMakefile
                        export
                    else
                        OCamlGeneratedFiles($(addsuffixes .ml .mli, $(MLZFILES)))
                        if $(defined MPFILES)
                            Theory($(MPFILES))
                            export
                        if $(defined PRINT_THEORIES)
                            TheoryDocumentInstall($(basename $(thy)), $(PRINT_THEORIES))
                            CLEAN += theory.tex theory-body.tex theory_print.ml
                            export CLEAN
                        all: theory$(LIB_SUFFIX)
                        clean:
                            $(CLEAN)
                        export
                    export READONLY THEORY_DEPS VIRTUAL_THEORY

                THEORY_DEPS_DIRS = $(dir $(addprefix $(THEORY_DIR)/, $(THEORY_DEPS)))
                if $(intersects $(PENDING_THEORIES), $(THEORY_DEPS_DIRS))
                    eprintln($"!!! ERROR: in $(in $(ROOT), $(thydir)):")
                    eprintln($"!!!        theory dependency ``$(thy): $(intersection $(PENDING_THEORIES), $(THEORY_DEPS_DIRS))'' creates a dependency loop")
                    exit(1)
                TheorySubDir($(THEORY_DEPS), OMakefile in $(in $(ROOT), $(thydir)))
                if $(not $(VIRTUAL_THEORY))
                    COLLECTED_THEORIES += $(thydir)
                    export COLLECTED_THEORIES
                export COLLECTED_THEORIES
            export COLLECTED_THEORIES
        export COLLECTED_THEORIES

    # Start the theory collection process with $(THEORIES)
    TheorySubDir($(THEORIES), THEORIES variable in $(MK)/config)
    export COLLECTED_THEORIES

MP_DIRS[] = $(COLLECTED_THEORIES)
